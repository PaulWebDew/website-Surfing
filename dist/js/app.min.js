/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/functions.js */ \"./src/js/modules/functions.js\");\n/* harmony import */ var _modules_jquery_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/jquery.js */ \"./src/js/modules/jquery.js\");\n/* harmony import */ var _modules_slic_slider_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/slic-slider.js */ \"./src/js/modules/slic-slider.js\");\n\r\n\r\n\r\n\r\n(0,_modules_jquery_js__WEBPACK_IMPORTED_MODULE_1__.jquery)();\r\n(0,_modules_slic_slider_js__WEBPACK_IMPORTED_MODULE_2__.slicSlider)();\r\n_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.isWebp();\r\n\r\n$('.header_slider').slick({\r\n  infinite: true,\r\n  fade: true,\r\n  prevArrow:\r\n    '<img class=\"slider-arrows slider_arrow-left\" src=\"../img/arrows-left.svg\" alt=\"arrow\">',\r\n  nextArrow:\r\n    '<img class=\"slider-arrows slider_arrows-right\" src=\"../img/arrows-right.svg\" alt=\"arrow\">',\r\n  asNavFor: '.slider-dotshead',\r\n});\r\n$('.slider-dotshead').slick({\r\n  slidesToShow: 4,\r\n  slidesToScroll: 4,\r\n  asNavFor: '.header_slider',\r\n  responsive: [\r\n    {\r\n      breakpoint: 961,\r\n      settings: 'unslick',\r\n    },\r\n  ],\r\n  prevArrow:\r\n    '<img class=\"slider-arrows slider_arrow-left\" src=\"../img/arrows-left.svg\" alt=\"arrow\">',\r\n  nextArrow:\r\n    '<img class=\"slider-arrows slider_arrows-right\" src=\"../img/arrows-right.svg\" alt=\"arrow\">',\r\n});\r\n$('.surf-slider').slick({\r\n  slidesToShow: 4,\r\n  slidesToScroll: 1,\r\n  responsive: [\r\n    {\r\n      breakpoint: 1210,\r\n      settings: {\r\n        slidesToShow: 3,\r\n      },\r\n    },\r\n    {\r\n      breakpoint: 900,\r\n      settings: {\r\n        slidesToShow: 2,\r\n      },\r\n    },\r\n    {\r\n      breakpoint: 700,\r\n      settings: {\r\n        slidesToShow: 1,\r\n        centerMode: true,\r\n      },\r\n    },\r\n    {\r\n      breakpoint: 426,\r\n      settings: {\r\n        slidesToShow: 1,\r\n        centerMode: false,\r\n      },\r\n    },\r\n  ],\r\n  prevArrow:\r\n    '<img class=\"slider-arrows slider_arrow-left\" src=\"../img/arrows-left.svg\" alt=\"arrow\">',\r\n  nextArrow:\r\n    '<img class=\"slider-arrows slider_arrows-right\" src=\"../img/arrows-right.svg\" alt=\"arrow\">',\r\n});\r\n$('.slider-map').slick({\r\n  slidesToShow: 8,\r\n  slidesToScroll: 1,\r\n  asNavFor: '.surf-slider',\r\n  focusOnSelect: true,\r\n  responsive: [\r\n    {\r\n      breakpoint: 1103,\r\n      settings: {\r\n        slidesToShow: 3,\r\n      },\r\n    },\r\n    {\r\n      breakpoint: 900,\r\n      settings: {\r\n        slidesToShow: 2,\r\n        centerMode: true,\r\n      },\r\n    },\r\n    {\r\n      breakpoint: 700,\r\n      settings: {\r\n        slidesToShow: 1,\r\n        centerMode: true,\r\n      },\r\n    },\r\n  ],\r\n});\r\n$('.holder_slider, .shop_slider').slick({\r\n  infinite: true,\r\n  fade: true,\r\n  prevArrow:\r\n    '<img class=\"slider-arrows slider_arrow-left\" src=\"../img/arrows-left.svg\" alt=\"arrow\">',\r\n  nextArrow:\r\n    '<img class=\"slider-arrows slider_arrows-right\" src=\"../img/arrows-right.svg\" alt=\"arrow\">',\r\n});\r\n\r\n// =================styling input===============================\r\n$(\r\n  '<div class=\"quantity-nav\"><div class=\"quantity-button quantity-up\"><img src=\"../img/plus.svg\" alt=\"rating\"></div><div class=\"quantity-button quantity-down\"><img src=\"../img/minus.svg\" alt=\"rating\"></div></div>',\r\n).insertAfter('.quantity input');\r\n$('.quantity').each(function () {\r\n  var spinner = $(this),\r\n    input = spinner.find('input[type=\"number\"]'),\r\n    btnUp = spinner.find('.quantity-up'),\r\n    btnDown = spinner.find('.quantity-down'),\r\n    min = input.attr('min'),\r\n    max = input.attr('max');\r\n\r\n  btnUp.on('click', function () {\r\n    var oldValue = parseFloat(input.val());\r\n    if (oldValue >= max) {\r\n      var newVal = oldValue;\r\n    } else {\r\n      var newVal = oldValue + 1;\r\n    }\r\n    spinner.find('input').val(newVal);\r\n    spinner.find('input').trigger('change');\r\n  });\r\n\r\n  btnDown.on('click', function () {\r\n    var oldValue = parseFloat(input.val());\r\n    if (oldValue <= min) {\r\n      var newVal = oldValue;\r\n    } else {\r\n      var newVal = oldValue - 1;\r\n    }\r\n    spinner.find('input').val(newVal);\r\n    spinner.find('input').trigger('change');\r\n  });\r\n});\r\n// =====================calculate the price=====================================\r\n\r\n$('.quantity-button').on('click', function () {\r\n  let summ =\r\n    $('.nights').val() * $('.summ').data('nights') +\r\n    ($('.guests').val() - 1) * $('.summ').data('guests');\r\n  $('.summ').html('$' + summ);\r\n});\r\n\r\n$('.surfboard-box_circle').on('click', function () {\r\n  $(this).toggleClass('active');\r\n});\r\n\r\n// ================open menu on width< 1040px==========================\r\n$('.menu-btn').on('click', function () {\r\n  $('.menu').toggleClass('active');\r\n});\r\nnew WOW().init();\r\n\n\n//# sourceURL=webpack://gulp_2023/./src/js/app.js?");

/***/ }),

/***/ "./src/js/modules/functions.js":
/*!*************************************!*\
  !*** ./src/js/modules/functions.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isWebp\": () => (/* binding */ isWebp)\n/* harmony export */ });\nfunction isWebp() {\r\n  function testWebP(callback) {\r\n    var webP = new Image();\r\n    webP.onload = webP.onerror = function () {\r\n      callback(webP.height == 2);\r\n    };\r\n    webP.src =\r\n      'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';\r\n  }\r\n\r\n  testWebP(function (support) {\r\n    let className = support === true ? 'webp' : 'no-webp';\r\n    document.documentElement.classList.add(className);\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://gulp_2023/./src/js/modules/functions.js?");

/***/ }),

/***/ "./src/js/modules/jquery.js":
/*!**********************************!*\
  !*** ./src/js/modules/jquery.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"jquery\": () => (/* binding */ jquery)\n/* harmony export */ });\n/*!\r\n * jQuery JavaScript Library v3.6.3\r\n * https://jquery.com/\r\n *\r\n * Includes Sizzle.js\r\n * https://sizzlejs.com/\r\n *\r\n * Copyright OpenJS Foundation and other contributors\r\n * Released under the MIT license\r\n * https://jquery.org/license\r\n *\r\n * Date: 2022-12-20T21:28Z\r\n */\r\nfunction jquery(){(function (global, factory) {\r\n  'use strict';\r\n\r\n  if (typeof module === 'object' && typeof module.exports === 'object') {\r\n    // For CommonJS and CommonJS-like environments where a proper `window`\r\n    // is present, execute the factory and get jQuery.\r\n    // For environments that do not have a `window` with a `document`\r\n    // (such as Node.js), expose a factory as module.exports.\r\n    // This accentuates the need for the creation of a real `window`.\r\n    // e.g. var jQuery = require(\"jquery\")(window);\r\n    // See ticket trac-14549 for more info.\r\n    module.exports = global.document\r\n      ? factory(global, true)\r\n      : function (w) {\r\n          if (!w.document) {\r\n            throw new Error('jQuery requires a window with a document');\r\n          }\r\n          return factory(w);\r\n        };\r\n  } else {\r\n    factory(global);\r\n  }\r\n\r\n  // Pass this if window is not defined yet\r\n})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {\r\n  // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\r\n  // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\r\n  // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\r\n  // enough that all such attempts are guarded in a try block.\r\n  'use strict';\r\n\r\n  var arr = [];\r\n\r\n  var getProto = Object.getPrototypeOf;\r\n\r\n  var slice = arr.slice;\r\n\r\n  var flat = arr.flat\r\n    ? function (array) {\r\n        return arr.flat.call(array);\r\n      }\r\n    : function (array) {\r\n        return arr.concat.apply([], array);\r\n      };\r\n\r\n  var push = arr.push;\r\n\r\n  var indexOf = arr.indexOf;\r\n\r\n  var class2type = {};\r\n\r\n  var toString = class2type.toString;\r\n\r\n  var hasOwn = class2type.hasOwnProperty;\r\n\r\n  var fnToString = hasOwn.toString;\r\n\r\n  var ObjectFunctionString = fnToString.call(Object);\r\n\r\n  var support = {};\r\n\r\n  var isFunction = function isFunction(obj) {\r\n    // Support: Chrome <=57, Firefox <=52\r\n    // In some browsers, typeof returns \"function\" for HTML <object> elements\r\n    // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\r\n    // We don't want to classify *any* DOM node as a function.\r\n    // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5\r\n    // Plus for old WebKit, typeof returns \"function\" for HTML collections\r\n    // (e.g., `typeof document.getElementsByTagName(\"div\") === \"function\"`). (gh-4756)\r\n    return (\r\n      typeof obj === 'function' &&\r\n      typeof obj.nodeType !== 'number' &&\r\n      typeof obj.item !== 'function'\r\n    );\r\n  };\r\n\r\n  var isWindow = function isWindow(obj) {\r\n    return obj != null && obj === obj.window;\r\n  };\r\n\r\n  var document = window.document;\r\n\r\n  var preservedScriptAttributes = {\r\n    type: true,\r\n    src: true,\r\n    nonce: true,\r\n    noModule: true,\r\n  };\r\n\r\n  function DOMEval(code, node, doc) {\r\n    doc = doc || document;\r\n\r\n    var i,\r\n      val,\r\n      script = doc.createElement('script');\r\n\r\n    script.text = code;\r\n    if (node) {\r\n      for (i in preservedScriptAttributes) {\r\n        // Support: Firefox 64+, Edge 18+\r\n        // Some browsers don't support the \"nonce\" property on scripts.\r\n        // On the other hand, just using `getAttribute` is not enough as\r\n        // the `nonce` attribute is reset to an empty string whenever it\r\n        // becomes browsing-context connected.\r\n        // See https://github.com/whatwg/html/issues/2369\r\n        // See https://html.spec.whatwg.org/#nonce-attributes\r\n        // The `node.getAttribute` check was added for the sake of\r\n        // `jQuery.globalEval` so that it can fake a nonce-containing node\r\n        // via an object.\r\n        val = node[i] || (node.getAttribute && node.getAttribute(i));\r\n        if (val) {\r\n          script.setAttribute(i, val);\r\n        }\r\n      }\r\n    }\r\n    doc.head.appendChild(script).parentNode.removeChild(script);\r\n  }\r\n\r\n  function toType(obj) {\r\n    if (obj == null) {\r\n      return obj + '';\r\n    }\r\n\r\n    // Support: Android <=2.3 only (functionish RegExp)\r\n    return typeof obj === 'object' || typeof obj === 'function'\r\n      ? class2type[toString.call(obj)] || 'object'\r\n      : typeof obj;\r\n  }\r\n  /* global Symbol */\r\n  // Defining this global in .eslintrc.json would create a danger of using the global\r\n  // unguarded in another place, it seems safer to define global only for this module\r\n\r\n  var version = '3.6.3',\r\n    // Define a local copy of jQuery\r\n    jQuery = function (selector, context) {\r\n      // The jQuery object is actually just the init constructor 'enhanced'\r\n      // Need init if jQuery is called (just allow error to be thrown if not included)\r\n      return new jQuery.fn.init(selector, context);\r\n    };\r\n\r\n  jQuery.fn = jQuery.prototype = {\r\n    // The current version of jQuery being used\r\n    jquery: version,\r\n\r\n    constructor: jQuery,\r\n\r\n    // The default length of a jQuery object is 0\r\n    length: 0,\r\n\r\n    toArray: function () {\r\n      return slice.call(this);\r\n    },\r\n\r\n    // Get the Nth element in the matched element set OR\r\n    // Get the whole matched element set as a clean array\r\n    get: function (num) {\r\n      // Return all the elements in a clean array\r\n      if (num == null) {\r\n        return slice.call(this);\r\n      }\r\n\r\n      // Return just the one element from the set\r\n      return num < 0 ? this[num + this.length] : this[num];\r\n    },\r\n\r\n    // Take an array of elements and push it onto the stack\r\n    // (returning the new matched element set)\r\n    pushStack: function (elems) {\r\n      // Build a new jQuery matched element set\r\n      var ret = jQuery.merge(this.constructor(), elems);\r\n\r\n      // Add the old object onto the stack (as a reference)\r\n      ret.prevObject = this;\r\n\r\n      // Return the newly-formed element set\r\n      return ret;\r\n    },\r\n\r\n    // Execute a callback for every element in the matched set.\r\n    each: function (callback) {\r\n      return jQuery.each(this, callback);\r\n    },\r\n\r\n    map: function (callback) {\r\n      return this.pushStack(\r\n        jQuery.map(this, function (elem, i) {\r\n          return callback.call(elem, i, elem);\r\n        }),\r\n      );\r\n    },\r\n\r\n    slice: function () {\r\n      return this.pushStack(slice.apply(this, arguments));\r\n    },\r\n\r\n    first: function () {\r\n      return this.eq(0);\r\n    },\r\n\r\n    last: function () {\r\n      return this.eq(-1);\r\n    },\r\n\r\n    even: function () {\r\n      return this.pushStack(\r\n        jQuery.grep(this, function (_elem, i) {\r\n          return (i + 1) % 2;\r\n        }),\r\n      );\r\n    },\r\n\r\n    odd: function () {\r\n      return this.pushStack(\r\n        jQuery.grep(this, function (_elem, i) {\r\n          return i % 2;\r\n        }),\r\n      );\r\n    },\r\n\r\n    eq: function (i) {\r\n      var len = this.length,\r\n        j = +i + (i < 0 ? len : 0);\r\n      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);\r\n    },\r\n\r\n    end: function () {\r\n      return this.prevObject || this.constructor();\r\n    },\r\n\r\n    // For internal use only.\r\n    // Behaves like an Array's method, not like a jQuery method.\r\n    push: push,\r\n    sort: arr.sort,\r\n    splice: arr.splice,\r\n  };\r\n\r\n  jQuery.extend = jQuery.fn.extend = function () {\r\n    var options,\r\n      name,\r\n      src,\r\n      copy,\r\n      copyIsArray,\r\n      clone,\r\n      target = arguments[0] || {},\r\n      i = 1,\r\n      length = arguments.length,\r\n      deep = false;\r\n\r\n    // Handle a deep copy situation\r\n    if (typeof target === 'boolean') {\r\n      deep = target;\r\n\r\n      // Skip the boolean and the target\r\n      target = arguments[i] || {};\r\n      i++;\r\n    }\r\n\r\n    // Handle case when target is a string or something (possible in deep copy)\r\n    if (typeof target !== 'object' && !isFunction(target)) {\r\n      target = {};\r\n    }\r\n\r\n    // Extend jQuery itself if only one argument is passed\r\n    if (i === length) {\r\n      target = this;\r\n      i--;\r\n    }\r\n\r\n    for (; i < length; i++) {\r\n      // Only deal with non-null/undefined values\r\n      if ((options = arguments[i]) != null) {\r\n        // Extend the base object\r\n        for (name in options) {\r\n          copy = options[name];\r\n\r\n          // Prevent Object.prototype pollution\r\n          // Prevent never-ending loop\r\n          if (name === '__proto__' || target === copy) {\r\n            continue;\r\n          }\r\n\r\n          // Recurse if we're merging plain objects or arrays\r\n          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\r\n            src = target[name];\r\n\r\n            // Ensure proper type for the source value\r\n            if (copyIsArray && !Array.isArray(src)) {\r\n              clone = [];\r\n            } else if (!copyIsArray && !jQuery.isPlainObject(src)) {\r\n              clone = {};\r\n            } else {\r\n              clone = src;\r\n            }\r\n            copyIsArray = false;\r\n\r\n            // Never move original objects, clone them\r\n            target[name] = jQuery.extend(deep, clone, copy);\r\n\r\n            // Don't bring in undefined values\r\n          } else if (copy !== undefined) {\r\n            target[name] = copy;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Return the modified object\r\n    return target;\r\n  };\r\n\r\n  jQuery.extend({\r\n    // Unique for each copy of jQuery on the page\r\n    expando: 'jQuery' + (version + Math.random()).replace(/\\D/g, ''),\r\n\r\n    // Assume jQuery is ready without the ready module\r\n    isReady: true,\r\n\r\n    error: function (msg) {\r\n      throw new Error(msg);\r\n    },\r\n\r\n    noop: function () {},\r\n\r\n    isPlainObject: function (obj) {\r\n      var proto, Ctor;\r\n\r\n      // Detect obvious negatives\r\n      // Use toString instead of jQuery.type to catch host objects\r\n      if (!obj || toString.call(obj) !== '[object Object]') {\r\n        return false;\r\n      }\r\n\r\n      proto = getProto(obj);\r\n\r\n      // Objects with no prototype (e.g., `Object.create( null )`) are plain\r\n      if (!proto) {\r\n        return true;\r\n      }\r\n\r\n      // Objects with prototype are plain iff they were constructed by a global Object function\r\n      Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;\r\n      return typeof Ctor === 'function' && fnToString.call(Ctor) === ObjectFunctionString;\r\n    },\r\n\r\n    isEmptyObject: function (obj) {\r\n      var name;\r\n\r\n      for (name in obj) {\r\n        return false;\r\n      }\r\n      return true;\r\n    },\r\n\r\n    // Evaluates a script in a provided context; falls back to the global one\r\n    // if not specified.\r\n    globalEval: function (code, options, doc) {\r\n      DOMEval(code, { nonce: options && options.nonce }, doc);\r\n    },\r\n\r\n    each: function (obj, callback) {\r\n      var length,\r\n        i = 0;\r\n\r\n      if (isArrayLike(obj)) {\r\n        length = obj.length;\r\n        for (; i < length; i++) {\r\n          if (callback.call(obj[i], i, obj[i]) === false) {\r\n            break;\r\n          }\r\n        }\r\n      } else {\r\n        for (i in obj) {\r\n          if (callback.call(obj[i], i, obj[i]) === false) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return obj;\r\n    },\r\n\r\n    // results is for internal usage only\r\n    makeArray: function (arr, results) {\r\n      var ret = results || [];\r\n\r\n      if (arr != null) {\r\n        if (isArrayLike(Object(arr))) {\r\n          jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);\r\n        } else {\r\n          push.call(ret, arr);\r\n        }\r\n      }\r\n\r\n      return ret;\r\n    },\r\n\r\n    inArray: function (elem, arr, i) {\r\n      return arr == null ? -1 : indexOf.call(arr, elem, i);\r\n    },\r\n\r\n    // Support: Android <=4.0 only, PhantomJS 1 only\r\n    // push.apply(_, arraylike) throws on ancient WebKit\r\n    merge: function (first, second) {\r\n      var len = +second.length,\r\n        j = 0,\r\n        i = first.length;\r\n\r\n      for (; j < len; j++) {\r\n        first[i++] = second[j];\r\n      }\r\n\r\n      first.length = i;\r\n\r\n      return first;\r\n    },\r\n\r\n    grep: function (elems, callback, invert) {\r\n      var callbackInverse,\r\n        matches = [],\r\n        i = 0,\r\n        length = elems.length,\r\n        callbackExpect = !invert;\r\n\r\n      // Go through the array, only saving the items\r\n      // that pass the validator function\r\n      for (; i < length; i++) {\r\n        callbackInverse = !callback(elems[i], i);\r\n        if (callbackInverse !== callbackExpect) {\r\n          matches.push(elems[i]);\r\n        }\r\n      }\r\n\r\n      return matches;\r\n    },\r\n\r\n    // arg is for internal usage only\r\n    map: function (elems, callback, arg) {\r\n      var length,\r\n        value,\r\n        i = 0,\r\n        ret = [];\r\n\r\n      // Go through the array, translating each of the items to their new values\r\n      if (isArrayLike(elems)) {\r\n        length = elems.length;\r\n        for (; i < length; i++) {\r\n          value = callback(elems[i], i, arg);\r\n\r\n          if (value != null) {\r\n            ret.push(value);\r\n          }\r\n        }\r\n\r\n        // Go through every key on the object,\r\n      } else {\r\n        for (i in elems) {\r\n          value = callback(elems[i], i, arg);\r\n\r\n          if (value != null) {\r\n            ret.push(value);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Flatten any nested arrays\r\n      return flat(ret);\r\n    },\r\n\r\n    // A global GUID counter for objects\r\n    guid: 1,\r\n\r\n    // jQuery.support is not used in Core but other projects attach their\r\n    // properties to it so it needs to exist.\r\n    support: support,\r\n  });\r\n\r\n  if (typeof Symbol === 'function') {\r\n    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];\r\n  }\r\n\r\n  // Populate the class2type map\r\n  jQuery.each(\r\n    'Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '),\r\n    function (_i, name) {\r\n      class2type['[object ' + name + ']'] = name.toLowerCase();\r\n    },\r\n  );\r\n\r\n  function isArrayLike(obj) {\r\n    // Support: real iOS 8.2 only (not reproducible in simulator)\r\n    // `in` check used to prevent JIT error (gh-2145)\r\n    // hasOwn isn't used here due to false negatives\r\n    // regarding Nodelist length in IE\r\n    var length = !!obj && 'length' in obj && obj.length,\r\n      type = toType(obj);\r\n\r\n    if (isFunction(obj) || isWindow(obj)) {\r\n      return false;\r\n    }\r\n\r\n    return (\r\n      type === 'array' ||\r\n      length === 0 ||\r\n      (typeof length === 'number' && length > 0 && length - 1 in obj)\r\n    );\r\n  }\r\n  var Sizzle =\r\n    /*!\r\n     * Sizzle CSS Selector Engine v2.3.9\r\n     * https://sizzlejs.com/\r\n     *\r\n     * Copyright JS Foundation and other contributors\r\n     * Released under the MIT license\r\n     * https://js.foundation/\r\n     *\r\n     * Date: 2022-12-19\r\n     */\r\n    (function (window) {\r\n      var i,\r\n        support,\r\n        Expr,\r\n        getText,\r\n        isXML,\r\n        tokenize,\r\n        compile,\r\n        select,\r\n        outermostContext,\r\n        sortInput,\r\n        hasDuplicate,\r\n        // Local document vars\r\n        setDocument,\r\n        document,\r\n        docElem,\r\n        documentIsHTML,\r\n        rbuggyQSA,\r\n        rbuggyMatches,\r\n        matches,\r\n        contains,\r\n        // Instance-specific data\r\n        expando = 'sizzle' + 1 * new Date(),\r\n        preferredDoc = window.document,\r\n        dirruns = 0,\r\n        done = 0,\r\n        classCache = createCache(),\r\n        tokenCache = createCache(),\r\n        compilerCache = createCache(),\r\n        nonnativeSelectorCache = createCache(),\r\n        sortOrder = function (a, b) {\r\n          if (a === b) {\r\n            hasDuplicate = true;\r\n          }\r\n          return 0;\r\n        },\r\n        // Instance methods\r\n        hasOwn = {}.hasOwnProperty,\r\n        arr = [],\r\n        pop = arr.pop,\r\n        pushNative = arr.push,\r\n        push = arr.push,\r\n        slice = arr.slice,\r\n        // Use a stripped-down indexOf as it's faster than native\r\n        // https://jsperf.com/thor-indexof-vs-for/5\r\n        indexOf = function (list, elem) {\r\n          var i = 0,\r\n            len = list.length;\r\n          for (; i < len; i++) {\r\n            if (list[i] === elem) {\r\n              return i;\r\n            }\r\n          }\r\n          return -1;\r\n        },\r\n        booleans =\r\n          'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|' +\r\n          'ismap|loop|multiple|open|readonly|required|scoped',\r\n        // Regular expressions\r\n\r\n        // http://www.w3.org/TR/css3-selectors/#whitespace\r\n        whitespace = '[\\\\x20\\\\t\\\\r\\\\n\\\\f]',\r\n        // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\r\n        identifier =\r\n          '(?:\\\\\\\\[\\\\da-fA-F]{1,6}' + whitespace + '?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+',\r\n        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\r\n        attributes =\r\n          '\\\\[' +\r\n          whitespace +\r\n          '*(' +\r\n          identifier +\r\n          ')(?:' +\r\n          whitespace +\r\n          // Operator (capture 2)\r\n          '*([*^$|!~]?=)' +\r\n          whitespace +\r\n          // \"Attribute values must be CSS identifiers [capture 5]\r\n          // or strings [capture 3 or capture 4]\"\r\n          '*(?:\\'((?:\\\\\\\\.|[^\\\\\\\\\\'])*)\\'|\"((?:\\\\\\\\.|[^\\\\\\\\\"])*)\"|(' +\r\n          identifier +\r\n          '))|)' +\r\n          whitespace +\r\n          '*\\\\]',\r\n        pseudos =\r\n          ':(' +\r\n          identifier +\r\n          ')(?:\\\\((' +\r\n          // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\r\n          // 1. quoted (capture 3; capture 4 or capture 5)\r\n          '(\\'((?:\\\\\\\\.|[^\\\\\\\\\\'])*)\\'|\"((?:\\\\\\\\.|[^\\\\\\\\\"])*)\")|' +\r\n          // 2. simple (capture 6)\r\n          '((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|' +\r\n          attributes +\r\n          ')*)|' +\r\n          // 3. anything else (capture 2)\r\n          '.*' +\r\n          ')\\\\)|)',\r\n        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\r\n        rwhitespace = new RegExp(whitespace + '+', 'g'),\r\n        rtrim = new RegExp(\r\n          '^' + whitespace + '+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)' + whitespace + '+$',\r\n          'g',\r\n        ),\r\n        rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'),\r\n        rcombinators = new RegExp(\r\n          '^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*',\r\n        ),\r\n        rdescend = new RegExp(whitespace + '|>'),\r\n        rpseudo = new RegExp(pseudos),\r\n        ridentifier = new RegExp('^' + identifier + '$'),\r\n        matchExpr = {\r\n          ID: new RegExp('^#(' + identifier + ')'),\r\n          CLASS: new RegExp('^\\\\.(' + identifier + ')'),\r\n          TAG: new RegExp('^(' + identifier + '|[*])'),\r\n          ATTR: new RegExp('^' + attributes),\r\n          PSEUDO: new RegExp('^' + pseudos),\r\n          CHILD: new RegExp(\r\n            '^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(' +\r\n              whitespace +\r\n              '*(even|odd|(([+-]|)(\\\\d*)n|)' +\r\n              whitespace +\r\n              '*(?:([+-]|)' +\r\n              whitespace +\r\n              '*(\\\\d+)|))' +\r\n              whitespace +\r\n              '*\\\\)|)',\r\n            'i',\r\n          ),\r\n          bool: new RegExp('^(?:' + booleans + ')$', 'i'),\r\n\r\n          // For use in libraries implementing .is()\r\n          // We use this for POS matching in `select`\r\n          needsContext: new RegExp(\r\n            '^' +\r\n              whitespace +\r\n              '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(' +\r\n              whitespace +\r\n              '*((?:-\\\\d)?\\\\d*)' +\r\n              whitespace +\r\n              '*\\\\)|)(?=[^-]|$)',\r\n            'i',\r\n          ),\r\n        },\r\n        rhtml = /HTML$/i,\r\n        rinputs = /^(?:input|select|textarea|button)$/i,\r\n        rheader = /^h\\d$/i,\r\n        rnative = /^[^{]+\\{\\s*\\[native \\w/,\r\n        // Easily-parseable/retrievable ID or TAG or CLASS selectors\r\n        rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\r\n        rsibling = /[+~]/,\r\n        // CSS escapes\r\n        // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\r\n        runescape = new RegExp('\\\\\\\\[\\\\da-fA-F]{1,6}' + whitespace + '?|\\\\\\\\([^\\\\r\\\\n\\\\f])', 'g'),\r\n        funescape = function (escape, nonHex) {\r\n          var high = '0x' + escape.slice(1) - 0x10000;\r\n\r\n          return nonHex\r\n            ? // Strip the backslash prefix from a non-hex escape sequence\r\n              nonHex\r\n            : // Replace a hexadecimal escape sequence with the encoded Unicode code point\r\n            // Support: IE <=11+\r\n            // For values outside the Basic Multilingual Plane (BMP), manually construct a\r\n            // surrogate pair\r\n            high < 0\r\n            ? String.fromCharCode(high + 0x10000)\r\n            : String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);\r\n        },\r\n        // CSS string/identifier serialization\r\n        // https://drafts.csswg.org/cssom/#common-serializing-idioms\r\n        rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\r\n        fcssescape = function (ch, asCodePoint) {\r\n          if (asCodePoint) {\r\n            // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\r\n            if (ch === '\\0') {\r\n              return '\\uFFFD';\r\n            }\r\n\r\n            // Control characters and (dependent upon position) numbers get escaped as code points\r\n            return ch.slice(0, -1) + '\\\\' + ch.charCodeAt(ch.length - 1).toString(16) + ' ';\r\n          }\r\n\r\n          // Other potentially-special ASCII characters get backslash-escaped\r\n          return '\\\\' + ch;\r\n        },\r\n        // Used for iframes\r\n        // See setDocument()\r\n        // Removing the function wrapper causes a \"Permission Denied\"\r\n        // error in IE\r\n        unloadHandler = function () {\r\n          setDocument();\r\n        },\r\n        inDisabledFieldset = addCombinator(\r\n          function (elem) {\r\n            return elem.disabled === true && elem.nodeName.toLowerCase() === 'fieldset';\r\n          },\r\n          { dir: 'parentNode', next: 'legend' },\r\n        );\r\n\r\n      // Optimize for push.apply( _, NodeList )\r\n      try {\r\n        push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);\r\n\r\n        // Support: Android<4.0\r\n        // Detect silently failing push.apply\r\n        // eslint-disable-next-line no-unused-expressions\r\n        arr[preferredDoc.childNodes.length].nodeType;\r\n      } catch (e) {\r\n        push = {\r\n          apply: arr.length\r\n            ? // Leverage slice if possible\r\n              function (target, els) {\r\n                pushNative.apply(target, slice.call(els));\r\n              }\r\n            : // Support: IE<9\r\n              // Otherwise append directly\r\n              function (target, els) {\r\n                var j = target.length,\r\n                  i = 0;\r\n\r\n                // Can't trust NodeList.length\r\n                while ((target[j++] = els[i++])) {}\r\n                target.length = j - 1;\r\n              },\r\n        };\r\n      }\r\n\r\n      function Sizzle(selector, context, results, seed) {\r\n        var m,\r\n          i,\r\n          elem,\r\n          nid,\r\n          match,\r\n          groups,\r\n          newSelector,\r\n          newContext = context && context.ownerDocument,\r\n          // nodeType defaults to 9, since context defaults to document\r\n          nodeType = context ? context.nodeType : 9;\r\n\r\n        results = results || [];\r\n\r\n        // Return early from calls with invalid selector or context\r\n        if (\r\n          typeof selector !== 'string' ||\r\n          !selector ||\r\n          (nodeType !== 1 && nodeType !== 9 && nodeType !== 11)\r\n        ) {\r\n          return results;\r\n        }\r\n\r\n        // Try to shortcut find operations (as opposed to filters) in HTML documents\r\n        if (!seed) {\r\n          setDocument(context);\r\n          context = context || document;\r\n\r\n          if (documentIsHTML) {\r\n            // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\r\n            // (excepting DocumentFragment context, where the methods don't exist)\r\n            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\r\n              // ID selector\r\n              if ((m = match[1])) {\r\n                // Document context\r\n                if (nodeType === 9) {\r\n                  if ((elem = context.getElementById(m))) {\r\n                    // Support: IE, Opera, Webkit\r\n                    // TODO: identify versions\r\n                    // getElementById can match elements by name instead of ID\r\n                    if (elem.id === m) {\r\n                      results.push(elem);\r\n                      return results;\r\n                    }\r\n                  } else {\r\n                    return results;\r\n                  }\r\n\r\n                  // Element context\r\n                } else {\r\n                  // Support: IE, Opera, Webkit\r\n                  // TODO: identify versions\r\n                  // getElementById can match elements by name instead of ID\r\n                  if (\r\n                    newContext &&\r\n                    (elem = newContext.getElementById(m)) &&\r\n                    contains(context, elem) &&\r\n                    elem.id === m\r\n                  ) {\r\n                    results.push(elem);\r\n                    return results;\r\n                  }\r\n                }\r\n\r\n                // Type selector\r\n              } else if (match[2]) {\r\n                push.apply(results, context.getElementsByTagName(selector));\r\n                return results;\r\n\r\n                // Class selector\r\n              } else if (\r\n                (m = match[3]) &&\r\n                support.getElementsByClassName &&\r\n                context.getElementsByClassName\r\n              ) {\r\n                push.apply(results, context.getElementsByClassName(m));\r\n                return results;\r\n              }\r\n            }\r\n\r\n            // Take advantage of querySelectorAll\r\n            if (\r\n              support.qsa &&\r\n              !nonnativeSelectorCache[selector + ' '] &&\r\n              (!rbuggyQSA || !rbuggyQSA.test(selector)) &&\r\n              // Support: IE 8 only\r\n              // Exclude object elements\r\n              (nodeType !== 1 || context.nodeName.toLowerCase() !== 'object')\r\n            ) {\r\n              newSelector = selector;\r\n              newContext = context;\r\n\r\n              // qSA considers elements outside a scoping root when evaluating child or\r\n              // descendant combinators, which is not what we want.\r\n              // In such cases, we work around the behavior by prefixing every selector in the\r\n              // list with an ID selector referencing the scope context.\r\n              // The technique has to be used as well when a leading combinator is used\r\n              // as such selectors are not recognized by querySelectorAll.\r\n              // Thanks to Andrew Dupont for this technique.\r\n              if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {\r\n                // Expand context for sibling selectors\r\n                newContext =\r\n                  (rsibling.test(selector) && testContext(context.parentNode)) || context;\r\n\r\n                // We can use :scope instead of the ID hack if the browser\r\n                // supports it & if we're not changing the context.\r\n                if (newContext !== context || !support.scope) {\r\n                  // Capture the context ID, setting it first if necessary\r\n                  if ((nid = context.getAttribute('id'))) {\r\n                    nid = nid.replace(rcssescape, fcssescape);\r\n                  } else {\r\n                    context.setAttribute('id', (nid = expando));\r\n                  }\r\n                }\r\n\r\n                // Prefix every selector in the list\r\n                groups = tokenize(selector);\r\n                i = groups.length;\r\n                while (i--) {\r\n                  groups[i] = (nid ? '#' + nid : ':scope') + ' ' + toSelector(groups[i]);\r\n                }\r\n                newSelector = groups.join(',');\r\n              }\r\n\r\n              try {\r\n                // `qSA` may not throw for unrecognized parts using forgiving parsing:\r\n                // https://drafts.csswg.org/selectors/#forgiving-selector\r\n                // like the `:has()` pseudo-class:\r\n                // https://drafts.csswg.org/selectors/#relational\r\n                // `CSS.supports` is still expected to return `false` then:\r\n                // https://drafts.csswg.org/css-conditional-4/#typedef-supports-selector-fn\r\n                // https://drafts.csswg.org/css-conditional-4/#dfn-support-selector\r\n                if (\r\n                  support.cssSupportsSelector &&\r\n                  // eslint-disable-next-line no-undef\r\n                  !CSS.supports('selector(:is(' + newSelector + '))')\r\n                ) {\r\n                  // Support: IE 11+\r\n                  // Throw to get to the same code path as an error directly in qSA.\r\n                  // Note: once we only support browser supporting\r\n                  // `CSS.supports('selector(...)')`, we can most likely drop\r\n                  // the `try-catch`. IE doesn't implement the API.\r\n                  throw new Error();\r\n                }\r\n\r\n                push.apply(results, newContext.querySelectorAll(newSelector));\r\n                return results;\r\n              } catch (qsaError) {\r\n                nonnativeSelectorCache(selector, true);\r\n              } finally {\r\n                if (nid === expando) {\r\n                  context.removeAttribute('id');\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        // All others\r\n        return select(selector.replace(rtrim, '$1'), context, results, seed);\r\n      }\r\n\r\n      /**\r\n       * Create key-value caches of limited size\r\n       * @returns {function(string, object)} Returns the Object data after storing it on itself with\r\n       *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\r\n       *\tdeleting the oldest entry\r\n       */\r\n      function createCache() {\r\n        var keys = [];\r\n\r\n        function cache(key, value) {\r\n          // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\r\n          if (keys.push(key + ' ') > Expr.cacheLength) {\r\n            // Only keep the most recent entries\r\n            delete cache[keys.shift()];\r\n          }\r\n          return (cache[key + ' '] = value);\r\n        }\r\n        return cache;\r\n      }\r\n\r\n      /**\r\n       * Mark a function for special use by Sizzle\r\n       * @param {Function} fn The function to mark\r\n       */\r\n      function markFunction(fn) {\r\n        fn[expando] = true;\r\n        return fn;\r\n      }\r\n\r\n      /**\r\n       * Support testing using an element\r\n       * @param {Function} fn Passed the created element and returns a boolean result\r\n       */\r\n      function assert(fn) {\r\n        var el = document.createElement('fieldset');\r\n\r\n        try {\r\n          return !!fn(el);\r\n        } catch (e) {\r\n          return false;\r\n        } finally {\r\n          // Remove from its parent by default\r\n          if (el.parentNode) {\r\n            el.parentNode.removeChild(el);\r\n          }\r\n\r\n          // release memory in IE\r\n          el = null;\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Adds the same handler for all of the specified attrs\r\n       * @param {String} attrs Pipe-separated list of attributes\r\n       * @param {Function} handler The method that will be applied\r\n       */\r\n      function addHandle(attrs, handler) {\r\n        var arr = attrs.split('|'),\r\n          i = arr.length;\r\n\r\n        while (i--) {\r\n          Expr.attrHandle[arr[i]] = handler;\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Checks document order of two siblings\r\n       * @param {Element} a\r\n       * @param {Element} b\r\n       * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\r\n       */\r\n      function siblingCheck(a, b) {\r\n        var cur = b && a,\r\n          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;\r\n\r\n        // Use IE sourceIndex if available on both nodes\r\n        if (diff) {\r\n          return diff;\r\n        }\r\n\r\n        // Check if b follows a\r\n        if (cur) {\r\n          while ((cur = cur.nextSibling)) {\r\n            if (cur === b) {\r\n              return -1;\r\n            }\r\n          }\r\n        }\r\n\r\n        return a ? 1 : -1;\r\n      }\r\n\r\n      /**\r\n       * Returns a function to use in pseudos for input types\r\n       * @param {String} type\r\n       */\r\n      function createInputPseudo(type) {\r\n        return function (elem) {\r\n          var name = elem.nodeName.toLowerCase();\r\n          return name === 'input' && elem.type === type;\r\n        };\r\n      }\r\n\r\n      /**\r\n       * Returns a function to use in pseudos for buttons\r\n       * @param {String} type\r\n       */\r\n      function createButtonPseudo(type) {\r\n        return function (elem) {\r\n          var name = elem.nodeName.toLowerCase();\r\n          return (name === 'input' || name === 'button') && elem.type === type;\r\n        };\r\n      }\r\n\r\n      /**\r\n       * Returns a function to use in pseudos for :enabled/:disabled\r\n       * @param {Boolean} disabled true for :disabled; false for :enabled\r\n       */\r\n      function createDisabledPseudo(disabled) {\r\n        // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\r\n        return function (elem) {\r\n          // Only certain elements can match :enabled or :disabled\r\n          // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\r\n          // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\r\n          if ('form' in elem) {\r\n            // Check for inherited disabledness on relevant non-disabled elements:\r\n            // * listed form-associated elements in a disabled fieldset\r\n            //   https://html.spec.whatwg.org/multipage/forms.html#category-listed\r\n            //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\r\n            // * option elements in a disabled optgroup\r\n            //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\r\n            // All such elements have a \"form\" property.\r\n            if (elem.parentNode && elem.disabled === false) {\r\n              // Option elements defer to a parent optgroup if present\r\n              if ('label' in elem) {\r\n                if ('label' in elem.parentNode) {\r\n                  return elem.parentNode.disabled === disabled;\r\n                } else {\r\n                  return elem.disabled === disabled;\r\n                }\r\n              }\r\n\r\n              // Support: IE 6 - 11\r\n              // Use the isDisabled shortcut property to check for disabled fieldset ancestors\r\n              return (\r\n                elem.isDisabled === disabled ||\r\n                // Where there is no isDisabled, check manually\r\n                /* jshint -W018 */\r\n                (elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled)\r\n              );\r\n            }\r\n\r\n            return elem.disabled === disabled;\r\n\r\n            // Try to winnow out elements that can't be disabled before trusting the disabled property.\r\n            // Some victims get caught in our net (label, legend, menu, track), but it shouldn't\r\n            // even exist on them, let alone have a boolean value.\r\n          } else if ('label' in elem) {\r\n            return elem.disabled === disabled;\r\n          }\r\n\r\n          // Remaining elements are neither :enabled nor :disabled\r\n          return false;\r\n        };\r\n      }\r\n\r\n      /**\r\n       * Returns a function to use in pseudos for positionals\r\n       * @param {Function} fn\r\n       */\r\n      function createPositionalPseudo(fn) {\r\n        return markFunction(function (argument) {\r\n          argument = +argument;\r\n          return markFunction(function (seed, matches) {\r\n            var j,\r\n              matchIndexes = fn([], seed.length, argument),\r\n              i = matchIndexes.length;\r\n\r\n            // Match elements found at the specified indexes\r\n            while (i--) {\r\n              if (seed[(j = matchIndexes[i])]) {\r\n                seed[j] = !(matches[j] = seed[j]);\r\n              }\r\n            }\r\n          });\r\n        });\r\n      }\r\n\r\n      /**\r\n       * Checks a node for validity as a Sizzle context\r\n       * @param {Element|Object=} context\r\n       * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\r\n       */\r\n      function testContext(context) {\r\n        return context && typeof context.getElementsByTagName !== 'undefined' && context;\r\n      }\r\n\r\n      // Expose support vars for convenience\r\n      support = Sizzle.support = {};\r\n\r\n      /**\r\n       * Detects XML nodes\r\n       * @param {Element|Object} elem An element or a document\r\n       * @returns {Boolean} True iff elem is a non-HTML XML node\r\n       */\r\n      isXML = Sizzle.isXML = function (elem) {\r\n        var namespace = elem && elem.namespaceURI,\r\n          docElem = elem && (elem.ownerDocument || elem).documentElement;\r\n\r\n        // Support: IE <=8\r\n        // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\r\n        // https://bugs.jquery.com/ticket/4833\r\n        return !rhtml.test(namespace || (docElem && docElem.nodeName) || 'HTML');\r\n      };\r\n\r\n      /**\r\n       * Sets document-related variables once based on the current document\r\n       * @param {Element|Object} [doc] An element or document object to use to set the document\r\n       * @returns {Object} Returns the current document\r\n       */\r\n      setDocument = Sizzle.setDocument = function (node) {\r\n        var hasCompare,\r\n          subWindow,\r\n          doc = node ? node.ownerDocument || node : preferredDoc;\r\n\r\n        // Return early if doc is invalid or already selected\r\n        // Support: IE 11+, Edge 17 - 18+\r\n        // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\r\n        // two documents; shallow comparisons work.\r\n        // eslint-disable-next-line eqeqeq\r\n        if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {\r\n          return document;\r\n        }\r\n\r\n        // Update global variables\r\n        document = doc;\r\n        docElem = document.documentElement;\r\n        documentIsHTML = !isXML(document);\r\n\r\n        // Support: IE 9 - 11+, Edge 12 - 18+\r\n        // Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\r\n        // Support: IE 11+, Edge 17 - 18+\r\n        // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\r\n        // two documents; shallow comparisons work.\r\n        // eslint-disable-next-line eqeqeq\r\n        if (\r\n          preferredDoc != document &&\r\n          (subWindow = document.defaultView) &&\r\n          subWindow.top !== subWindow\r\n        ) {\r\n          // Support: IE 11, Edge\r\n          if (subWindow.addEventListener) {\r\n            subWindow.addEventListener('unload', unloadHandler, false);\r\n\r\n            // Support: IE 9 - 10 only\r\n          } else if (subWindow.attachEvent) {\r\n            subWindow.attachEvent('onunload', unloadHandler);\r\n          }\r\n        }\r\n\r\n        // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,\r\n        // Safari 4 - 5 only, Opera <=11.6 - 12.x only\r\n        // IE/Edge & older browsers don't support the :scope pseudo-class.\r\n        // Support: Safari 6.0 only\r\n        // Safari 6.0 supports :scope but it's an alias of :root there.\r\n        support.scope = assert(function (el) {\r\n          docElem.appendChild(el).appendChild(document.createElement('div'));\r\n          return (\r\n            typeof el.querySelectorAll !== 'undefined' &&\r\n            !el.querySelectorAll(':scope fieldset div').length\r\n          );\r\n        });\r\n\r\n        // Support: Chrome 105+, Firefox 104+, Safari 15.4+\r\n        // Make sure forgiving mode is not used in `CSS.supports( \"selector(...)\" )`.\r\n        //\r\n        // `:is()` uses a forgiving selector list as an argument and is widely\r\n        // implemented, so it's a good one to test against.\r\n        support.cssSupportsSelector = assert(function () {\r\n          /* eslint-disable no-undef */\r\n\r\n          return (\r\n            CSS.supports('selector(*)') &&\r\n            // Support: Firefox 78-81 only\r\n            // In old Firefox, `:is()` didn't use forgiving parsing. In that case,\r\n            // fail this test as there's no selector to test against that.\r\n            // `CSS.supports` uses unforgiving parsing\r\n            document.querySelectorAll(':is(:jqfake)') &&\r\n            // `*` is needed as Safari & newer Chrome implemented something in between\r\n            // for `:has()` - it throws in `qSA` if it only contains an unsupported\r\n            // argument but multiple ones, one of which is supported, are fine.\r\n            // We want to play safe in case `:is()` gets the same treatment.\r\n            !CSS.supports('selector(:is(*,:jqfake))')\r\n          );\r\n\r\n          /* eslint-enable */\r\n        });\r\n\r\n        /* Attributes\r\n\t---------------------------------------------------------------------- */\r\n\r\n        // Support: IE<8\r\n        // Verify that getAttribute really returns attributes and not properties\r\n        // (excepting IE8 booleans)\r\n        support.attributes = assert(function (el) {\r\n          el.className = 'i';\r\n          return !el.getAttribute('className');\r\n        });\r\n\r\n        /* getElement(s)By*\r\n\t---------------------------------------------------------------------- */\r\n\r\n        // Check if getElementsByTagName(\"*\") returns only elements\r\n        support.getElementsByTagName = assert(function (el) {\r\n          el.appendChild(document.createComment(''));\r\n          return !el.getElementsByTagName('*').length;\r\n        });\r\n\r\n        // Support: IE<9\r\n        support.getElementsByClassName = rnative.test(document.getElementsByClassName);\r\n\r\n        // Support: IE<10\r\n        // Check if getElementById returns elements by name\r\n        // The broken getElementById methods don't pick up programmatically-set names,\r\n        // so use a roundabout getElementsByName test\r\n        support.getById = assert(function (el) {\r\n          docElem.appendChild(el).id = expando;\r\n          return !document.getElementsByName || !document.getElementsByName(expando).length;\r\n        });\r\n\r\n        // ID filter and find\r\n        if (support.getById) {\r\n          Expr.filter['ID'] = function (id) {\r\n            var attrId = id.replace(runescape, funescape);\r\n            return function (elem) {\r\n              return elem.getAttribute('id') === attrId;\r\n            };\r\n          };\r\n          Expr.find['ID'] = function (id, context) {\r\n            if (typeof context.getElementById !== 'undefined' && documentIsHTML) {\r\n              var elem = context.getElementById(id);\r\n              return elem ? [elem] : [];\r\n            }\r\n          };\r\n        } else {\r\n          Expr.filter['ID'] = function (id) {\r\n            var attrId = id.replace(runescape, funescape);\r\n            return function (elem) {\r\n              var node =\r\n                typeof elem.getAttributeNode !== 'undefined' && elem.getAttributeNode('id');\r\n              return node && node.value === attrId;\r\n            };\r\n          };\r\n\r\n          // Support: IE 6 - 7 only\r\n          // getElementById is not reliable as a find shortcut\r\n          Expr.find['ID'] = function (id, context) {\r\n            if (typeof context.getElementById !== 'undefined' && documentIsHTML) {\r\n              var node,\r\n                i,\r\n                elems,\r\n                elem = context.getElementById(id);\r\n\r\n              if (elem) {\r\n                // Verify the id attribute\r\n                node = elem.getAttributeNode('id');\r\n                if (node && node.value === id) {\r\n                  return [elem];\r\n                }\r\n\r\n                // Fall back on getElementsByName\r\n                elems = context.getElementsByName(id);\r\n                i = 0;\r\n                while ((elem = elems[i++])) {\r\n                  node = elem.getAttributeNode('id');\r\n                  if (node && node.value === id) {\r\n                    return [elem];\r\n                  }\r\n                }\r\n              }\r\n\r\n              return [];\r\n            }\r\n          };\r\n        }\r\n\r\n        // Tag\r\n        Expr.find['TAG'] = support.getElementsByTagName\r\n          ? function (tag, context) {\r\n              if (typeof context.getElementsByTagName !== 'undefined') {\r\n                return context.getElementsByTagName(tag);\r\n\r\n                // DocumentFragment nodes don't have gEBTN\r\n              } else if (support.qsa) {\r\n                return context.querySelectorAll(tag);\r\n              }\r\n            }\r\n          : function (tag, context) {\r\n              var elem,\r\n                tmp = [],\r\n                i = 0,\r\n                // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\r\n                results = context.getElementsByTagName(tag);\r\n\r\n              // Filter out possible comments\r\n              if (tag === '*') {\r\n                while ((elem = results[i++])) {\r\n                  if (elem.nodeType === 1) {\r\n                    tmp.push(elem);\r\n                  }\r\n                }\r\n\r\n                return tmp;\r\n              }\r\n              return results;\r\n            };\r\n\r\n        // Class\r\n        Expr.find['CLASS'] =\r\n          support.getElementsByClassName &&\r\n          function (className, context) {\r\n            if (typeof context.getElementsByClassName !== 'undefined' && documentIsHTML) {\r\n              return context.getElementsByClassName(className);\r\n            }\r\n          };\r\n\r\n        /* QSA/matchesSelector\r\n\t---------------------------------------------------------------------- */\r\n\r\n        // QSA and matchesSelector support\r\n\r\n        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\r\n        rbuggyMatches = [];\r\n\r\n        // qSa(:focus) reports false when true (Chrome 21)\r\n        // We allow this because of a bug in IE8/9 that throws an error\r\n        // whenever `document.activeElement` is accessed on an iframe\r\n        // So, we allow :focus to pass through QSA all the time to avoid the IE error\r\n        // See https://bugs.jquery.com/ticket/13378\r\n        rbuggyQSA = [];\r\n\r\n        if ((support.qsa = rnative.test(document.querySelectorAll))) {\r\n          // Build QSA regex\r\n          // Regex strategy adopted from Diego Perini\r\n          assert(function (el) {\r\n            var input;\r\n\r\n            // Select is set to empty string on purpose\r\n            // This is to test IE's treatment of not explicitly\r\n            // setting a boolean content attribute,\r\n            // since its presence should be enough\r\n            // https://bugs.jquery.com/ticket/12359\r\n            docElem.appendChild(el).innerHTML =\r\n              \"<a id='\" +\r\n              expando +\r\n              \"'></a>\" +\r\n              \"<select id='\" +\r\n              expando +\r\n              \"-\\r\\\\' msallowcapture=''>\" +\r\n              \"<option selected=''></option></select>\";\r\n\r\n            // Support: IE8, Opera 11-12.16\r\n            // Nothing should be selected when empty strings follow ^= or $= or *=\r\n            // The test attribute must be unknown in Opera but \"safe\" for WinRT\r\n            // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\r\n            if (el.querySelectorAll(\"[msallowcapture^='']\").length) {\r\n              rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\\'\\'|\"\")');\r\n            }\r\n\r\n            // Support: IE8\r\n            // Boolean attributes and \"value\" are not treated correctly\r\n            if (!el.querySelectorAll('[selected]').length) {\r\n              rbuggyQSA.push('\\\\[' + whitespace + '*(?:value|' + booleans + ')');\r\n            }\r\n\r\n            // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\r\n            if (!el.querySelectorAll('[id~=' + expando + '-]').length) {\r\n              rbuggyQSA.push('~=');\r\n            }\r\n\r\n            // Support: IE 11+, Edge 15 - 18+\r\n            // IE 11/Edge don't find elements on a `[name='']` query in some cases.\r\n            // Adding a temporary attribute to the document before the selection works\r\n            // around the issue.\r\n            // Interestingly, IE 10 & older don't seem to have the issue.\r\n            input = document.createElement('input');\r\n            input.setAttribute('name', '');\r\n            el.appendChild(input);\r\n            if (!el.querySelectorAll(\"[name='']\").length) {\r\n              rbuggyQSA.push(\r\n                '\\\\[' + whitespace + '*name' + whitespace + '*=' + whitespace + '*(?:\\'\\'|\"\")',\r\n              );\r\n            }\r\n\r\n            // Webkit/Opera - :checked should return selected option elements\r\n            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\r\n            // IE8 throws error here and will not see later tests\r\n            if (!el.querySelectorAll(':checked').length) {\r\n              rbuggyQSA.push(':checked');\r\n            }\r\n\r\n            // Support: Safari 8+, iOS 8+\r\n            // https://bugs.webkit.org/show_bug.cgi?id=136851\r\n            // In-page `selector#id sibling-combinator selector` fails\r\n            if (!el.querySelectorAll('a#' + expando + '+*').length) {\r\n              rbuggyQSA.push('.#.+[+~]');\r\n            }\r\n\r\n            // Support: Firefox <=3.6 - 5 only\r\n            // Old Firefox doesn't throw on a badly-escaped identifier.\r\n            el.querySelectorAll('\\\\\\f');\r\n            rbuggyQSA.push('[\\\\r\\\\n\\\\f]');\r\n          });\r\n\r\n          assert(function (el) {\r\n            el.innerHTML =\r\n              \"<a href='' disabled='disabled'></a>\" +\r\n              \"<select disabled='disabled'><option/></select>\";\r\n\r\n            // Support: Windows 8 Native Apps\r\n            // The type and name attributes are restricted during .innerHTML assignment\r\n            var input = document.createElement('input');\r\n            input.setAttribute('type', 'hidden');\r\n            el.appendChild(input).setAttribute('name', 'D');\r\n\r\n            // Support: IE8\r\n            // Enforce case-sensitivity of name attribute\r\n            if (el.querySelectorAll('[name=d]').length) {\r\n              rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');\r\n            }\r\n\r\n            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\r\n            // IE8 throws error here and will not see later tests\r\n            if (el.querySelectorAll(':enabled').length !== 2) {\r\n              rbuggyQSA.push(':enabled', ':disabled');\r\n            }\r\n\r\n            // Support: IE9-11+\r\n            // IE's :disabled selector does not pick up the children of disabled fieldsets\r\n            docElem.appendChild(el).disabled = true;\r\n            if (el.querySelectorAll(':disabled').length !== 2) {\r\n              rbuggyQSA.push(':enabled', ':disabled');\r\n            }\r\n\r\n            // Support: Opera 10 - 11 only\r\n            // Opera 10-11 does not throw on post-comma invalid pseudos\r\n            el.querySelectorAll('*,:x');\r\n            rbuggyQSA.push(',.*:');\r\n          });\r\n        }\r\n\r\n        if (\r\n          (support.matchesSelector = rnative.test(\r\n            (matches =\r\n              docElem.matches ||\r\n              docElem.webkitMatchesSelector ||\r\n              docElem.mozMatchesSelector ||\r\n              docElem.oMatchesSelector ||\r\n              docElem.msMatchesSelector),\r\n          ))\r\n        ) {\r\n          assert(function (el) {\r\n            // Check to see if it's possible to do matchesSelector\r\n            // on a disconnected node (IE 9)\r\n            support.disconnectedMatch = matches.call(el, '*');\r\n\r\n            // This should fail with an exception\r\n            // Gecko does not error, returns false instead\r\n            matches.call(el, \"[s!='']:x\");\r\n            rbuggyMatches.push('!=', pseudos);\r\n          });\r\n        }\r\n\r\n        if (!support.cssSupportsSelector) {\r\n          // Support: Chrome 105+, Safari 15.4+\r\n          // `:has()` uses a forgiving selector list as an argument so our regular\r\n          // `try-catch` mechanism fails to catch `:has()` with arguments not supported\r\n          // natively like `:has(:contains(\"Foo\"))`. Where supported & spec-compliant,\r\n          // we now use `CSS.supports(\"selector(:is(SELECTOR_TO_BE_TESTED))\")`, but\r\n          // outside that we mark `:has` as buggy.\r\n          rbuggyQSA.push(':has');\r\n        }\r\n\r\n        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));\r\n        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));\r\n\r\n        /* Contains\r\n\t---------------------------------------------------------------------- */\r\n        hasCompare = rnative.test(docElem.compareDocumentPosition);\r\n\r\n        // Element contains another\r\n        // Purposefully self-exclusive\r\n        // As in, an element does not contain itself\r\n        contains =\r\n          hasCompare || rnative.test(docElem.contains)\r\n            ? function (a, b) {\r\n                // Support: IE <9 only\r\n                // IE doesn't have `contains` on `document` so we need to check for\r\n                // `documentElement` presence.\r\n                // We need to fall back to `a` when `documentElement` is missing\r\n                // as `ownerDocument` of elements within `<template/>` may have\r\n                // a null one - a default behavior of all modern browsers.\r\n                var adown = (a.nodeType === 9 && a.documentElement) || a,\r\n                  bup = b && b.parentNode;\r\n                return (\r\n                  a === bup ||\r\n                  !!(\r\n                    bup &&\r\n                    bup.nodeType === 1 &&\r\n                    (adown.contains\r\n                      ? adown.contains(bup)\r\n                      : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16)\r\n                  )\r\n                );\r\n              }\r\n            : function (a, b) {\r\n                if (b) {\r\n                  while ((b = b.parentNode)) {\r\n                    if (b === a) {\r\n                      return true;\r\n                    }\r\n                  }\r\n                }\r\n                return false;\r\n              };\r\n\r\n        /* Sorting\r\n\t---------------------------------------------------------------------- */\r\n\r\n        // Document order sorting\r\n        sortOrder = hasCompare\r\n          ? function (a, b) {\r\n              // Flag for duplicate removal\r\n              if (a === b) {\r\n                hasDuplicate = true;\r\n                return 0;\r\n              }\r\n\r\n              // Sort on method existence if only one input has compareDocumentPosition\r\n              var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\r\n              if (compare) {\r\n                return compare;\r\n              }\r\n\r\n              // Calculate position if both inputs belong to the same document\r\n              // Support: IE 11+, Edge 17 - 18+\r\n              // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\r\n              // two documents; shallow comparisons work.\r\n              // eslint-disable-next-line eqeqeq\r\n              compare =\r\n                (a.ownerDocument || a) == (b.ownerDocument || b)\r\n                  ? a.compareDocumentPosition(b)\r\n                  : // Otherwise we know they are disconnected\r\n                    1;\r\n\r\n              // Disconnected nodes\r\n              if (\r\n                compare & 1 ||\r\n                (!support.sortDetached && b.compareDocumentPosition(a) === compare)\r\n              ) {\r\n                // Choose the first element that is related to our preferred document\r\n                // Support: IE 11+, Edge 17 - 18+\r\n                // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\r\n                // two documents; shallow comparisons work.\r\n                // eslint-disable-next-line eqeqeq\r\n                if (\r\n                  a == document ||\r\n                  (a.ownerDocument == preferredDoc && contains(preferredDoc, a))\r\n                ) {\r\n                  return -1;\r\n                }\r\n\r\n                // Support: IE 11+, Edge 17 - 18+\r\n                // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\r\n                // two documents; shallow comparisons work.\r\n                // eslint-disable-next-line eqeqeq\r\n                if (\r\n                  b == document ||\r\n                  (b.ownerDocument == preferredDoc && contains(preferredDoc, b))\r\n                ) {\r\n                  return 1;\r\n                }\r\n\r\n                // Maintain original order\r\n                return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\r\n              }\r\n\r\n              return compare & 4 ? -1 : 1;\r\n            }\r\n          : function (a, b) {\r\n              // Exit early if the nodes are identical\r\n              if (a === b) {\r\n                hasDuplicate = true;\r\n                return 0;\r\n              }\r\n\r\n              var cur,\r\n                i = 0,\r\n                aup = a.parentNode,\r\n                bup = b.parentNode,\r\n                ap = [a],\r\n                bp = [b];\r\n\r\n              // Parentless nodes are either documents or disconnected\r\n              if (!aup || !bup) {\r\n                // Support: IE 11+, Edge 17 - 18+\r\n                // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\r\n                // two documents; shallow comparisons work.\r\n                /* eslint-disable eqeqeq */\r\n                return a == document\r\n                  ? -1\r\n                  : b == document\r\n                  ? 1\r\n                  : /* eslint-enable eqeqeq */\r\n                  aup\r\n                  ? -1\r\n                  : bup\r\n                  ? 1\r\n                  : sortInput\r\n                  ? indexOf(sortInput, a) - indexOf(sortInput, b)\r\n                  : 0;\r\n\r\n                // If the nodes are siblings, we can do a quick check\r\n              } else if (aup === bup) {\r\n                return siblingCheck(a, b);\r\n              }\r\n\r\n              // Otherwise we need full lists of their ancestors for comparison\r\n              cur = a;\r\n              while ((cur = cur.parentNode)) {\r\n                ap.unshift(cur);\r\n              }\r\n              cur = b;\r\n              while ((cur = cur.parentNode)) {\r\n                bp.unshift(cur);\r\n              }\r\n\r\n              // Walk down the tree looking for a discrepancy\r\n              while (ap[i] === bp[i]) {\r\n                i++;\r\n              }\r\n\r\n              return i\r\n                ? // Do a sibling check if the nodes have a common ancestor\r\n                  siblingCheck(ap[i], bp[i])\r\n                : // Otherwise nodes in our document sort first\r\n                // Support: IE 11+, Edge 17 - 18+\r\n                // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\r\n                // two documents; shallow comparisons work.\r\n                /* eslint-disable eqeqeq */\r\n                ap[i] == preferredDoc\r\n                ? -1\r\n                : bp[i] == preferredDoc\r\n                ? 1\r\n                : /* eslint-enable eqeqeq */\r\n                  0;\r\n            };\r\n\r\n        return document;\r\n      };\r\n\r\n      Sizzle.matches = function (expr, elements) {\r\n        return Sizzle(expr, null, null, elements);\r\n      };\r\n\r\n      Sizzle.matchesSelector = function (elem, expr) {\r\n        setDocument(elem);\r\n\r\n        if (\r\n          support.matchesSelector &&\r\n          documentIsHTML &&\r\n          !nonnativeSelectorCache[expr + ' '] &&\r\n          (!rbuggyMatches || !rbuggyMatches.test(expr)) &&\r\n          (!rbuggyQSA || !rbuggyQSA.test(expr))\r\n        ) {\r\n          try {\r\n            var ret = matches.call(elem, expr);\r\n\r\n            // IE 9's matchesSelector returns false on disconnected nodes\r\n            if (\r\n              ret ||\r\n              support.disconnectedMatch ||\r\n              // As well, disconnected nodes are said to be in a document\r\n              // fragment in IE 9\r\n              (elem.document && elem.document.nodeType !== 11)\r\n            ) {\r\n              return ret;\r\n            }\r\n          } catch (e) {\r\n            nonnativeSelectorCache(expr, true);\r\n          }\r\n        }\r\n\r\n        return Sizzle(expr, document, null, [elem]).length > 0;\r\n      };\r\n\r\n      Sizzle.contains = function (context, elem) {\r\n        // Set document vars if needed\r\n        // Support: IE 11+, Edge 17 - 18+\r\n        // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\r\n        // two documents; shallow comparisons work.\r\n        // eslint-disable-next-line eqeqeq\r\n        if ((context.ownerDocument || context) != document) {\r\n          setDocument(context);\r\n        }\r\n        return contains(context, elem);\r\n      };\r\n\r\n      Sizzle.attr = function (elem, name) {\r\n        // Set document vars if needed\r\n        // Support: IE 11+, Edge 17 - 18+\r\n        // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\r\n        // two documents; shallow comparisons work.\r\n        // eslint-disable-next-line eqeqeq\r\n        if ((elem.ownerDocument || elem) != document) {\r\n          setDocument(elem);\r\n        }\r\n\r\n        var fn = Expr.attrHandle[name.toLowerCase()],\r\n          // Don't get fooled by Object.prototype properties (jQuery #13807)\r\n          val =\r\n            fn && hasOwn.call(Expr.attrHandle, name.toLowerCase())\r\n              ? fn(elem, name, !documentIsHTML)\r\n              : undefined;\r\n\r\n        return val !== undefined\r\n          ? val\r\n          : support.attributes || !documentIsHTML\r\n          ? elem.getAttribute(name)\r\n          : (val = elem.getAttributeNode(name)) && val.specified\r\n          ? val.value\r\n          : null;\r\n      };\r\n\r\n      Sizzle.escape = function (sel) {\r\n        return (sel + '').replace(rcssescape, fcssescape);\r\n      };\r\n\r\n      Sizzle.error = function (msg) {\r\n        throw new Error('Syntax error, unrecognized expression: ' + msg);\r\n      };\r\n\r\n      /**\r\n       * Document sorting and removing duplicates\r\n       * @param {ArrayLike} results\r\n       */\r\n      Sizzle.uniqueSort = function (results) {\r\n        var elem,\r\n          duplicates = [],\r\n          j = 0,\r\n          i = 0;\r\n\r\n        // Unless we *know* we can detect duplicates, assume their presence\r\n        hasDuplicate = !support.detectDuplicates;\r\n        sortInput = !support.sortStable && results.slice(0);\r\n        results.sort(sortOrder);\r\n\r\n        if (hasDuplicate) {\r\n          while ((elem = results[i++])) {\r\n            if (elem === results[i]) {\r\n              j = duplicates.push(i);\r\n            }\r\n          }\r\n          while (j--) {\r\n            results.splice(duplicates[j], 1);\r\n          }\r\n        }\r\n\r\n        // Clear input after sorting to release objects\r\n        // See https://github.com/jquery/sizzle/pull/225\r\n        sortInput = null;\r\n\r\n        return results;\r\n      };\r\n\r\n      /**\r\n       * Utility function for retrieving the text value of an array of DOM nodes\r\n       * @param {Array|Element} elem\r\n       */\r\n      getText = Sizzle.getText = function (elem) {\r\n        var node,\r\n          ret = '',\r\n          i = 0,\r\n          nodeType = elem.nodeType;\r\n\r\n        if (!nodeType) {\r\n          // If no nodeType, this is expected to be an array\r\n          while ((node = elem[i++])) {\r\n            // Do not traverse comment nodes\r\n            ret += getText(node);\r\n          }\r\n        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\r\n          // Use textContent for elements\r\n          // innerText usage removed for consistency of new lines (jQuery #11153)\r\n          if (typeof elem.textContent === 'string') {\r\n            return elem.textContent;\r\n          } else {\r\n            // Traverse its children\r\n            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\r\n              ret += getText(elem);\r\n            }\r\n          }\r\n        } else if (nodeType === 3 || nodeType === 4) {\r\n          return elem.nodeValue;\r\n        }\r\n\r\n        // Do not include comment or processing instruction nodes\r\n\r\n        return ret;\r\n      };\r\n\r\n      Expr = Sizzle.selectors = {\r\n        // Can be adjusted by the user\r\n        cacheLength: 50,\r\n\r\n        createPseudo: markFunction,\r\n\r\n        match: matchExpr,\r\n\r\n        attrHandle: {},\r\n\r\n        find: {},\r\n\r\n        relative: {\r\n          '>': { dir: 'parentNode', first: true },\r\n          ' ': { dir: 'parentNode' },\r\n          '+': { dir: 'previousSibling', first: true },\r\n          '~': { dir: 'previousSibling' },\r\n        },\r\n\r\n        preFilter: {\r\n          ATTR: function (match) {\r\n            match[1] = match[1].replace(runescape, funescape);\r\n\r\n            // Move the given value to match[3] whether quoted or unquoted\r\n            match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);\r\n\r\n            if (match[2] === '~=') {\r\n              match[3] = ' ' + match[3] + ' ';\r\n            }\r\n\r\n            return match.slice(0, 4);\r\n          },\r\n\r\n          CHILD: function (match) {\r\n            /* matches from matchExpr[\"CHILD\"]\r\n\t\t\t\t1 type (only|nth|...)\r\n\t\t\t\t2 what (child|of-type)\r\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\r\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\r\n\t\t\t\t5 sign of xn-component\r\n\t\t\t\t6 x of xn-component\r\n\t\t\t\t7 sign of y-component\r\n\t\t\t\t8 y of y-component\r\n\t\t\t*/\r\n            match[1] = match[1].toLowerCase();\r\n\r\n            if (match[1].slice(0, 3) === 'nth') {\r\n              // nth-* requires argument\r\n              if (!match[3]) {\r\n                Sizzle.error(match[0]);\r\n              }\r\n\r\n              // numeric x and y parameters for Expr.filter.CHILD\r\n              // remember that false/true cast respectively to 0/1\r\n              match[4] = +(match[4]\r\n                ? match[5] + (match[6] || 1)\r\n                : 2 * (match[3] === 'even' || match[3] === 'odd'));\r\n              match[5] = +(match[7] + match[8] || match[3] === 'odd');\r\n\r\n              // other types prohibit arguments\r\n            } else if (match[3]) {\r\n              Sizzle.error(match[0]);\r\n            }\r\n\r\n            return match;\r\n          },\r\n\r\n          PSEUDO: function (match) {\r\n            var excess,\r\n              unquoted = !match[6] && match[2];\r\n\r\n            if (matchExpr['CHILD'].test(match[0])) {\r\n              return null;\r\n            }\r\n\r\n            // Accept quoted arguments as-is\r\n            if (match[3]) {\r\n              match[2] = match[4] || match[5] || '';\r\n\r\n              // Strip excess characters from unquoted arguments\r\n            } else if (\r\n              unquoted &&\r\n              rpseudo.test(unquoted) &&\r\n              // Get excess from tokenize (recursively)\r\n              (excess = tokenize(unquoted, true)) &&\r\n              // advance to the next closing parenthesis\r\n              (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)\r\n            ) {\r\n              // excess is a negative index\r\n              match[0] = match[0].slice(0, excess);\r\n              match[2] = unquoted.slice(0, excess);\r\n            }\r\n\r\n            // Return only captures needed by the pseudo filter method (type and argument)\r\n            return match.slice(0, 3);\r\n          },\r\n        },\r\n\r\n        filter: {\r\n          TAG: function (nodeNameSelector) {\r\n            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\r\n            return nodeNameSelector === '*'\r\n              ? function () {\r\n                  return true;\r\n                }\r\n              : function (elem) {\r\n                  return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\r\n                };\r\n          },\r\n\r\n          CLASS: function (className) {\r\n            var pattern = classCache[className + ' '];\r\n\r\n            return (\r\n              pattern ||\r\n              ((pattern = new RegExp(\r\n                '(^|' + whitespace + ')' + className + '(' + whitespace + '|$)',\r\n              )) &&\r\n                classCache(className, function (elem) {\r\n                  return pattern.test(\r\n                    (typeof elem.className === 'string' && elem.className) ||\r\n                      (typeof elem.getAttribute !== 'undefined' && elem.getAttribute('class')) ||\r\n                      '',\r\n                  );\r\n                }))\r\n            );\r\n          },\r\n\r\n          ATTR: function (name, operator, check) {\r\n            return function (elem) {\r\n              var result = Sizzle.attr(elem, name);\r\n\r\n              if (result == null) {\r\n                return operator === '!=';\r\n              }\r\n              if (!operator) {\r\n                return true;\r\n              }\r\n\r\n              result += '';\r\n\r\n              /* eslint-disable max-len */\r\n\r\n              return operator === '='\r\n                ? result === check\r\n                : operator === '!='\r\n                ? result !== check\r\n                : operator === '^='\r\n                ? check && result.indexOf(check) === 0\r\n                : operator === '*='\r\n                ? check && result.indexOf(check) > -1\r\n                : operator === '$='\r\n                ? check && result.slice(-check.length) === check\r\n                : operator === '~='\r\n                ? (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(check) > -1\r\n                : operator === '|='\r\n                ? result === check || result.slice(0, check.length + 1) === check + '-'\r\n                : false;\r\n              /* eslint-enable max-len */\r\n            };\r\n          },\r\n\r\n          CHILD: function (type, what, _argument, first, last) {\r\n            var simple = type.slice(0, 3) !== 'nth',\r\n              forward = type.slice(-4) !== 'last',\r\n              ofType = what === 'of-type';\r\n\r\n            return first === 1 && last === 0\r\n              ? // Shortcut for :nth-*(n)\r\n                function (elem) {\r\n                  return !!elem.parentNode;\r\n                }\r\n              : function (elem, _context, xml) {\r\n                  var cache,\r\n                    uniqueCache,\r\n                    outerCache,\r\n                    node,\r\n                    nodeIndex,\r\n                    start,\r\n                    dir = simple !== forward ? 'nextSibling' : 'previousSibling',\r\n                    parent = elem.parentNode,\r\n                    name = ofType && elem.nodeName.toLowerCase(),\r\n                    useCache = !xml && !ofType,\r\n                    diff = false;\r\n\r\n                  if (parent) {\r\n                    // :(first|last|only)-(child|of-type)\r\n                    if (simple) {\r\n                      while (dir) {\r\n                        node = elem;\r\n                        while ((node = node[dir])) {\r\n                          if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\r\n                            return false;\r\n                          }\r\n                        }\r\n\r\n                        // Reverse direction for :only-* (if we haven't yet done so)\r\n                        start = dir = type === 'only' && !start && 'nextSibling';\r\n                      }\r\n                      return true;\r\n                    }\r\n\r\n                    start = [forward ? parent.firstChild : parent.lastChild];\r\n\r\n                    // non-xml :nth-child(...) stores cache data on `parent`\r\n                    if (forward && useCache) {\r\n                      // Seek `elem` from a previously-cached index\r\n\r\n                      // ...in a gzip-friendly way\r\n                      node = parent;\r\n                      outerCache = node[expando] || (node[expando] = {});\r\n\r\n                      // Support: IE <9 only\r\n                      // Defend against cloned attroperties (jQuery gh-1709)\r\n                      uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\r\n\r\n                      cache = uniqueCache[type] || [];\r\n                      nodeIndex = cache[0] === dirruns && cache[1];\r\n                      diff = nodeIndex && cache[2];\r\n                      node = nodeIndex && parent.childNodes[nodeIndex];\r\n\r\n                      while (\r\n                        (node =\r\n                          (++nodeIndex && node && node[dir]) ||\r\n                          // Fallback to seeking `elem` from the start\r\n                          (diff = nodeIndex = 0) ||\r\n                          start.pop())\r\n                      ) {\r\n                        // When found, cache indexes on `parent` and break\r\n                        if (node.nodeType === 1 && ++diff && node === elem) {\r\n                          uniqueCache[type] = [dirruns, nodeIndex, diff];\r\n                          break;\r\n                        }\r\n                      }\r\n                    } else {\r\n                      // Use previously-cached element index if available\r\n                      if (useCache) {\r\n                        // ...in a gzip-friendly way\r\n                        node = elem;\r\n                        outerCache = node[expando] || (node[expando] = {});\r\n\r\n                        // Support: IE <9 only\r\n                        // Defend against cloned attroperties (jQuery gh-1709)\r\n                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\r\n\r\n                        cache = uniqueCache[type] || [];\r\n                        nodeIndex = cache[0] === dirruns && cache[1];\r\n                        diff = nodeIndex;\r\n                      }\r\n\r\n                      // xml :nth-child(...)\r\n                      // or :nth-last-child(...) or :nth(-last)?-of-type(...)\r\n                      if (diff === false) {\r\n                        // Use the same loop as above to seek `elem` from the start\r\n                        while (\r\n                          (node =\r\n                            (++nodeIndex && node && node[dir]) ||\r\n                            (diff = nodeIndex = 0) ||\r\n                            start.pop())\r\n                        ) {\r\n                          if (\r\n                            (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) &&\r\n                            ++diff\r\n                          ) {\r\n                            // Cache the index of each encountered element\r\n                            if (useCache) {\r\n                              outerCache = node[expando] || (node[expando] = {});\r\n\r\n                              // Support: IE <9 only\r\n                              // Defend against cloned attroperties (jQuery gh-1709)\r\n                              uniqueCache =\r\n                                outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\r\n\r\n                              uniqueCache[type] = [dirruns, diff];\r\n                            }\r\n\r\n                            if (node === elem) {\r\n                              break;\r\n                            }\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n\r\n                    // Incorporate the offset, then check against cycle size\r\n                    diff -= last;\r\n                    return diff === first || (diff % first === 0 && diff / first >= 0);\r\n                  }\r\n                };\r\n          },\r\n\r\n          PSEUDO: function (pseudo, argument) {\r\n            // pseudo-class names are case-insensitive\r\n            // http://www.w3.org/TR/selectors/#pseudo-classes\r\n            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\r\n            // Remember that setFilters inherits from pseudos\r\n            var args,\r\n              fn =\r\n                Expr.pseudos[pseudo] ||\r\n                Expr.setFilters[pseudo.toLowerCase()] ||\r\n                Sizzle.error('unsupported pseudo: ' + pseudo);\r\n\r\n            // The user may use createPseudo to indicate that\r\n            // arguments are needed to create the filter function\r\n            // just as Sizzle does\r\n            if (fn[expando]) {\r\n              return fn(argument);\r\n            }\r\n\r\n            // But maintain support for old signatures\r\n            if (fn.length > 1) {\r\n              args = [pseudo, pseudo, '', argument];\r\n              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase())\r\n                ? markFunction(function (seed, matches) {\r\n                    var idx,\r\n                      matched = fn(seed, argument),\r\n                      i = matched.length;\r\n                    while (i--) {\r\n                      idx = indexOf(seed, matched[i]);\r\n                      seed[idx] = !(matches[idx] = matched[i]);\r\n                    }\r\n                  })\r\n                : function (elem) {\r\n                    return fn(elem, 0, args);\r\n                  };\r\n            }\r\n\r\n            return fn;\r\n          },\r\n        },\r\n\r\n        pseudos: {\r\n          // Potentially complex pseudos\r\n          not: markFunction(function (selector) {\r\n            // Trim the selector passed to compile\r\n            // to avoid treating leading and trailing\r\n            // spaces as combinators\r\n            var input = [],\r\n              results = [],\r\n              matcher = compile(selector.replace(rtrim, '$1'));\r\n\r\n            return matcher[expando]\r\n              ? markFunction(function (seed, matches, _context, xml) {\r\n                  var elem,\r\n                    unmatched = matcher(seed, null, xml, []),\r\n                    i = seed.length;\r\n\r\n                  // Match elements unmatched by `matcher`\r\n                  while (i--) {\r\n                    if ((elem = unmatched[i])) {\r\n                      seed[i] = !(matches[i] = elem);\r\n                    }\r\n                  }\r\n                })\r\n              : function (elem, _context, xml) {\r\n                  input[0] = elem;\r\n                  matcher(input, null, xml, results);\r\n\r\n                  // Don't keep the element (issue #299)\r\n                  input[0] = null;\r\n                  return !results.pop();\r\n                };\r\n          }),\r\n\r\n          has: markFunction(function (selector) {\r\n            return function (elem) {\r\n              return Sizzle(selector, elem).length > 0;\r\n            };\r\n          }),\r\n\r\n          contains: markFunction(function (text) {\r\n            text = text.replace(runescape, funescape);\r\n            return function (elem) {\r\n              return (elem.textContent || getText(elem)).indexOf(text) > -1;\r\n            };\r\n          }),\r\n\r\n          // \"Whether an element is represented by a :lang() selector\r\n          // is based solely on the element's language value\r\n          // being equal to the identifier C,\r\n          // or beginning with the identifier C immediately followed by \"-\".\r\n          // The matching of C against the element's language value is performed case-insensitively.\r\n          // The identifier C does not have to be a valid language name.\"\r\n          // http://www.w3.org/TR/selectors/#lang-pseudo\r\n          lang: markFunction(function (lang) {\r\n            // lang value must be a valid identifier\r\n            if (!ridentifier.test(lang || '')) {\r\n              Sizzle.error('unsupported lang: ' + lang);\r\n            }\r\n            lang = lang.replace(runescape, funescape).toLowerCase();\r\n            return function (elem) {\r\n              var elemLang;\r\n              do {\r\n                if (\r\n                  (elemLang = documentIsHTML\r\n                    ? elem.lang\r\n                    : elem.getAttribute('xml:lang') || elem.getAttribute('lang'))\r\n                ) {\r\n                  elemLang = elemLang.toLowerCase();\r\n                  return elemLang === lang || elemLang.indexOf(lang + '-') === 0;\r\n                }\r\n              } while ((elem = elem.parentNode) && elem.nodeType === 1);\r\n              return false;\r\n            };\r\n          }),\r\n\r\n          // Miscellaneous\r\n          target: function (elem) {\r\n            var hash = window.location && window.location.hash;\r\n            return hash && hash.slice(1) === elem.id;\r\n          },\r\n\r\n          root: function (elem) {\r\n            return elem === docElem;\r\n          },\r\n\r\n          focus: function (elem) {\r\n            return (\r\n              elem === document.activeElement &&\r\n              (!document.hasFocus || document.hasFocus()) &&\r\n              !!(elem.type || elem.href || ~elem.tabIndex)\r\n            );\r\n          },\r\n\r\n          // Boolean properties\r\n          enabled: createDisabledPseudo(false),\r\n          disabled: createDisabledPseudo(true),\r\n\r\n          checked: function (elem) {\r\n            // In CSS3, :checked should return both checked and selected elements\r\n            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\r\n            var nodeName = elem.nodeName.toLowerCase();\r\n            return (\r\n              (nodeName === 'input' && !!elem.checked) || (nodeName === 'option' && !!elem.selected)\r\n            );\r\n          },\r\n\r\n          selected: function (elem) {\r\n            // Accessing this property makes selected-by-default\r\n            // options in Safari work properly\r\n            if (elem.parentNode) {\r\n              // eslint-disable-next-line no-unused-expressions\r\n              elem.parentNode.selectedIndex;\r\n            }\r\n\r\n            return elem.selected === true;\r\n          },\r\n\r\n          // Contents\r\n          empty: function (elem) {\r\n            // http://www.w3.org/TR/selectors/#empty-pseudo\r\n            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\r\n            //   but not by others (comment: 8; processing instruction: 7; etc.)\r\n            // nodeType < 6 works because attributes (2) do not appear as children\r\n            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\r\n              if (elem.nodeType < 6) {\r\n                return false;\r\n              }\r\n            }\r\n            return true;\r\n          },\r\n\r\n          parent: function (elem) {\r\n            return !Expr.pseudos['empty'](elem);\r\n          },\r\n\r\n          // Element/input types\r\n          header: function (elem) {\r\n            return rheader.test(elem.nodeName);\r\n          },\r\n\r\n          input: function (elem) {\r\n            return rinputs.test(elem.nodeName);\r\n          },\r\n\r\n          button: function (elem) {\r\n            var name = elem.nodeName.toLowerCase();\r\n            return (name === 'input' && elem.type === 'button') || name === 'button';\r\n          },\r\n\r\n          text: function (elem) {\r\n            var attr;\r\n            return (\r\n              elem.nodeName.toLowerCase() === 'input' &&\r\n              elem.type === 'text' &&\r\n              // Support: IE <10 only\r\n              // New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\r\n              ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text')\r\n            );\r\n          },\r\n\r\n          // Position-in-collection\r\n          first: createPositionalPseudo(function () {\r\n            return [0];\r\n          }),\r\n\r\n          last: createPositionalPseudo(function (_matchIndexes, length) {\r\n            return [length - 1];\r\n          }),\r\n\r\n          eq: createPositionalPseudo(function (_matchIndexes, length, argument) {\r\n            return [argument < 0 ? argument + length : argument];\r\n          }),\r\n\r\n          even: createPositionalPseudo(function (matchIndexes, length) {\r\n            var i = 0;\r\n            for (; i < length; i += 2) {\r\n              matchIndexes.push(i);\r\n            }\r\n            return matchIndexes;\r\n          }),\r\n\r\n          odd: createPositionalPseudo(function (matchIndexes, length) {\r\n            var i = 1;\r\n            for (; i < length; i += 2) {\r\n              matchIndexes.push(i);\r\n            }\r\n            return matchIndexes;\r\n          }),\r\n\r\n          lt: createPositionalPseudo(function (matchIndexes, length, argument) {\r\n            var i = argument < 0 ? argument + length : argument > length ? length : argument;\r\n            for (; --i >= 0; ) {\r\n              matchIndexes.push(i);\r\n            }\r\n            return matchIndexes;\r\n          }),\r\n\r\n          gt: createPositionalPseudo(function (matchIndexes, length, argument) {\r\n            var i = argument < 0 ? argument + length : argument;\r\n            for (; ++i < length; ) {\r\n              matchIndexes.push(i);\r\n            }\r\n            return matchIndexes;\r\n          }),\r\n        },\r\n      };\r\n\r\n      Expr.pseudos['nth'] = Expr.pseudos['eq'];\r\n\r\n      // Add button/input type pseudos\r\n      for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {\r\n        Expr.pseudos[i] = createInputPseudo(i);\r\n      }\r\n      for (i in { submit: true, reset: true }) {\r\n        Expr.pseudos[i] = createButtonPseudo(i);\r\n      }\r\n\r\n      // Easy API for creating new setFilters\r\n      function setFilters() {}\r\n      setFilters.prototype = Expr.filters = Expr.pseudos;\r\n      Expr.setFilters = new setFilters();\r\n\r\n      tokenize = Sizzle.tokenize = function (selector, parseOnly) {\r\n        var matched,\r\n          match,\r\n          tokens,\r\n          type,\r\n          soFar,\r\n          groups,\r\n          preFilters,\r\n          cached = tokenCache[selector + ' '];\r\n\r\n        if (cached) {\r\n          return parseOnly ? 0 : cached.slice(0);\r\n        }\r\n\r\n        soFar = selector;\r\n        groups = [];\r\n        preFilters = Expr.preFilter;\r\n\r\n        while (soFar) {\r\n          // Comma and first run\r\n          if (!matched || (match = rcomma.exec(soFar))) {\r\n            if (match) {\r\n              // Don't consume trailing commas as valid\r\n              soFar = soFar.slice(match[0].length) || soFar;\r\n            }\r\n            groups.push((tokens = []));\r\n          }\r\n\r\n          matched = false;\r\n\r\n          // Combinators\r\n          if ((match = rcombinators.exec(soFar))) {\r\n            matched = match.shift();\r\n            tokens.push({\r\n              value: matched,\r\n\r\n              // Cast descendant combinators to space\r\n              type: match[0].replace(rtrim, ' '),\r\n            });\r\n            soFar = soFar.slice(matched.length);\r\n          }\r\n\r\n          // Filters\r\n          for (type in Expr.filter) {\r\n            if (\r\n              (match = matchExpr[type].exec(soFar)) &&\r\n              (!preFilters[type] || (match = preFilters[type](match)))\r\n            ) {\r\n              matched = match.shift();\r\n              tokens.push({\r\n                value: matched,\r\n                type: type,\r\n                matches: match,\r\n              });\r\n              soFar = soFar.slice(matched.length);\r\n            }\r\n          }\r\n\r\n          if (!matched) {\r\n            break;\r\n          }\r\n        }\r\n\r\n        // Return the length of the invalid excess\r\n        // if we're just parsing\r\n        // Otherwise, throw an error or return tokens\r\n        return parseOnly\r\n          ? soFar.length\r\n          : soFar\r\n          ? Sizzle.error(selector)\r\n          : // Cache the tokens\r\n            tokenCache(selector, groups).slice(0);\r\n      };\r\n\r\n      function toSelector(tokens) {\r\n        var i = 0,\r\n          len = tokens.length,\r\n          selector = '';\r\n        for (; i < len; i++) {\r\n          selector += tokens[i].value;\r\n        }\r\n        return selector;\r\n      }\r\n\r\n      function addCombinator(matcher, combinator, base) {\r\n        var dir = combinator.dir,\r\n          skip = combinator.next,\r\n          key = skip || dir,\r\n          checkNonElements = base && key === 'parentNode',\r\n          doneName = done++;\r\n\r\n        return combinator.first\r\n          ? // Check against closest ancestor/preceding element\r\n            function (elem, context, xml) {\r\n              while ((elem = elem[dir])) {\r\n                if (elem.nodeType === 1 || checkNonElements) {\r\n                  return matcher(elem, context, xml);\r\n                }\r\n              }\r\n              return false;\r\n            }\r\n          : // Check against all ancestor/preceding elements\r\n            function (elem, context, xml) {\r\n              var oldCache,\r\n                uniqueCache,\r\n                outerCache,\r\n                newCache = [dirruns, doneName];\r\n\r\n              // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\r\n              if (xml) {\r\n                while ((elem = elem[dir])) {\r\n                  if (elem.nodeType === 1 || checkNonElements) {\r\n                    if (matcher(elem, context, xml)) {\r\n                      return true;\r\n                    }\r\n                  }\r\n                }\r\n              } else {\r\n                while ((elem = elem[dir])) {\r\n                  if (elem.nodeType === 1 || checkNonElements) {\r\n                    outerCache = elem[expando] || (elem[expando] = {});\r\n\r\n                    // Support: IE <9 only\r\n                    // Defend against cloned attroperties (jQuery gh-1709)\r\n                    uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\r\n\r\n                    if (skip && skip === elem.nodeName.toLowerCase()) {\r\n                      elem = elem[dir] || elem;\r\n                    } else if (\r\n                      (oldCache = uniqueCache[key]) &&\r\n                      oldCache[0] === dirruns &&\r\n                      oldCache[1] === doneName\r\n                    ) {\r\n                      // Assign to newCache so results back-propagate to previous elements\r\n                      return (newCache[2] = oldCache[2]);\r\n                    } else {\r\n                      // Reuse newcache so results back-propagate to previous elements\r\n                      uniqueCache[key] = newCache;\r\n\r\n                      // A match means we're done; a fail means we have to keep checking\r\n                      if ((newCache[2] = matcher(elem, context, xml))) {\r\n                        return true;\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n              return false;\r\n            };\r\n      }\r\n\r\n      function elementMatcher(matchers) {\r\n        return matchers.length > 1\r\n          ? function (elem, context, xml) {\r\n              var i = matchers.length;\r\n              while (i--) {\r\n                if (!matchers[i](elem, context, xml)) {\r\n                  return false;\r\n                }\r\n              }\r\n              return true;\r\n            }\r\n          : matchers[0];\r\n      }\r\n\r\n      function multipleContexts(selector, contexts, results) {\r\n        var i = 0,\r\n          len = contexts.length;\r\n        for (; i < len; i++) {\r\n          Sizzle(selector, contexts[i], results);\r\n        }\r\n        return results;\r\n      }\r\n\r\n      function condense(unmatched, map, filter, context, xml) {\r\n        var elem,\r\n          newUnmatched = [],\r\n          i = 0,\r\n          len = unmatched.length,\r\n          mapped = map != null;\r\n\r\n        for (; i < len; i++) {\r\n          if ((elem = unmatched[i])) {\r\n            if (!filter || filter(elem, context, xml)) {\r\n              newUnmatched.push(elem);\r\n              if (mapped) {\r\n                map.push(i);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        return newUnmatched;\r\n      }\r\n\r\n      function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\r\n        if (postFilter && !postFilter[expando]) {\r\n          postFilter = setMatcher(postFilter);\r\n        }\r\n        if (postFinder && !postFinder[expando]) {\r\n          postFinder = setMatcher(postFinder, postSelector);\r\n        }\r\n        return markFunction(function (seed, results, context, xml) {\r\n          var temp,\r\n            i,\r\n            elem,\r\n            preMap = [],\r\n            postMap = [],\r\n            preexisting = results.length,\r\n            // Get initial elements from seed or context\r\n            elems =\r\n              seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []),\r\n            // Prefilter to get matcher input, preserving a map for seed-results synchronization\r\n            matcherIn =\r\n              preFilter && (seed || !selector)\r\n                ? condense(elems, preMap, preFilter, context, xml)\r\n                : elems,\r\n            matcherOut = matcher\r\n              ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\r\n                postFinder || (seed ? preFilter : preexisting || postFilter)\r\n                ? // ...intermediate processing is necessary\r\n                  []\r\n                : // ...otherwise use results directly\r\n                  results\r\n              : matcherIn;\r\n\r\n          // Find primary matches\r\n          if (matcher) {\r\n            matcher(matcherIn, matcherOut, context, xml);\r\n          }\r\n\r\n          // Apply postFilter\r\n          if (postFilter) {\r\n            temp = condense(matcherOut, postMap);\r\n            postFilter(temp, [], context, xml);\r\n\r\n            // Un-match failing elements by moving them back to matcherIn\r\n            i = temp.length;\r\n            while (i--) {\r\n              if ((elem = temp[i])) {\r\n                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\r\n              }\r\n            }\r\n          }\r\n\r\n          if (seed) {\r\n            if (postFinder || preFilter) {\r\n              if (postFinder) {\r\n                // Get the final matcherOut by condensing this intermediate into postFinder contexts\r\n                temp = [];\r\n                i = matcherOut.length;\r\n                while (i--) {\r\n                  if ((elem = matcherOut[i])) {\r\n                    // Restore matcherIn since elem is not yet a final match\r\n                    temp.push((matcherIn[i] = elem));\r\n                  }\r\n                }\r\n                postFinder(null, (matcherOut = []), temp, xml);\r\n              }\r\n\r\n              // Move matched elements from seed to results to keep them synchronized\r\n              i = matcherOut.length;\r\n              while (i--) {\r\n                if (\r\n                  (elem = matcherOut[i]) &&\r\n                  (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1\r\n                ) {\r\n                  seed[temp] = !(results[temp] = elem);\r\n                }\r\n              }\r\n            }\r\n\r\n            // Add elements to results, through postFinder if defined\r\n          } else {\r\n            matcherOut = condense(\r\n              matcherOut === results\r\n                ? matcherOut.splice(preexisting, matcherOut.length)\r\n                : matcherOut,\r\n            );\r\n            if (postFinder) {\r\n              postFinder(null, results, matcherOut, xml);\r\n            } else {\r\n              push.apply(results, matcherOut);\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      function matcherFromTokens(tokens) {\r\n        var checkContext,\r\n          matcher,\r\n          j,\r\n          len = tokens.length,\r\n          leadingRelative = Expr.relative[tokens[0].type],\r\n          implicitRelative = leadingRelative || Expr.relative[' '],\r\n          i = leadingRelative ? 1 : 0,\r\n          // The foundational matcher ensures that elements are reachable from top-level context(s)\r\n          matchContext = addCombinator(\r\n            function (elem) {\r\n              return elem === checkContext;\r\n            },\r\n            implicitRelative,\r\n            true,\r\n          ),\r\n          matchAnyContext = addCombinator(\r\n            function (elem) {\r\n              return indexOf(checkContext, elem) > -1;\r\n            },\r\n            implicitRelative,\r\n            true,\r\n          ),\r\n          matchers = [\r\n            function (elem, context, xml) {\r\n              var ret =\r\n                (!leadingRelative && (xml || context !== outermostContext)) ||\r\n                ((checkContext = context).nodeType\r\n                  ? matchContext(elem, context, xml)\r\n                  : matchAnyContext(elem, context, xml));\r\n\r\n              // Avoid hanging onto element (issue #299)\r\n              checkContext = null;\r\n              return ret;\r\n            },\r\n          ];\r\n\r\n        for (; i < len; i++) {\r\n          if ((matcher = Expr.relative[tokens[i].type])) {\r\n            matchers = [addCombinator(elementMatcher(matchers), matcher)];\r\n          } else {\r\n            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);\r\n\r\n            // Return special upon seeing a positional matcher\r\n            if (matcher[expando]) {\r\n              // Find the next relative operator (if any) for proper handling\r\n              j = ++i;\r\n              for (; j < len; j++) {\r\n                if (Expr.relative[tokens[j].type]) {\r\n                  break;\r\n                }\r\n              }\r\n              return setMatcher(\r\n                i > 1 && elementMatcher(matchers),\r\n                i > 1 &&\r\n                  toSelector(\r\n                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`\r\n                    tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' }),\r\n                  ).replace(rtrim, '$1'),\r\n                matcher,\r\n                i < j && matcherFromTokens(tokens.slice(i, j)),\r\n                j < len && matcherFromTokens((tokens = tokens.slice(j))),\r\n                j < len && toSelector(tokens),\r\n              );\r\n            }\r\n            matchers.push(matcher);\r\n          }\r\n        }\r\n\r\n        return elementMatcher(matchers);\r\n      }\r\n\r\n      function matcherFromGroupMatchers(elementMatchers, setMatchers) {\r\n        var bySet = setMatchers.length > 0,\r\n          byElement = elementMatchers.length > 0,\r\n          superMatcher = function (seed, context, xml, results, outermost) {\r\n            var elem,\r\n              j,\r\n              matcher,\r\n              matchedCount = 0,\r\n              i = '0',\r\n              unmatched = seed && [],\r\n              setMatched = [],\r\n              contextBackup = outermostContext,\r\n              // We must always have either seed elements or outermost context\r\n              elems = seed || (byElement && Expr.find['TAG']('*', outermost)),\r\n              // Use integer dirruns iff this is the outermost matcher\r\n              dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\r\n              len = elems.length;\r\n\r\n            if (outermost) {\r\n              // Support: IE 11+, Edge 17 - 18+\r\n              // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\r\n              // two documents; shallow comparisons work.\r\n              // eslint-disable-next-line eqeqeq\r\n              outermostContext = context == document || context || outermost;\r\n            }\r\n\r\n            // Add elements passing elementMatchers directly to results\r\n            // Support: IE<9, Safari\r\n            // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\r\n            for (; i !== len && (elem = elems[i]) != null; i++) {\r\n              if (byElement && elem) {\r\n                j = 0;\r\n\r\n                // Support: IE 11+, Edge 17 - 18+\r\n                // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\r\n                // two documents; shallow comparisons work.\r\n                // eslint-disable-next-line eqeqeq\r\n                if (!context && elem.ownerDocument != document) {\r\n                  setDocument(elem);\r\n                  xml = !documentIsHTML;\r\n                }\r\n                while ((matcher = elementMatchers[j++])) {\r\n                  if (matcher(elem, context || document, xml)) {\r\n                    results.push(elem);\r\n                    break;\r\n                  }\r\n                }\r\n                if (outermost) {\r\n                  dirruns = dirrunsUnique;\r\n                }\r\n              }\r\n\r\n              // Track unmatched elements for set filters\r\n              if (bySet) {\r\n                // They will have gone through all possible matchers\r\n                if ((elem = !matcher && elem)) {\r\n                  matchedCount--;\r\n                }\r\n\r\n                // Lengthen the array for every element, matched or not\r\n                if (seed) {\r\n                  unmatched.push(elem);\r\n                }\r\n              }\r\n            }\r\n\r\n            // `i` is now the count of elements visited above, and adding it to `matchedCount`\r\n            // makes the latter nonnegative.\r\n            matchedCount += i;\r\n\r\n            // Apply set filters to unmatched elements\r\n            // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\r\n            // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\r\n            // no element matchers and no seed.\r\n            // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\r\n            // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\r\n            // numerically zero.\r\n            if (bySet && i !== matchedCount) {\r\n              j = 0;\r\n              while ((matcher = setMatchers[j++])) {\r\n                matcher(unmatched, setMatched, context, xml);\r\n              }\r\n\r\n              if (seed) {\r\n                // Reintegrate element matches to eliminate the need for sorting\r\n                if (matchedCount > 0) {\r\n                  while (i--) {\r\n                    if (!(unmatched[i] || setMatched[i])) {\r\n                      setMatched[i] = pop.call(results);\r\n                    }\r\n                  }\r\n                }\r\n\r\n                // Discard index placeholder values to get only actual matches\r\n                setMatched = condense(setMatched);\r\n              }\r\n\r\n              // Add matches to results\r\n              push.apply(results, setMatched);\r\n\r\n              // Seedless set matches succeeding multiple successful matchers stipulate sorting\r\n              if (\r\n                outermost &&\r\n                !seed &&\r\n                setMatched.length > 0 &&\r\n                matchedCount + setMatchers.length > 1\r\n              ) {\r\n                Sizzle.uniqueSort(results);\r\n              }\r\n            }\r\n\r\n            // Override manipulation of globals by nested matchers\r\n            if (outermost) {\r\n              dirruns = dirrunsUnique;\r\n              outermostContext = contextBackup;\r\n            }\r\n\r\n            return unmatched;\r\n          };\r\n\r\n        return bySet ? markFunction(superMatcher) : superMatcher;\r\n      }\r\n\r\n      compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {\r\n        var i,\r\n          setMatchers = [],\r\n          elementMatchers = [],\r\n          cached = compilerCache[selector + ' '];\r\n\r\n        if (!cached) {\r\n          // Generate a function of recursive functions that can be used to check each element\r\n          if (!match) {\r\n            match = tokenize(selector);\r\n          }\r\n          i = match.length;\r\n          while (i--) {\r\n            cached = matcherFromTokens(match[i]);\r\n            if (cached[expando]) {\r\n              setMatchers.push(cached);\r\n            } else {\r\n              elementMatchers.push(cached);\r\n            }\r\n          }\r\n\r\n          // Cache the compiled function\r\n          cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));\r\n\r\n          // Save selector and tokenization\r\n          cached.selector = selector;\r\n        }\r\n        return cached;\r\n      };\r\n\r\n      /**\r\n       * A low-level selection function that works with Sizzle's compiled\r\n       *  selector functions\r\n       * @param {String|Function} selector A selector or a pre-compiled\r\n       *  selector function built with Sizzle.compile\r\n       * @param {Element} context\r\n       * @param {Array} [results]\r\n       * @param {Array} [seed] A set of elements to match against\r\n       */\r\n      select = Sizzle.select = function (selector, context, results, seed) {\r\n        var i,\r\n          tokens,\r\n          token,\r\n          type,\r\n          find,\r\n          compiled = typeof selector === 'function' && selector,\r\n          match = !seed && tokenize((selector = compiled.selector || selector));\r\n\r\n        results = results || [];\r\n\r\n        // Try to minimize operations if there is only one selector in the list and no seed\r\n        // (the latter of which guarantees us context)\r\n        if (match.length === 1) {\r\n          // Reduce context if the leading compound selector is an ID\r\n          tokens = match[0] = match[0].slice(0);\r\n          if (\r\n            tokens.length > 2 &&\r\n            (token = tokens[0]).type === 'ID' &&\r\n            context.nodeType === 9 &&\r\n            documentIsHTML &&\r\n            Expr.relative[tokens[1].type]\r\n          ) {\r\n            context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) ||\r\n              [])[0];\r\n            if (!context) {\r\n              return results;\r\n\r\n              // Precompiled matchers will still verify ancestry, so step up a level\r\n            } else if (compiled) {\r\n              context = context.parentNode;\r\n            }\r\n\r\n            selector = selector.slice(tokens.shift().value.length);\r\n          }\r\n\r\n          // Fetch a seed set for right-to-left matching\r\n          i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;\r\n          while (i--) {\r\n            token = tokens[i];\r\n\r\n            // Abort if we hit a combinator\r\n            if (Expr.relative[(type = token.type)]) {\r\n              break;\r\n            }\r\n            if ((find = Expr.find[type])) {\r\n              // Search, expanding context for leading sibling combinators\r\n              if (\r\n                (seed = find(\r\n                  token.matches[0].replace(runescape, funescape),\r\n                  (rsibling.test(tokens[0].type) && testContext(context.parentNode)) || context,\r\n                ))\r\n              ) {\r\n                // If seed is empty or no tokens remain, we can return early\r\n                tokens.splice(i, 1);\r\n                selector = seed.length && toSelector(tokens);\r\n                if (!selector) {\r\n                  push.apply(results, seed);\r\n                  return results;\r\n                }\r\n\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        // Compile and execute a filtering function if one is not provided\r\n        // Provide `match` to avoid retokenization if we modified the selector above\r\n        (compiled || compile(selector, match))(\r\n          seed,\r\n          context,\r\n          !documentIsHTML,\r\n          results,\r\n          !context || (rsibling.test(selector) && testContext(context.parentNode)) || context,\r\n        );\r\n        return results;\r\n      };\r\n\r\n      // One-time assignments\r\n\r\n      // Sort stability\r\n      support.sortStable = expando.split('').sort(sortOrder).join('') === expando;\r\n\r\n      // Support: Chrome 14-35+\r\n      // Always assume duplicates if they aren't passed to the comparison function\r\n      support.detectDuplicates = !!hasDuplicate;\r\n\r\n      // Initialize against the default document\r\n      setDocument();\r\n\r\n      // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\r\n      // Detached nodes confoundingly follow *each other*\r\n      support.sortDetached = assert(function (el) {\r\n        // Should return 1, but returns 4 (following)\r\n        return el.compareDocumentPosition(document.createElement('fieldset')) & 1;\r\n      });\r\n\r\n      // Support: IE<8\r\n      // Prevent attribute/property \"interpolation\"\r\n      // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\r\n      if (\r\n        !assert(function (el) {\r\n          el.innerHTML = \"<a href='#'></a>\";\r\n          return el.firstChild.getAttribute('href') === '#';\r\n        })\r\n      ) {\r\n        addHandle('type|href|height|width', function (elem, name, isXML) {\r\n          if (!isXML) {\r\n            return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);\r\n          }\r\n        });\r\n      }\r\n\r\n      // Support: IE<9\r\n      // Use defaultValue in place of getAttribute(\"value\")\r\n      if (\r\n        !support.attributes ||\r\n        !assert(function (el) {\r\n          el.innerHTML = '<input/>';\r\n          el.firstChild.setAttribute('value', '');\r\n          return el.firstChild.getAttribute('value') === '';\r\n        })\r\n      ) {\r\n        addHandle('value', function (elem, _name, isXML) {\r\n          if (!isXML && elem.nodeName.toLowerCase() === 'input') {\r\n            return elem.defaultValue;\r\n          }\r\n        });\r\n      }\r\n\r\n      // Support: IE<9\r\n      // Use getAttributeNode to fetch booleans when getAttribute lies\r\n      if (\r\n        !assert(function (el) {\r\n          return el.getAttribute('disabled') == null;\r\n        })\r\n      ) {\r\n        addHandle(booleans, function (elem, name, isXML) {\r\n          var val;\r\n          if (!isXML) {\r\n            return elem[name] === true\r\n              ? name.toLowerCase()\r\n              : (val = elem.getAttributeNode(name)) && val.specified\r\n              ? val.value\r\n              : null;\r\n          }\r\n        });\r\n      }\r\n\r\n      return Sizzle;\r\n    })(window);\r\n\r\n  jQuery.find = Sizzle;\r\n  jQuery.expr = Sizzle.selectors;\r\n\r\n  // Deprecated\r\n  jQuery.expr[':'] = jQuery.expr.pseudos;\r\n  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\r\n  jQuery.text = Sizzle.getText;\r\n  jQuery.isXMLDoc = Sizzle.isXML;\r\n  jQuery.contains = Sizzle.contains;\r\n  jQuery.escapeSelector = Sizzle.escape;\r\n\r\n  var dir = function (elem, dir, until) {\r\n    var matched = [],\r\n      truncate = until !== undefined;\r\n\r\n    while ((elem = elem[dir]) && elem.nodeType !== 9) {\r\n      if (elem.nodeType === 1) {\r\n        if (truncate && jQuery(elem).is(until)) {\r\n          break;\r\n        }\r\n        matched.push(elem);\r\n      }\r\n    }\r\n    return matched;\r\n  };\r\n\r\n  var siblings = function (n, elem) {\r\n    var matched = [];\r\n\r\n    for (; n; n = n.nextSibling) {\r\n      if (n.nodeType === 1 && n !== elem) {\r\n        matched.push(n);\r\n      }\r\n    }\r\n\r\n    return matched;\r\n  };\r\n\r\n  var rneedsContext = jQuery.expr.match.needsContext;\r\n\r\n  function nodeName(elem, name) {\r\n    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\r\n  }\r\n  var rsingleTag = /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i;\r\n\r\n  // Implement the identical functionality for filter and not\r\n  function winnow(elements, qualifier, not) {\r\n    if (isFunction(qualifier)) {\r\n      return jQuery.grep(elements, function (elem, i) {\r\n        return !!qualifier.call(elem, i, elem) !== not;\r\n      });\r\n    }\r\n\r\n    // Single element\r\n    if (qualifier.nodeType) {\r\n      return jQuery.grep(elements, function (elem) {\r\n        return (elem === qualifier) !== not;\r\n      });\r\n    }\r\n\r\n    // Arraylike of elements (jQuery, arguments, Array)\r\n    if (typeof qualifier !== 'string') {\r\n      return jQuery.grep(elements, function (elem) {\r\n        return indexOf.call(qualifier, elem) > -1 !== not;\r\n      });\r\n    }\r\n\r\n    // Filtered directly for both simple and complex selectors\r\n    return jQuery.filter(qualifier, elements, not);\r\n  }\r\n\r\n  jQuery.filter = function (expr, elems, not) {\r\n    var elem = elems[0];\r\n\r\n    if (not) {\r\n      expr = ':not(' + expr + ')';\r\n    }\r\n\r\n    if (elems.length === 1 && elem.nodeType === 1) {\r\n      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];\r\n    }\r\n\r\n    return jQuery.find.matches(\r\n      expr,\r\n      jQuery.grep(elems, function (elem) {\r\n        return elem.nodeType === 1;\r\n      }),\r\n    );\r\n  };\r\n\r\n  jQuery.fn.extend({\r\n    find: function (selector) {\r\n      var i,\r\n        ret,\r\n        len = this.length,\r\n        self = this;\r\n\r\n      if (typeof selector !== 'string') {\r\n        return this.pushStack(\r\n          jQuery(selector).filter(function () {\r\n            for (i = 0; i < len; i++) {\r\n              if (jQuery.contains(self[i], this)) {\r\n                return true;\r\n              }\r\n            }\r\n          }),\r\n        );\r\n      }\r\n\r\n      ret = this.pushStack([]);\r\n\r\n      for (i = 0; i < len; i++) {\r\n        jQuery.find(selector, self[i], ret);\r\n      }\r\n\r\n      return len > 1 ? jQuery.uniqueSort(ret) : ret;\r\n    },\r\n    filter: function (selector) {\r\n      return this.pushStack(winnow(this, selector || [], false));\r\n    },\r\n    not: function (selector) {\r\n      return this.pushStack(winnow(this, selector || [], true));\r\n    },\r\n    is: function (selector) {\r\n      return !!winnow(\r\n        this,\r\n\r\n        // If this is a positional/relative selector, check membership in the returned set\r\n        // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\r\n        typeof selector === 'string' && rneedsContext.test(selector)\r\n          ? jQuery(selector)\r\n          : selector || [],\r\n        false,\r\n      ).length;\r\n    },\r\n  });\r\n\r\n  // Initialize a jQuery object\r\n\r\n  // A central reference to the root jQuery(document)\r\n  var rootjQuery,\r\n    // A simple way to check for HTML strings\r\n    // Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)\r\n    // Strict HTML recognition (trac-11290: must start with <)\r\n    // Shortcut simple #id case for speed\r\n    rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\r\n    init = (jQuery.fn.init = function (selector, context, root) {\r\n      var match, elem;\r\n\r\n      // HANDLE: $(\"\"), $(null), $(undefined), $(false)\r\n      if (!selector) {\r\n        return this;\r\n      }\r\n\r\n      // Method init() accepts an alternate rootjQuery\r\n      // so migrate can support jQuery.sub (gh-2101)\r\n      root = root || rootjQuery;\r\n\r\n      // Handle HTML strings\r\n      if (typeof selector === 'string') {\r\n        if (selector[0] === '<' && selector[selector.length - 1] === '>' && selector.length >= 3) {\r\n          // Assume that strings that start and end with <> are HTML and skip the regex check\r\n          match = [null, selector, null];\r\n        } else {\r\n          match = rquickExpr.exec(selector);\r\n        }\r\n\r\n        // Match html or make sure no context is specified for #id\r\n        if (match && (match[1] || !context)) {\r\n          // HANDLE: $(html) -> $(array)\r\n          if (match[1]) {\r\n            context = context instanceof jQuery ? context[0] : context;\r\n\r\n            // Option to run scripts is true for back-compat\r\n            // Intentionally let the error be thrown if parseHTML is not present\r\n            jQuery.merge(\r\n              this,\r\n              jQuery.parseHTML(\r\n                match[1],\r\n                context && context.nodeType ? context.ownerDocument || context : document,\r\n                true,\r\n              ),\r\n            );\r\n\r\n            // HANDLE: $(html, props)\r\n            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\r\n              for (match in context) {\r\n                // Properties of context are called as methods if possible\r\n                if (isFunction(this[match])) {\r\n                  this[match](context[match]);\r\n\r\n                  // ...and otherwise set as attributes\r\n                } else {\r\n                  this.attr(match, context[match]);\r\n                }\r\n              }\r\n            }\r\n\r\n            return this;\r\n\r\n            // HANDLE: $(#id)\r\n          } else {\r\n            elem = document.getElementById(match[2]);\r\n\r\n            if (elem) {\r\n              // Inject the element directly into the jQuery object\r\n              this[0] = elem;\r\n              this.length = 1;\r\n            }\r\n            return this;\r\n          }\r\n\r\n          // HANDLE: $(expr, $(...))\r\n        } else if (!context || context.jquery) {\r\n          return (context || root).find(selector);\r\n\r\n          // HANDLE: $(expr, context)\r\n          // (which is just equivalent to: $(context).find(expr)\r\n        } else {\r\n          return this.constructor(context).find(selector);\r\n        }\r\n\r\n        // HANDLE: $(DOMElement)\r\n      } else if (selector.nodeType) {\r\n        this[0] = selector;\r\n        this.length = 1;\r\n        return this;\r\n\r\n        // HANDLE: $(function)\r\n        // Shortcut for document ready\r\n      } else if (isFunction(selector)) {\r\n        return root.ready !== undefined\r\n          ? root.ready(selector)\r\n          : // Execute immediately if ready is not present\r\n            selector(jQuery);\r\n      }\r\n\r\n      return jQuery.makeArray(selector, this);\r\n    });\r\n\r\n  // Give the init function the jQuery prototype for later instantiation\r\n  init.prototype = jQuery.fn;\r\n\r\n  // Initialize central reference\r\n  rootjQuery = jQuery(document);\r\n\r\n  var rparentsprev = /^(?:parents|prev(?:Until|All))/,\r\n    // Methods guaranteed to produce a unique set when starting from a unique set\r\n    guaranteedUnique = {\r\n      children: true,\r\n      contents: true,\r\n      next: true,\r\n      prev: true,\r\n    };\r\n\r\n  jQuery.fn.extend({\r\n    has: function (target) {\r\n      var targets = jQuery(target, this),\r\n        l = targets.length;\r\n\r\n      return this.filter(function () {\r\n        var i = 0;\r\n        for (; i < l; i++) {\r\n          if (jQuery.contains(this, targets[i])) {\r\n            return true;\r\n          }\r\n        }\r\n      });\r\n    },\r\n\r\n    closest: function (selectors, context) {\r\n      var cur,\r\n        i = 0,\r\n        l = this.length,\r\n        matched = [],\r\n        targets = typeof selectors !== 'string' && jQuery(selectors);\r\n\r\n      // Positional selectors never match, since there's no _selection_ context\r\n      if (!rneedsContext.test(selectors)) {\r\n        for (; i < l; i++) {\r\n          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\r\n            // Always skip document fragments\r\n            if (\r\n              cur.nodeType < 11 &&\r\n              (targets\r\n                ? targets.index(cur) > -1\r\n                : // Don't pass non-elements to Sizzle\r\n                  cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))\r\n            ) {\r\n              matched.push(cur);\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);\r\n    },\r\n\r\n    // Determine the position of an element within the set\r\n    index: function (elem) {\r\n      // No argument, return index in parent\r\n      if (!elem) {\r\n        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\r\n      }\r\n\r\n      // Index in selector\r\n      if (typeof elem === 'string') {\r\n        return indexOf.call(jQuery(elem), this[0]);\r\n      }\r\n\r\n      // Locate the position of the desired element\r\n      return indexOf.call(\r\n        this,\r\n\r\n        // If it receives a jQuery object, the first element is used\r\n        elem.jquery ? elem[0] : elem,\r\n      );\r\n    },\r\n\r\n    add: function (selector, context) {\r\n      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));\r\n    },\r\n\r\n    addBack: function (selector) {\r\n      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\r\n    },\r\n  });\r\n\r\n  function sibling(cur, dir) {\r\n    while ((cur = cur[dir]) && cur.nodeType !== 1) {}\r\n    return cur;\r\n  }\r\n\r\n  jQuery.each(\r\n    {\r\n      parent: function (elem) {\r\n        var parent = elem.parentNode;\r\n        return parent && parent.nodeType !== 11 ? parent : null;\r\n      },\r\n      parents: function (elem) {\r\n        return dir(elem, 'parentNode');\r\n      },\r\n      parentsUntil: function (elem, _i, until) {\r\n        return dir(elem, 'parentNode', until);\r\n      },\r\n      next: function (elem) {\r\n        return sibling(elem, 'nextSibling');\r\n      },\r\n      prev: function (elem) {\r\n        return sibling(elem, 'previousSibling');\r\n      },\r\n      nextAll: function (elem) {\r\n        return dir(elem, 'nextSibling');\r\n      },\r\n      prevAll: function (elem) {\r\n        return dir(elem, 'previousSibling');\r\n      },\r\n      nextUntil: function (elem, _i, until) {\r\n        return dir(elem, 'nextSibling', until);\r\n      },\r\n      prevUntil: function (elem, _i, until) {\r\n        return dir(elem, 'previousSibling', until);\r\n      },\r\n      siblings: function (elem) {\r\n        return siblings((elem.parentNode || {}).firstChild, elem);\r\n      },\r\n      children: function (elem) {\r\n        return siblings(elem.firstChild);\r\n      },\r\n      contents: function (elem) {\r\n        if (\r\n          elem.contentDocument != null &&\r\n          // Support: IE 11+\r\n          // <object> elements with no `data` attribute has an object\r\n          // `contentDocument` with a `null` prototype.\r\n          getProto(elem.contentDocument)\r\n        ) {\r\n          return elem.contentDocument;\r\n        }\r\n\r\n        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\r\n        // Treat the template element as a regular one in browsers that\r\n        // don't support it.\r\n        if (nodeName(elem, 'template')) {\r\n          elem = elem.content || elem;\r\n        }\r\n\r\n        return jQuery.merge([], elem.childNodes);\r\n      },\r\n    },\r\n    function (name, fn) {\r\n      jQuery.fn[name] = function (until, selector) {\r\n        var matched = jQuery.map(this, fn, until);\r\n\r\n        if (name.slice(-5) !== 'Until') {\r\n          selector = until;\r\n        }\r\n\r\n        if (selector && typeof selector === 'string') {\r\n          matched = jQuery.filter(selector, matched);\r\n        }\r\n\r\n        if (this.length > 1) {\r\n          // Remove duplicates\r\n          if (!guaranteedUnique[name]) {\r\n            jQuery.uniqueSort(matched);\r\n          }\r\n\r\n          // Reverse order for parents* and prev-derivatives\r\n          if (rparentsprev.test(name)) {\r\n            matched.reverse();\r\n          }\r\n        }\r\n\r\n        return this.pushStack(matched);\r\n      };\r\n    },\r\n  );\r\n  var rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g;\r\n\r\n  // Convert String-formatted options into Object-formatted ones\r\n  function createOptions(options) {\r\n    var object = {};\r\n    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {\r\n      object[flag] = true;\r\n    });\r\n    return object;\r\n  }\r\n\r\n  /*\r\n   * Create a callback list using the following parameters:\r\n   *\r\n   *\toptions: an optional list of space-separated options that will change how\r\n   *\t\t\tthe callback list behaves or a more traditional option object\r\n   *\r\n   * By default a callback list will act like an event callback list and can be\r\n   * \"fired\" multiple times.\r\n   *\r\n   * Possible options:\r\n   *\r\n   *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\r\n   *\r\n   *\tmemory:\t\t\twill keep track of previous values and will call any callback added\r\n   *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\r\n   *\t\t\t\t\tvalues (like a Deferred)\r\n   *\r\n   *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\r\n   *\r\n   *\tstopOnFalse:\tinterrupt callings when a callback returns false\r\n   *\r\n   */\r\n  jQuery.Callbacks = function (options) {\r\n    // Convert options from String-formatted to Object-formatted if needed\r\n    // (we check in cache first)\r\n    options = typeof options === 'string' ? createOptions(options) : jQuery.extend({}, options);\r\n\r\n    var // Flag to know if list is currently firing\r\n      firing,\r\n      // Last fire value for non-forgettable lists\r\n      memory,\r\n      // Flag to know if list was already fired\r\n      fired,\r\n      // Flag to prevent firing\r\n      locked,\r\n      // Actual callback list\r\n      list = [],\r\n      // Queue of execution data for repeatable lists\r\n      queue = [],\r\n      // Index of currently firing callback (modified by add/remove as needed)\r\n      firingIndex = -1,\r\n      // Fire callbacks\r\n      fire = function () {\r\n        // Enforce single-firing\r\n        locked = locked || options.once;\r\n\r\n        // Execute callbacks for all pending executions,\r\n        // respecting firingIndex overrides and runtime changes\r\n        fired = firing = true;\r\n        for (; queue.length; firingIndex = -1) {\r\n          memory = queue.shift();\r\n          while (++firingIndex < list.length) {\r\n            // Run callback and check for early termination\r\n            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\r\n              // Jump to end and forget the data so .add doesn't re-fire\r\n              firingIndex = list.length;\r\n              memory = false;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Forget the data if we're done with it\r\n        if (!options.memory) {\r\n          memory = false;\r\n        }\r\n\r\n        firing = false;\r\n\r\n        // Clean up if we're done firing for good\r\n        if (locked) {\r\n          // Keep an empty list if we have data for future add calls\r\n          if (memory) {\r\n            list = [];\r\n\r\n            // Otherwise, this object is spent\r\n          } else {\r\n            list = '';\r\n          }\r\n        }\r\n      },\r\n      // Actual Callbacks object\r\n      self = {\r\n        // Add a callback or a collection of callbacks to the list\r\n        add: function () {\r\n          if (list) {\r\n            // If we have memory from a past run, we should fire after adding\r\n            if (memory && !firing) {\r\n              firingIndex = list.length - 1;\r\n              queue.push(memory);\r\n            }\r\n\r\n            (function add(args) {\r\n              jQuery.each(args, function (_, arg) {\r\n                if (isFunction(arg)) {\r\n                  if (!options.unique || !self.has(arg)) {\r\n                    list.push(arg);\r\n                  }\r\n                } else if (arg && arg.length && toType(arg) !== 'string') {\r\n                  // Inspect recursively\r\n                  add(arg);\r\n                }\r\n              });\r\n            })(arguments);\r\n\r\n            if (memory && !firing) {\r\n              fire();\r\n            }\r\n          }\r\n          return this;\r\n        },\r\n\r\n        // Remove a callback from the list\r\n        remove: function () {\r\n          jQuery.each(arguments, function (_, arg) {\r\n            var index;\r\n            while ((index = jQuery.inArray(arg, list, index)) > -1) {\r\n              list.splice(index, 1);\r\n\r\n              // Handle firing indexes\r\n              if (index <= firingIndex) {\r\n                firingIndex--;\r\n              }\r\n            }\r\n          });\r\n          return this;\r\n        },\r\n\r\n        // Check if a given callback is in the list.\r\n        // If no argument is given, return whether or not list has callbacks attached.\r\n        has: function (fn) {\r\n          return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;\r\n        },\r\n\r\n        // Remove all callbacks from the list\r\n        empty: function () {\r\n          if (list) {\r\n            list = [];\r\n          }\r\n          return this;\r\n        },\r\n\r\n        // Disable .fire and .add\r\n        // Abort any current/pending executions\r\n        // Clear all callbacks and values\r\n        disable: function () {\r\n          locked = queue = [];\r\n          list = memory = '';\r\n          return this;\r\n        },\r\n        disabled: function () {\r\n          return !list;\r\n        },\r\n\r\n        // Disable .fire\r\n        // Also disable .add unless we have memory (since it would have no effect)\r\n        // Abort any pending executions\r\n        lock: function () {\r\n          locked = queue = [];\r\n          if (!memory && !firing) {\r\n            list = memory = '';\r\n          }\r\n          return this;\r\n        },\r\n        locked: function () {\r\n          return !!locked;\r\n        },\r\n\r\n        // Call all callbacks with the given context and arguments\r\n        fireWith: function (context, args) {\r\n          if (!locked) {\r\n            args = args || [];\r\n            args = [context, args.slice ? args.slice() : args];\r\n            queue.push(args);\r\n            if (!firing) {\r\n              fire();\r\n            }\r\n          }\r\n          return this;\r\n        },\r\n\r\n        // Call all the callbacks with the given arguments\r\n        fire: function () {\r\n          self.fireWith(this, arguments);\r\n          return this;\r\n        },\r\n\r\n        // To know if the callbacks have already been called at least once\r\n        fired: function () {\r\n          return !!fired;\r\n        },\r\n      };\r\n\r\n    return self;\r\n  };\r\n\r\n  function Identity(v) {\r\n    return v;\r\n  }\r\n  function Thrower(ex) {\r\n    throw ex;\r\n  }\r\n\r\n  function adoptValue(value, resolve, reject, noValue) {\r\n    var method;\r\n\r\n    try {\r\n      // Check for promise aspect first to privilege synchronous behavior\r\n      if (value && isFunction((method = value.promise))) {\r\n        method.call(value).done(resolve).fail(reject);\r\n\r\n        // Other thenables\r\n      } else if (value && isFunction((method = value.then))) {\r\n        method.call(value, resolve, reject);\r\n\r\n        // Other non-thenables\r\n      } else {\r\n        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\r\n        // * false: [ value ].slice( 0 ) => resolve( value )\r\n        // * true: [ value ].slice( 1 ) => resolve()\r\n        resolve.apply(undefined, [value].slice(noValue));\r\n      }\r\n\r\n      // For Promises/A+, convert exceptions into rejections\r\n      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\r\n      // Deferred#then to conditionally suppress rejection.\r\n    } catch (value) {\r\n      // Support: Android 4.0 only\r\n      // Strict mode functions invoked without .call/.apply get global-object context\r\n      reject.apply(undefined, [value]);\r\n    }\r\n  }\r\n\r\n  jQuery.extend({\r\n    Deferred: function (func) {\r\n      var tuples = [\r\n          // action, add listener, callbacks,\r\n          // ... .then handlers, argument index, [final state]\r\n          ['notify', 'progress', jQuery.Callbacks('memory'), jQuery.Callbacks('memory'), 2],\r\n          [\r\n            'resolve',\r\n            'done',\r\n            jQuery.Callbacks('once memory'),\r\n            jQuery.Callbacks('once memory'),\r\n            0,\r\n            'resolved',\r\n          ],\r\n          [\r\n            'reject',\r\n            'fail',\r\n            jQuery.Callbacks('once memory'),\r\n            jQuery.Callbacks('once memory'),\r\n            1,\r\n            'rejected',\r\n          ],\r\n        ],\r\n        state = 'pending',\r\n        promise = {\r\n          state: function () {\r\n            return state;\r\n          },\r\n          always: function () {\r\n            deferred.done(arguments).fail(arguments);\r\n            return this;\r\n          },\r\n          catch: function (fn) {\r\n            return promise.then(null, fn);\r\n          },\r\n\r\n          // Keep pipe for back-compat\r\n          pipe: function (/* fnDone, fnFail, fnProgress */) {\r\n            var fns = arguments;\r\n\r\n            return jQuery\r\n              .Deferred(function (newDefer) {\r\n                jQuery.each(tuples, function (_i, tuple) {\r\n                  // Map tuples (progress, done, fail) to arguments (done, fail, progress)\r\n                  var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];\r\n\r\n                  // deferred.progress(function() { bind to newDefer or newDefer.notify })\r\n                  // deferred.done(function() { bind to newDefer or newDefer.resolve })\r\n                  // deferred.fail(function() { bind to newDefer or newDefer.reject })\r\n                  deferred[tuple[1]](function () {\r\n                    var returned = fn && fn.apply(this, arguments);\r\n                    if (returned && isFunction(returned.promise)) {\r\n                      returned\r\n                        .promise()\r\n                        .progress(newDefer.notify)\r\n                        .done(newDefer.resolve)\r\n                        .fail(newDefer.reject);\r\n                    } else {\r\n                      newDefer[tuple[0] + 'With'](this, fn ? [returned] : arguments);\r\n                    }\r\n                  });\r\n                });\r\n                fns = null;\r\n              })\r\n              .promise();\r\n          },\r\n          then: function (onFulfilled, onRejected, onProgress) {\r\n            var maxDepth = 0;\r\n            function resolve(depth, deferred, handler, special) {\r\n              return function () {\r\n                var that = this,\r\n                  args = arguments,\r\n                  mightThrow = function () {\r\n                    var returned, then;\r\n\r\n                    // Support: Promises/A+ section 2.3.3.3.3\r\n                    // https://promisesaplus.com/#point-59\r\n                    // Ignore double-resolution attempts\r\n                    if (depth < maxDepth) {\r\n                      return;\r\n                    }\r\n\r\n                    returned = handler.apply(that, args);\r\n\r\n                    // Support: Promises/A+ section 2.3.1\r\n                    // https://promisesaplus.com/#point-48\r\n                    if (returned === deferred.promise()) {\r\n                      throw new TypeError('Thenable self-resolution');\r\n                    }\r\n\r\n                    // Support: Promises/A+ sections 2.3.3.1, 3.5\r\n                    // https://promisesaplus.com/#point-54\r\n                    // https://promisesaplus.com/#point-75\r\n                    // Retrieve `then` only once\r\n                    then =\r\n                      returned &&\r\n                      // Support: Promises/A+ section 2.3.4\r\n                      // https://promisesaplus.com/#point-64\r\n                      // Only check objects and functions for thenability\r\n                      (typeof returned === 'object' || typeof returned === 'function') &&\r\n                      returned.then;\r\n\r\n                    // Handle a returned thenable\r\n                    if (isFunction(then)) {\r\n                      // Special processors (notify) just wait for resolution\r\n                      if (special) {\r\n                        then.call(\r\n                          returned,\r\n                          resolve(maxDepth, deferred, Identity, special),\r\n                          resolve(maxDepth, deferred, Thrower, special),\r\n                        );\r\n\r\n                        // Normal processors (resolve) also hook into progress\r\n                      } else {\r\n                        // ...and disregard older resolution values\r\n                        maxDepth++;\r\n\r\n                        then.call(\r\n                          returned,\r\n                          resolve(maxDepth, deferred, Identity, special),\r\n                          resolve(maxDepth, deferred, Thrower, special),\r\n                          resolve(maxDepth, deferred, Identity, deferred.notifyWith),\r\n                        );\r\n                      }\r\n\r\n                      // Handle all other returned values\r\n                    } else {\r\n                      // Only substitute handlers pass on context\r\n                      // and multiple values (non-spec behavior)\r\n                      if (handler !== Identity) {\r\n                        that = undefined;\r\n                        args = [returned];\r\n                      }\r\n\r\n                      // Process the value(s)\r\n                      // Default process is resolve\r\n                      (special || deferred.resolveWith)(that, args);\r\n                    }\r\n                  },\r\n                  // Only normal processors (resolve) catch and reject exceptions\r\n                  process = special\r\n                    ? mightThrow\r\n                    : function () {\r\n                        try {\r\n                          mightThrow();\r\n                        } catch (e) {\r\n                          if (jQuery.Deferred.exceptionHook) {\r\n                            jQuery.Deferred.exceptionHook(e, process.stackTrace);\r\n                          }\r\n\r\n                          // Support: Promises/A+ section 2.3.3.3.4.1\r\n                          // https://promisesaplus.com/#point-61\r\n                          // Ignore post-resolution exceptions\r\n                          if (depth + 1 >= maxDepth) {\r\n                            // Only substitute handlers pass on context\r\n                            // and multiple values (non-spec behavior)\r\n                            if (handler !== Thrower) {\r\n                              that = undefined;\r\n                              args = [e];\r\n                            }\r\n\r\n                            deferred.rejectWith(that, args);\r\n                          }\r\n                        }\r\n                      };\r\n\r\n                // Support: Promises/A+ section 2.3.3.3.1\r\n                // https://promisesaplus.com/#point-57\r\n                // Re-resolve promises immediately to dodge false rejection from\r\n                // subsequent errors\r\n                if (depth) {\r\n                  process();\r\n                } else {\r\n                  // Call an optional hook to record the stack, in case of exception\r\n                  // since it's otherwise lost when execution goes async\r\n                  if (jQuery.Deferred.getStackHook) {\r\n                    process.stackTrace = jQuery.Deferred.getStackHook();\r\n                  }\r\n                  window.setTimeout(process);\r\n                }\r\n              };\r\n            }\r\n\r\n            return jQuery\r\n              .Deferred(function (newDefer) {\r\n                // progress_handlers.add( ... )\r\n                tuples[0][3].add(\r\n                  resolve(\r\n                    0,\r\n                    newDefer,\r\n                    isFunction(onProgress) ? onProgress : Identity,\r\n                    newDefer.notifyWith,\r\n                  ),\r\n                );\r\n\r\n                // fulfilled_handlers.add( ... )\r\n                tuples[1][3].add(\r\n                  resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity),\r\n                );\r\n\r\n                // rejected_handlers.add( ... )\r\n                tuples[2][3].add(\r\n                  resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower),\r\n                );\r\n              })\r\n              .promise();\r\n          },\r\n\r\n          // Get a promise for this deferred\r\n          // If obj is provided, the promise aspect is added to the object\r\n          promise: function (obj) {\r\n            return obj != null ? jQuery.extend(obj, promise) : promise;\r\n          },\r\n        },\r\n        deferred = {};\r\n\r\n      // Add list-specific methods\r\n      jQuery.each(tuples, function (i, tuple) {\r\n        var list = tuple[2],\r\n          stateString = tuple[5];\r\n\r\n        // promise.progress = list.add\r\n        // promise.done = list.add\r\n        // promise.fail = list.add\r\n        promise[tuple[1]] = list.add;\r\n\r\n        // Handle state\r\n        if (stateString) {\r\n          list.add(\r\n            function () {\r\n              // state = \"resolved\" (i.e., fulfilled)\r\n              // state = \"rejected\"\r\n              state = stateString;\r\n            },\r\n\r\n            // rejected_callbacks.disable\r\n            // fulfilled_callbacks.disable\r\n            tuples[3 - i][2].disable,\r\n\r\n            // rejected_handlers.disable\r\n            // fulfilled_handlers.disable\r\n            tuples[3 - i][3].disable,\r\n\r\n            // progress_callbacks.lock\r\n            tuples[0][2].lock,\r\n\r\n            // progress_handlers.lock\r\n            tuples[0][3].lock,\r\n          );\r\n        }\r\n\r\n        // progress_handlers.fire\r\n        // fulfilled_handlers.fire\r\n        // rejected_handlers.fire\r\n        list.add(tuple[3].fire);\r\n\r\n        // deferred.notify = function() { deferred.notifyWith(...) }\r\n        // deferred.resolve = function() { deferred.resolveWith(...) }\r\n        // deferred.reject = function() { deferred.rejectWith(...) }\r\n        deferred[tuple[0]] = function () {\r\n          deferred[tuple[0] + 'With'](this === deferred ? undefined : this, arguments);\r\n          return this;\r\n        };\r\n\r\n        // deferred.notifyWith = list.fireWith\r\n        // deferred.resolveWith = list.fireWith\r\n        // deferred.rejectWith = list.fireWith\r\n        deferred[tuple[0] + 'With'] = list.fireWith;\r\n      });\r\n\r\n      // Make the deferred a promise\r\n      promise.promise(deferred);\r\n\r\n      // Call given func if any\r\n      if (func) {\r\n        func.call(deferred, deferred);\r\n      }\r\n\r\n      // All done!\r\n      return deferred;\r\n    },\r\n\r\n    // Deferred helper\r\n    when: function (singleValue) {\r\n      var // count of uncompleted subordinates\r\n        remaining = arguments.length,\r\n        // count of unprocessed arguments\r\n        i = remaining,\r\n        // subordinate fulfillment data\r\n        resolveContexts = Array(i),\r\n        resolveValues = slice.call(arguments),\r\n        // the primary Deferred\r\n        primary = jQuery.Deferred(),\r\n        // subordinate callback factory\r\n        updateFunc = function (i) {\r\n          return function (value) {\r\n            resolveContexts[i] = this;\r\n            resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;\r\n            if (!--remaining) {\r\n              primary.resolveWith(resolveContexts, resolveValues);\r\n            }\r\n          };\r\n        };\r\n\r\n      // Single- and empty arguments are adopted like Promise.resolve\r\n      if (remaining <= 1) {\r\n        adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining);\r\n\r\n        // Use .then() to unwrap secondary thenables (cf. gh-3000)\r\n        if (\r\n          primary.state() === 'pending' ||\r\n          isFunction(resolveValues[i] && resolveValues[i].then)\r\n        ) {\r\n          return primary.then();\r\n        }\r\n      }\r\n\r\n      // Multiple arguments are aggregated like Promise.all array elements\r\n      while (i--) {\r\n        adoptValue(resolveValues[i], updateFunc(i), primary.reject);\r\n      }\r\n\r\n      return primary.promise();\r\n    },\r\n  });\r\n\r\n  // These usually indicate a programmer mistake during development,\r\n  // warn about them ASAP rather than swallowing them by default.\r\n  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\r\n\r\n  jQuery.Deferred.exceptionHook = function (error, stack) {\r\n    // Support: IE 8 - 9 only\r\n    // Console exists when dev tools are open, which can happen at any time\r\n    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {\r\n      window.console.warn('jQuery.Deferred exception: ' + error.message, error.stack, stack);\r\n    }\r\n  };\r\n\r\n  jQuery.readyException = function (error) {\r\n    window.setTimeout(function () {\r\n      throw error;\r\n    });\r\n  };\r\n\r\n  // The deferred used on DOM ready\r\n  var readyList = jQuery.Deferred();\r\n\r\n  jQuery.fn.ready = function (fn) {\r\n    readyList\r\n      .then(fn)\r\n\r\n      // Wrap jQuery.readyException in a function so that the lookup\r\n      // happens at the time of error handling instead of callback\r\n      // registration.\r\n      .catch(function (error) {\r\n        jQuery.readyException(error);\r\n      });\r\n\r\n    return this;\r\n  };\r\n\r\n  jQuery.extend({\r\n    // Is the DOM ready to be used? Set to true once it occurs.\r\n    isReady: false,\r\n\r\n    // A counter to track how many items to wait for before\r\n    // the ready event fires. See trac-6781\r\n    readyWait: 1,\r\n\r\n    // Handle when the DOM is ready\r\n    ready: function (wait) {\r\n      // Abort if there are pending holds or we're already ready\r\n      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\r\n        return;\r\n      }\r\n\r\n      // Remember that the DOM is ready\r\n      jQuery.isReady = true;\r\n\r\n      // If a normal DOM Ready event fired, decrement, and wait if need be\r\n      if (wait !== true && --jQuery.readyWait > 0) {\r\n        return;\r\n      }\r\n\r\n      // If there are functions bound, to execute\r\n      readyList.resolveWith(document, [jQuery]);\r\n    },\r\n  });\r\n\r\n  jQuery.ready.then = readyList.then;\r\n\r\n  // The ready event handler and self cleanup method\r\n  function completed() {\r\n    document.removeEventListener('DOMContentLoaded', completed);\r\n    window.removeEventListener('load', completed);\r\n    jQuery.ready();\r\n  }\r\n\r\n  // Catch cases where $(document).ready() is called\r\n  // after the browser event has already occurred.\r\n  // Support: IE <=9 - 10 only\r\n  // Older IE sometimes signals \"interactive\" too soon\r\n  if (\r\n    document.readyState === 'complete' ||\r\n    (document.readyState !== 'loading' && !document.documentElement.doScroll)\r\n  ) {\r\n    // Handle it asynchronously to allow scripts the opportunity to delay ready\r\n    window.setTimeout(jQuery.ready);\r\n  } else {\r\n    // Use the handy event callback\r\n    document.addEventListener('DOMContentLoaded', completed);\r\n\r\n    // A fallback to window.onload, that will always work\r\n    window.addEventListener('load', completed);\r\n  }\r\n\r\n  // Multifunctional method to get and set values of a collection\r\n  // The value/s can optionally be executed if it's a function\r\n  var access = function (elems, fn, key, value, chainable, emptyGet, raw) {\r\n    var i = 0,\r\n      len = elems.length,\r\n      bulk = key == null;\r\n\r\n    // Sets many values\r\n    if (toType(key) === 'object') {\r\n      chainable = true;\r\n      for (i in key) {\r\n        access(elems, fn, i, key[i], true, emptyGet, raw);\r\n      }\r\n\r\n      // Sets one value\r\n    } else if (value !== undefined) {\r\n      chainable = true;\r\n\r\n      if (!isFunction(value)) {\r\n        raw = true;\r\n      }\r\n\r\n      if (bulk) {\r\n        // Bulk operations run against the entire set\r\n        if (raw) {\r\n          fn.call(elems, value);\r\n          fn = null;\r\n\r\n          // ...except when executing function values\r\n        } else {\r\n          bulk = fn;\r\n          fn = function (elem, _key, value) {\r\n            return bulk.call(jQuery(elem), value);\r\n          };\r\n        }\r\n      }\r\n\r\n      if (fn) {\r\n        for (; i < len; i++) {\r\n          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\r\n        }\r\n      }\r\n    }\r\n\r\n    if (chainable) {\r\n      return elems;\r\n    }\r\n\r\n    // Gets\r\n    if (bulk) {\r\n      return fn.call(elems);\r\n    }\r\n\r\n    return len ? fn(elems[0], key) : emptyGet;\r\n  };\r\n\r\n  // Matches dashed string for camelizing\r\n  var rmsPrefix = /^-ms-/,\r\n    rdashAlpha = /-([a-z])/g;\r\n\r\n  // Used by camelCase as callback to replace()\r\n  function fcamelCase(_all, letter) {\r\n    return letter.toUpperCase();\r\n  }\r\n\r\n  // Convert dashed to camelCase; used by the css and data modules\r\n  // Support: IE <=9 - 11, Edge 12 - 15\r\n  // Microsoft forgot to hump their vendor prefix (trac-9572)\r\n  function camelCase(string) {\r\n    return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);\r\n  }\r\n  var acceptData = function (owner) {\r\n    // Accepts only:\r\n    //  - Node\r\n    //    - Node.ELEMENT_NODE\r\n    //    - Node.DOCUMENT_NODE\r\n    //  - Object\r\n    //    - Any\r\n    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;\r\n  };\r\n\r\n  function Data() {\r\n    this.expando = jQuery.expando + Data.uid++;\r\n  }\r\n\r\n  Data.uid = 1;\r\n\r\n  Data.prototype = {\r\n    cache: function (owner) {\r\n      // Check if the owner object already has a cache\r\n      var value = owner[this.expando];\r\n\r\n      // If not, create one\r\n      if (!value) {\r\n        value = {};\r\n\r\n        // We can accept data for non-element nodes in modern browsers,\r\n        // but we should not, see trac-8335.\r\n        // Always return an empty object.\r\n        if (acceptData(owner)) {\r\n          // If it is a node unlikely to be stringify-ed or looped over\r\n          // use plain assignment\r\n          if (owner.nodeType) {\r\n            owner[this.expando] = value;\r\n\r\n            // Otherwise secure it in a non-enumerable property\r\n            // configurable must be true to allow the property to be\r\n            // deleted when data is removed\r\n          } else {\r\n            Object.defineProperty(owner, this.expando, {\r\n              value: value,\r\n              configurable: true,\r\n            });\r\n          }\r\n        }\r\n      }\r\n\r\n      return value;\r\n    },\r\n    set: function (owner, data, value) {\r\n      var prop,\r\n        cache = this.cache(owner);\r\n\r\n      // Handle: [ owner, key, value ] args\r\n      // Always use camelCase key (gh-2257)\r\n      if (typeof data === 'string') {\r\n        cache[camelCase(data)] = value;\r\n\r\n        // Handle: [ owner, { properties } ] args\r\n      } else {\r\n        // Copy the properties one-by-one to the cache object\r\n        for (prop in data) {\r\n          cache[camelCase(prop)] = data[prop];\r\n        }\r\n      }\r\n      return cache;\r\n    },\r\n    get: function (owner, key) {\r\n      return key === undefined\r\n        ? this.cache(owner)\r\n        : // Always use camelCase key (gh-2257)\r\n          owner[this.expando] && owner[this.expando][camelCase(key)];\r\n    },\r\n    access: function (owner, key, value) {\r\n      // In cases where either:\r\n      //\r\n      //   1. No key was specified\r\n      //   2. A string key was specified, but no value provided\r\n      //\r\n      // Take the \"read\" path and allow the get method to determine\r\n      // which value to return, respectively either:\r\n      //\r\n      //   1. The entire cache object\r\n      //   2. The data stored at the key\r\n      //\r\n      if (key === undefined || (key && typeof key === 'string' && value === undefined)) {\r\n        return this.get(owner, key);\r\n      }\r\n\r\n      // When the key is not a string, or both a key and value\r\n      // are specified, set or extend (existing objects) with either:\r\n      //\r\n      //   1. An object of properties\r\n      //   2. A key and value\r\n      //\r\n      this.set(owner, key, value);\r\n\r\n      // Since the \"set\" path can have two possible entry points\r\n      // return the expected data based on which path was taken[*]\r\n      return value !== undefined ? value : key;\r\n    },\r\n    remove: function (owner, key) {\r\n      var i,\r\n        cache = owner[this.expando];\r\n\r\n      if (cache === undefined) {\r\n        return;\r\n      }\r\n\r\n      if (key !== undefined) {\r\n        // Support array or space separated string of keys\r\n        if (Array.isArray(key)) {\r\n          // If key is an array of keys...\r\n          // We always set camelCase keys, so remove that.\r\n          key = key.map(camelCase);\r\n        } else {\r\n          key = camelCase(key);\r\n\r\n          // If a key with the spaces exists, use it.\r\n          // Otherwise, create an array by matching non-whitespace\r\n          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];\r\n        }\r\n\r\n        i = key.length;\r\n\r\n        while (i--) {\r\n          delete cache[key[i]];\r\n        }\r\n      }\r\n\r\n      // Remove the expando if there's no more data\r\n      if (key === undefined || jQuery.isEmptyObject(cache)) {\r\n        // Support: Chrome <=35 - 45\r\n        // Webkit & Blink performance suffers when deleting properties\r\n        // from DOM nodes, so set to undefined instead\r\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\r\n        if (owner.nodeType) {\r\n          owner[this.expando] = undefined;\r\n        } else {\r\n          delete owner[this.expando];\r\n        }\r\n      }\r\n    },\r\n    hasData: function (owner) {\r\n      var cache = owner[this.expando];\r\n      return cache !== undefined && !jQuery.isEmptyObject(cache);\r\n    },\r\n  };\r\n  var dataPriv = new Data();\r\n\r\n  var dataUser = new Data();\r\n\r\n  //\tImplementation Summary\r\n  //\r\n  //\t1. Enforce API surface and semantic compatibility with 1.9.x branch\r\n  //\t2. Improve the module's maintainability by reducing the storage\r\n  //\t\tpaths to a single mechanism.\r\n  //\t3. Use the same single mechanism to support \"private\" and \"user\" data.\r\n  //\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\r\n  //\t5. Avoid exposing implementation details on user objects (eg. expando properties)\r\n  //\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\r\n\r\n  var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\r\n    rmultiDash = /[A-Z]/g;\r\n\r\n  function getData(data) {\r\n    if (data === 'true') {\r\n      return true;\r\n    }\r\n\r\n    if (data === 'false') {\r\n      return false;\r\n    }\r\n\r\n    if (data === 'null') {\r\n      return null;\r\n    }\r\n\r\n    // Only convert to a number if it doesn't change the string\r\n    if (data === +data + '') {\r\n      return +data;\r\n    }\r\n\r\n    if (rbrace.test(data)) {\r\n      return JSON.parse(data);\r\n    }\r\n\r\n    return data;\r\n  }\r\n\r\n  function dataAttr(elem, key, data) {\r\n    var name;\r\n\r\n    // If nothing was found internally, try to fetch any\r\n    // data from the HTML5 data-* attribute\r\n    if (data === undefined && elem.nodeType === 1) {\r\n      name = 'data-' + key.replace(rmultiDash, '-$&').toLowerCase();\r\n      data = elem.getAttribute(name);\r\n\r\n      if (typeof data === 'string') {\r\n        try {\r\n          data = getData(data);\r\n        } catch (e) {}\r\n\r\n        // Make sure we set the data so it isn't changed later\r\n        dataUser.set(elem, key, data);\r\n      } else {\r\n        data = undefined;\r\n      }\r\n    }\r\n    return data;\r\n  }\r\n\r\n  jQuery.extend({\r\n    hasData: function (elem) {\r\n      return dataUser.hasData(elem) || dataPriv.hasData(elem);\r\n    },\r\n\r\n    data: function (elem, name, data) {\r\n      return dataUser.access(elem, name, data);\r\n    },\r\n\r\n    removeData: function (elem, name) {\r\n      dataUser.remove(elem, name);\r\n    },\r\n\r\n    // TODO: Now that all calls to _data and _removeData have been replaced\r\n    // with direct calls to dataPriv methods, these can be deprecated.\r\n    _data: function (elem, name, data) {\r\n      return dataPriv.access(elem, name, data);\r\n    },\r\n\r\n    _removeData: function (elem, name) {\r\n      dataPriv.remove(elem, name);\r\n    },\r\n  });\r\n\r\n  jQuery.fn.extend({\r\n    data: function (key, value) {\r\n      var i,\r\n        name,\r\n        data,\r\n        elem = this[0],\r\n        attrs = elem && elem.attributes;\r\n\r\n      // Gets all values\r\n      if (key === undefined) {\r\n        if (this.length) {\r\n          data = dataUser.get(elem);\r\n\r\n          if (elem.nodeType === 1 && !dataPriv.get(elem, 'hasDataAttrs')) {\r\n            i = attrs.length;\r\n            while (i--) {\r\n              // Support: IE 11 only\r\n              // The attrs elements can be null (trac-14894)\r\n              if (attrs[i]) {\r\n                name = attrs[i].name;\r\n                if (name.indexOf('data-') === 0) {\r\n                  name = camelCase(name.slice(5));\r\n                  dataAttr(elem, name, data[name]);\r\n                }\r\n              }\r\n            }\r\n            dataPriv.set(elem, 'hasDataAttrs', true);\r\n          }\r\n        }\r\n\r\n        return data;\r\n      }\r\n\r\n      // Sets multiple values\r\n      if (typeof key === 'object') {\r\n        return this.each(function () {\r\n          dataUser.set(this, key);\r\n        });\r\n      }\r\n\r\n      return access(\r\n        this,\r\n        function (value) {\r\n          var data;\r\n\r\n          // The calling jQuery object (element matches) is not empty\r\n          // (and therefore has an element appears at this[ 0 ]) and the\r\n          // `value` parameter was not undefined. An empty jQuery object\r\n          // will result in `undefined` for elem = this[ 0 ] which will\r\n          // throw an exception if an attempt to read a data cache is made.\r\n          if (elem && value === undefined) {\r\n            // Attempt to get data from the cache\r\n            // The key will always be camelCased in Data\r\n            data = dataUser.get(elem, key);\r\n            if (data !== undefined) {\r\n              return data;\r\n            }\r\n\r\n            // Attempt to \"discover\" the data in\r\n            // HTML5 custom data-* attrs\r\n            data = dataAttr(elem, key);\r\n            if (data !== undefined) {\r\n              return data;\r\n            }\r\n\r\n            // We tried really hard, but the data doesn't exist.\r\n            return;\r\n          }\r\n\r\n          // Set the data...\r\n          this.each(function () {\r\n            // We always store the camelCased key\r\n            dataUser.set(this, key, value);\r\n          });\r\n        },\r\n        null,\r\n        value,\r\n        arguments.length > 1,\r\n        null,\r\n        true,\r\n      );\r\n    },\r\n\r\n    removeData: function (key) {\r\n      return this.each(function () {\r\n        dataUser.remove(this, key);\r\n      });\r\n    },\r\n  });\r\n\r\n  jQuery.extend({\r\n    queue: function (elem, type, data) {\r\n      var queue;\r\n\r\n      if (elem) {\r\n        type = (type || 'fx') + 'queue';\r\n        queue = dataPriv.get(elem, type);\r\n\r\n        // Speed up dequeue by getting out quickly if this is just a lookup\r\n        if (data) {\r\n          if (!queue || Array.isArray(data)) {\r\n            queue = dataPriv.access(elem, type, jQuery.makeArray(data));\r\n          } else {\r\n            queue.push(data);\r\n          }\r\n        }\r\n        return queue || [];\r\n      }\r\n    },\r\n\r\n    dequeue: function (elem, type) {\r\n      type = type || 'fx';\r\n\r\n      var queue = jQuery.queue(elem, type),\r\n        startLength = queue.length,\r\n        fn = queue.shift(),\r\n        hooks = jQuery._queueHooks(elem, type),\r\n        next = function () {\r\n          jQuery.dequeue(elem, type);\r\n        };\r\n\r\n      // If the fx queue is dequeued, always remove the progress sentinel\r\n      if (fn === 'inprogress') {\r\n        fn = queue.shift();\r\n        startLength--;\r\n      }\r\n\r\n      if (fn) {\r\n        // Add a progress sentinel to prevent the fx queue from being\r\n        // automatically dequeued\r\n        if (type === 'fx') {\r\n          queue.unshift('inprogress');\r\n        }\r\n\r\n        // Clear up the last queue stop function\r\n        delete hooks.stop;\r\n        fn.call(elem, next, hooks);\r\n      }\r\n\r\n      if (!startLength && hooks) {\r\n        hooks.empty.fire();\r\n      }\r\n    },\r\n\r\n    // Not public - generate a queueHooks object, or return the current one\r\n    _queueHooks: function (elem, type) {\r\n      var key = type + 'queueHooks';\r\n      return (\r\n        dataPriv.get(elem, key) ||\r\n        dataPriv.access(elem, key, {\r\n          empty: jQuery.Callbacks('once memory').add(function () {\r\n            dataPriv.remove(elem, [type + 'queue', key]);\r\n          }),\r\n        })\r\n      );\r\n    },\r\n  });\r\n\r\n  jQuery.fn.extend({\r\n    queue: function (type, data) {\r\n      var setter = 2;\r\n\r\n      if (typeof type !== 'string') {\r\n        data = type;\r\n        type = 'fx';\r\n        setter--;\r\n      }\r\n\r\n      if (arguments.length < setter) {\r\n        return jQuery.queue(this[0], type);\r\n      }\r\n\r\n      return data === undefined\r\n        ? this\r\n        : this.each(function () {\r\n            var queue = jQuery.queue(this, type, data);\r\n\r\n            // Ensure a hooks for this queue\r\n            jQuery._queueHooks(this, type);\r\n\r\n            if (type === 'fx' && queue[0] !== 'inprogress') {\r\n              jQuery.dequeue(this, type);\r\n            }\r\n          });\r\n    },\r\n    dequeue: function (type) {\r\n      return this.each(function () {\r\n        jQuery.dequeue(this, type);\r\n      });\r\n    },\r\n    clearQueue: function (type) {\r\n      return this.queue(type || 'fx', []);\r\n    },\r\n\r\n    // Get a promise resolved when queues of a certain type\r\n    // are emptied (fx is the type by default)\r\n    promise: function (type, obj) {\r\n      var tmp,\r\n        count = 1,\r\n        defer = jQuery.Deferred(),\r\n        elements = this,\r\n        i = this.length,\r\n        resolve = function () {\r\n          if (!--count) {\r\n            defer.resolveWith(elements, [elements]);\r\n          }\r\n        };\r\n\r\n      if (typeof type !== 'string') {\r\n        obj = type;\r\n        type = undefined;\r\n      }\r\n      type = type || 'fx';\r\n\r\n      while (i--) {\r\n        tmp = dataPriv.get(elements[i], type + 'queueHooks');\r\n        if (tmp && tmp.empty) {\r\n          count++;\r\n          tmp.empty.add(resolve);\r\n        }\r\n      }\r\n      resolve();\r\n      return defer.promise(obj);\r\n    },\r\n  });\r\n  var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\r\n\r\n  var rcssNum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i');\r\n\r\n  var cssExpand = ['Top', 'Right', 'Bottom', 'Left'];\r\n\r\n  var documentElement = document.documentElement;\r\n\r\n  var isAttached = function (elem) {\r\n      return jQuery.contains(elem.ownerDocument, elem);\r\n    },\r\n    composed = { composed: true };\r\n\r\n  // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\r\n  // Check attachment across shadow DOM boundaries when possible (gh-3504)\r\n  // Support: iOS 10.0-10.2 only\r\n  // Early iOS 10 versions support `attachShadow` but not `getRootNode`,\r\n  // leading to errors. We need to check for `getRootNode`.\r\n  if (documentElement.getRootNode) {\r\n    isAttached = function (elem) {\r\n      return (\r\n        jQuery.contains(elem.ownerDocument, elem) ||\r\n        elem.getRootNode(composed) === elem.ownerDocument\r\n      );\r\n    };\r\n  }\r\n  var isHiddenWithinTree = function (elem, el) {\r\n    // isHiddenWithinTree might be called from jQuery#filter function;\r\n    // in that case, element will be second argument\r\n    elem = el || elem;\r\n\r\n    // Inline style trumps all\r\n    return (\r\n      elem.style.display === 'none' ||\r\n      (elem.style.display === '' &&\r\n        // Otherwise, check computed style\r\n        // Support: Firefox <=43 - 45\r\n        // Disconnected elements can have computed display: none, so first confirm that elem is\r\n        // in the document.\r\n        isAttached(elem) &&\r\n        jQuery.css(elem, 'display') === 'none')\r\n    );\r\n  };\r\n\r\n  function adjustCSS(elem, prop, valueParts, tween) {\r\n    var adjusted,\r\n      scale,\r\n      maxIterations = 20,\r\n      currentValue = tween\r\n        ? function () {\r\n            return tween.cur();\r\n          }\r\n        : function () {\r\n            return jQuery.css(elem, prop, '');\r\n          },\r\n      initial = currentValue(),\r\n      unit = (valueParts && valueParts[3]) || (jQuery.cssNumber[prop] ? '' : 'px'),\r\n      // Starting value computation is required for potential unit mismatches\r\n      initialInUnit =\r\n        elem.nodeType &&\r\n        (jQuery.cssNumber[prop] || (unit !== 'px' && +initial)) &&\r\n        rcssNum.exec(jQuery.css(elem, prop));\r\n\r\n    if (initialInUnit && initialInUnit[3] !== unit) {\r\n      // Support: Firefox <=54\r\n      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\r\n      initial = initial / 2;\r\n\r\n      // Trust units reported by jQuery.css\r\n      unit = unit || initialInUnit[3];\r\n\r\n      // Iteratively approximate from a nonzero starting point\r\n      initialInUnit = +initial || 1;\r\n\r\n      while (maxIterations--) {\r\n        // Evaluate and update our best guess (doubling guesses that zero out).\r\n        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).\r\n        jQuery.style(elem, prop, initialInUnit + unit);\r\n        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {\r\n          maxIterations = 0;\r\n        }\r\n        initialInUnit = initialInUnit / scale;\r\n      }\r\n\r\n      initialInUnit = initialInUnit * 2;\r\n      jQuery.style(elem, prop, initialInUnit + unit);\r\n\r\n      // Make sure we update the tween properties later on\r\n      valueParts = valueParts || [];\r\n    }\r\n\r\n    if (valueParts) {\r\n      initialInUnit = +initialInUnit || +initial || 0;\r\n\r\n      // Apply relative offset (+=/-=) if specified\r\n      adjusted = valueParts[1]\r\n        ? initialInUnit + (valueParts[1] + 1) * valueParts[2]\r\n        : +valueParts[2];\r\n      if (tween) {\r\n        tween.unit = unit;\r\n        tween.start = initialInUnit;\r\n        tween.end = adjusted;\r\n      }\r\n    }\r\n    return adjusted;\r\n  }\r\n\r\n  var defaultDisplayMap = {};\r\n\r\n  function getDefaultDisplay(elem) {\r\n    var temp,\r\n      doc = elem.ownerDocument,\r\n      nodeName = elem.nodeName,\r\n      display = defaultDisplayMap[nodeName];\r\n\r\n    if (display) {\r\n      return display;\r\n    }\r\n\r\n    temp = doc.body.appendChild(doc.createElement(nodeName));\r\n    display = jQuery.css(temp, 'display');\r\n\r\n    temp.parentNode.removeChild(temp);\r\n\r\n    if (display === 'none') {\r\n      display = 'block';\r\n    }\r\n    defaultDisplayMap[nodeName] = display;\r\n\r\n    return display;\r\n  }\r\n\r\n  function showHide(elements, show) {\r\n    var display,\r\n      elem,\r\n      values = [],\r\n      index = 0,\r\n      length = elements.length;\r\n\r\n    // Determine new display value for elements that need to change\r\n    for (; index < length; index++) {\r\n      elem = elements[index];\r\n      if (!elem.style) {\r\n        continue;\r\n      }\r\n\r\n      display = elem.style.display;\r\n      if (show) {\r\n        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)\r\n        // check is required in this first loop unless we have a nonempty display value (either\r\n        // inline or about-to-be-restored)\r\n        if (display === 'none') {\r\n          values[index] = dataPriv.get(elem, 'display') || null;\r\n          if (!values[index]) {\r\n            elem.style.display = '';\r\n          }\r\n        }\r\n        if (elem.style.display === '' && isHiddenWithinTree(elem)) {\r\n          values[index] = getDefaultDisplay(elem);\r\n        }\r\n      } else {\r\n        if (display !== 'none') {\r\n          values[index] = 'none';\r\n\r\n          // Remember what we're overwriting\r\n          dataPriv.set(elem, 'display', display);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Set the display of the elements in a second loop to avoid constant reflow\r\n    for (index = 0; index < length; index++) {\r\n      if (values[index] != null) {\r\n        elements[index].style.display = values[index];\r\n      }\r\n    }\r\n\r\n    return elements;\r\n  }\r\n\r\n  jQuery.fn.extend({\r\n    show: function () {\r\n      return showHide(this, true);\r\n    },\r\n    hide: function () {\r\n      return showHide(this);\r\n    },\r\n    toggle: function (state) {\r\n      if (typeof state === 'boolean') {\r\n        return state ? this.show() : this.hide();\r\n      }\r\n\r\n      return this.each(function () {\r\n        if (isHiddenWithinTree(this)) {\r\n          jQuery(this).show();\r\n        } else {\r\n          jQuery(this).hide();\r\n        }\r\n      });\r\n    },\r\n  });\r\n  var rcheckableType = /^(?:checkbox|radio)$/i;\r\n\r\n  var rtagName = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i;\r\n\r\n  var rscriptType = /^$|^module$|\\/(?:java|ecma)script/i;\r\n\r\n  (function () {\r\n    var fragment = document.createDocumentFragment(),\r\n      div = fragment.appendChild(document.createElement('div')),\r\n      input = document.createElement('input');\r\n\r\n    // Support: Android 4.0 - 4.3 only\r\n    // Check state lost if the name is set (trac-11217)\r\n    // Support: Windows Web Apps (WWA)\r\n    // `name` and `type` must use .setAttribute for WWA (trac-14901)\r\n    input.setAttribute('type', 'radio');\r\n    input.setAttribute('checked', 'checked');\r\n    input.setAttribute('name', 't');\r\n\r\n    div.appendChild(input);\r\n\r\n    // Support: Android <=4.1 only\r\n    // Older WebKit doesn't clone checked state correctly in fragments\r\n    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;\r\n\r\n    // Support: IE <=11 only\r\n    // Make sure textarea (and checkbox) defaultValue is properly cloned\r\n    div.innerHTML = '<textarea>x</textarea>';\r\n    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;\r\n\r\n    // Support: IE <=9 only\r\n    // IE <=9 replaces <option> tags with their contents when inserted outside of\r\n    // the select element.\r\n    div.innerHTML = '<option></option>';\r\n    support.option = !!div.lastChild;\r\n  })();\r\n\r\n  // We have to close these tags to support XHTML (trac-13200)\r\n  var wrapMap = {\r\n    // XHTML parsers do not magically insert elements in the\r\n    // same way that tag soup parsers do. So we cannot shorten\r\n    // this by omitting <tbody> or other required elements.\r\n    thead: [1, '<table>', '</table>'],\r\n    col: [2, '<table><colgroup>', '</colgroup></table>'],\r\n    tr: [2, '<table><tbody>', '</tbody></table>'],\r\n    td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],\r\n\r\n    _default: [0, '', ''],\r\n  };\r\n\r\n  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\r\n  wrapMap.th = wrapMap.td;\r\n\r\n  // Support: IE <=9 only\r\n  if (!support.option) {\r\n    wrapMap.optgroup = wrapMap.option = [1, \"<select multiple='multiple'>\", '</select>'];\r\n  }\r\n\r\n  function getAll(context, tag) {\r\n    // Support: IE <=9 - 11 only\r\n    // Use typeof to avoid zero-argument method invocation on host objects (trac-15151)\r\n    var ret;\r\n\r\n    if (typeof context.getElementsByTagName !== 'undefined') {\r\n      ret = context.getElementsByTagName(tag || '*');\r\n    } else if (typeof context.querySelectorAll !== 'undefined') {\r\n      ret = context.querySelectorAll(tag || '*');\r\n    } else {\r\n      ret = [];\r\n    }\r\n\r\n    if (tag === undefined || (tag && nodeName(context, tag))) {\r\n      return jQuery.merge([context], ret);\r\n    }\r\n\r\n    return ret;\r\n  }\r\n\r\n  // Mark scripts as having already been evaluated\r\n  function setGlobalEval(elems, refElements) {\r\n    var i = 0,\r\n      l = elems.length;\r\n\r\n    for (; i < l; i++) {\r\n      dataPriv.set(\r\n        elems[i],\r\n        'globalEval',\r\n        !refElements || dataPriv.get(refElements[i], 'globalEval'),\r\n      );\r\n    }\r\n  }\r\n\r\n  var rhtml = /<|&#?\\w+;/;\r\n\r\n  function buildFragment(elems, context, scripts, selection, ignored) {\r\n    var elem,\r\n      tmp,\r\n      tag,\r\n      wrap,\r\n      attached,\r\n      j,\r\n      fragment = context.createDocumentFragment(),\r\n      nodes = [],\r\n      i = 0,\r\n      l = elems.length;\r\n\r\n    for (; i < l; i++) {\r\n      elem = elems[i];\r\n\r\n      if (elem || elem === 0) {\r\n        // Add nodes directly\r\n        if (toType(elem) === 'object') {\r\n          // Support: Android <=4.0 only, PhantomJS 1 only\r\n          // push.apply(_, arraylike) throws on ancient WebKit\r\n          jQuery.merge(nodes, elem.nodeType ? [elem] : elem);\r\n\r\n          // Convert non-html into a text node\r\n        } else if (!rhtml.test(elem)) {\r\n          nodes.push(context.createTextNode(elem));\r\n\r\n          // Convert html into DOM nodes\r\n        } else {\r\n          tmp = tmp || fragment.appendChild(context.createElement('div'));\r\n\r\n          // Deserialize a standard representation\r\n          tag = (rtagName.exec(elem) || ['', ''])[1].toLowerCase();\r\n          wrap = wrapMap[tag] || wrapMap._default;\r\n          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];\r\n\r\n          // Descend through wrappers to the right content\r\n          j = wrap[0];\r\n          while (j--) {\r\n            tmp = tmp.lastChild;\r\n          }\r\n\r\n          // Support: Android <=4.0 only, PhantomJS 1 only\r\n          // push.apply(_, arraylike) throws on ancient WebKit\r\n          jQuery.merge(nodes, tmp.childNodes);\r\n\r\n          // Remember the top-level container\r\n          tmp = fragment.firstChild;\r\n\r\n          // Ensure the created nodes are orphaned (trac-12392)\r\n          tmp.textContent = '';\r\n        }\r\n      }\r\n    }\r\n\r\n    // Remove wrapper from fragment\r\n    fragment.textContent = '';\r\n\r\n    i = 0;\r\n    while ((elem = nodes[i++])) {\r\n      // Skip elements already in the context collection (trac-4087)\r\n      if (selection && jQuery.inArray(elem, selection) > -1) {\r\n        if (ignored) {\r\n          ignored.push(elem);\r\n        }\r\n        continue;\r\n      }\r\n\r\n      attached = isAttached(elem);\r\n\r\n      // Append to fragment\r\n      tmp = getAll(fragment.appendChild(elem), 'script');\r\n\r\n      // Preserve script evaluation history\r\n      if (attached) {\r\n        setGlobalEval(tmp);\r\n      }\r\n\r\n      // Capture executables\r\n      if (scripts) {\r\n        j = 0;\r\n        while ((elem = tmp[j++])) {\r\n          if (rscriptType.test(elem.type || '')) {\r\n            scripts.push(elem);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return fragment;\r\n  }\r\n\r\n  var rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\r\n\r\n  function returnTrue() {\r\n    return true;\r\n  }\r\n\r\n  function returnFalse() {\r\n    return false;\r\n  }\r\n\r\n  // Support: IE <=9 - 11+\r\n  // focus() and blur() are asynchronous, except when they are no-op.\r\n  // So expect focus to be synchronous when the element is already active,\r\n  // and blur to be synchronous when the element is not already active.\r\n  // (focus and blur are always synchronous in other supported browsers,\r\n  // this just defines when we can count on it).\r\n  function expectSync(elem, type) {\r\n    return (elem === safeActiveElement()) === (type === 'focus');\r\n  }\r\n\r\n  // Support: IE <=9 only\r\n  // Accessing document.activeElement can throw unexpectedly\r\n  // https://bugs.jquery.com/ticket/13393\r\n  function safeActiveElement() {\r\n    try {\r\n      return document.activeElement;\r\n    } catch (err) {}\r\n  }\r\n\r\n  function on(elem, types, selector, data, fn, one) {\r\n    var origFn, type;\r\n\r\n    // Types can be a map of types/handlers\r\n    if (typeof types === 'object') {\r\n      // ( types-Object, selector, data )\r\n      if (typeof selector !== 'string') {\r\n        // ( types-Object, data )\r\n        data = data || selector;\r\n        selector = undefined;\r\n      }\r\n      for (type in types) {\r\n        on(elem, type, selector, data, types[type], one);\r\n      }\r\n      return elem;\r\n    }\r\n\r\n    if (data == null && fn == null) {\r\n      // ( types, fn )\r\n      fn = selector;\r\n      data = selector = undefined;\r\n    } else if (fn == null) {\r\n      if (typeof selector === 'string') {\r\n        // ( types, selector, fn )\r\n        fn = data;\r\n        data = undefined;\r\n      } else {\r\n        // ( types, data, fn )\r\n        fn = data;\r\n        data = selector;\r\n        selector = undefined;\r\n      }\r\n    }\r\n    if (fn === false) {\r\n      fn = returnFalse;\r\n    } else if (!fn) {\r\n      return elem;\r\n    }\r\n\r\n    if (one === 1) {\r\n      origFn = fn;\r\n      fn = function (event) {\r\n        // Can use an empty set, since event contains the info\r\n        jQuery().off(event);\r\n        return origFn.apply(this, arguments);\r\n      };\r\n\r\n      // Use same guid so caller can remove using origFn\r\n      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\r\n    }\r\n    return elem.each(function () {\r\n      jQuery.event.add(this, types, fn, data, selector);\r\n    });\r\n  }\r\n\r\n  /*\r\n   * Helper functions for managing events -- not part of the public interface.\r\n   * Props to Dean Edwards' addEvent library for many of the ideas.\r\n   */\r\n  jQuery.event = {\r\n    global: {},\r\n\r\n    add: function (elem, types, handler, data, selector) {\r\n      var handleObjIn,\r\n        eventHandle,\r\n        tmp,\r\n        events,\r\n        t,\r\n        handleObj,\r\n        special,\r\n        handlers,\r\n        type,\r\n        namespaces,\r\n        origType,\r\n        elemData = dataPriv.get(elem);\r\n\r\n      // Only attach events to objects that accept data\r\n      if (!acceptData(elem)) {\r\n        return;\r\n      }\r\n\r\n      // Caller can pass in an object of custom data in lieu of the handler\r\n      if (handler.handler) {\r\n        handleObjIn = handler;\r\n        handler = handleObjIn.handler;\r\n        selector = handleObjIn.selector;\r\n      }\r\n\r\n      // Ensure that invalid selectors throw exceptions at attach time\r\n      // Evaluate against documentElement in case elem is a non-element node (e.g., document)\r\n      if (selector) {\r\n        jQuery.find.matchesSelector(documentElement, selector);\r\n      }\r\n\r\n      // Make sure that the handler has a unique ID, used to find/remove it later\r\n      if (!handler.guid) {\r\n        handler.guid = jQuery.guid++;\r\n      }\r\n\r\n      // Init the element's event structure and main handler, if this is the first\r\n      if (!(events = elemData.events)) {\r\n        events = elemData.events = Object.create(null);\r\n      }\r\n      if (!(eventHandle = elemData.handle)) {\r\n        eventHandle = elemData.handle = function (e) {\r\n          // Discard the second event of a jQuery.event.trigger() and\r\n          // when an event is called after a page has unloaded\r\n          return typeof jQuery !== 'undefined' && jQuery.event.triggered !== e.type\r\n            ? jQuery.event.dispatch.apply(elem, arguments)\r\n            : undefined;\r\n        };\r\n      }\r\n\r\n      // Handle multiple events separated by a space\r\n      types = (types || '').match(rnothtmlwhite) || [''];\r\n      t = types.length;\r\n      while (t--) {\r\n        tmp = rtypenamespace.exec(types[t]) || [];\r\n        type = origType = tmp[1];\r\n        namespaces = (tmp[2] || '').split('.').sort();\r\n\r\n        // There *must* be a type, no attaching namespace-only handlers\r\n        if (!type) {\r\n          continue;\r\n        }\r\n\r\n        // If event changes its type, use the special event handlers for the changed type\r\n        special = jQuery.event.special[type] || {};\r\n\r\n        // If selector defined, determine special event api type, otherwise given type\r\n        type = (selector ? special.delegateType : special.bindType) || type;\r\n\r\n        // Update special based on newly reset type\r\n        special = jQuery.event.special[type] || {};\r\n\r\n        // handleObj is passed to all event handlers\r\n        handleObj = jQuery.extend(\r\n          {\r\n            type: type,\r\n            origType: origType,\r\n            data: data,\r\n            handler: handler,\r\n            guid: handler.guid,\r\n            selector: selector,\r\n            needsContext: selector && jQuery.expr.match.needsContext.test(selector),\r\n            namespace: namespaces.join('.'),\r\n          },\r\n          handleObjIn,\r\n        );\r\n\r\n        // Init the event handler queue if we're the first\r\n        if (!(handlers = events[type])) {\r\n          handlers = events[type] = [];\r\n          handlers.delegateCount = 0;\r\n\r\n          // Only use addEventListener if the special events handler returns false\r\n          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\r\n            if (elem.addEventListener) {\r\n              elem.addEventListener(type, eventHandle);\r\n            }\r\n          }\r\n        }\r\n\r\n        if (special.add) {\r\n          special.add.call(elem, handleObj);\r\n\r\n          if (!handleObj.handler.guid) {\r\n            handleObj.handler.guid = handler.guid;\r\n          }\r\n        }\r\n\r\n        // Add to the element's handler list, delegates in front\r\n        if (selector) {\r\n          handlers.splice(handlers.delegateCount++, 0, handleObj);\r\n        } else {\r\n          handlers.push(handleObj);\r\n        }\r\n\r\n        // Keep track of which events have ever been used, for event optimization\r\n        jQuery.event.global[type] = true;\r\n      }\r\n    },\r\n\r\n    // Detach an event or set of events from an element\r\n    remove: function (elem, types, handler, selector, mappedTypes) {\r\n      var j,\r\n        origCount,\r\n        tmp,\r\n        events,\r\n        t,\r\n        handleObj,\r\n        special,\r\n        handlers,\r\n        type,\r\n        namespaces,\r\n        origType,\r\n        elemData = dataPriv.hasData(elem) && dataPriv.get(elem);\r\n\r\n      if (!elemData || !(events = elemData.events)) {\r\n        return;\r\n      }\r\n\r\n      // Once for each type.namespace in types; type may be omitted\r\n      types = (types || '').match(rnothtmlwhite) || [''];\r\n      t = types.length;\r\n      while (t--) {\r\n        tmp = rtypenamespace.exec(types[t]) || [];\r\n        type = origType = tmp[1];\r\n        namespaces = (tmp[2] || '').split('.').sort();\r\n\r\n        // Unbind all events (on this namespace, if provided) for the element\r\n        if (!type) {\r\n          for (type in events) {\r\n            jQuery.event.remove(elem, type + types[t], handler, selector, true);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        special = jQuery.event.special[type] || {};\r\n        type = (selector ? special.delegateType : special.bindType) || type;\r\n        handlers = events[type] || [];\r\n        tmp = tmp[2] && new RegExp('(^|\\\\.)' + namespaces.join('\\\\.(?:.*\\\\.|)') + '(\\\\.|$)');\r\n\r\n        // Remove matching events\r\n        origCount = j = handlers.length;\r\n        while (j--) {\r\n          handleObj = handlers[j];\r\n\r\n          if (\r\n            (mappedTypes || origType === handleObj.origType) &&\r\n            (!handler || handler.guid === handleObj.guid) &&\r\n            (!tmp || tmp.test(handleObj.namespace)) &&\r\n            (!selector ||\r\n              selector === handleObj.selector ||\r\n              (selector === '**' && handleObj.selector))\r\n          ) {\r\n            handlers.splice(j, 1);\r\n\r\n            if (handleObj.selector) {\r\n              handlers.delegateCount--;\r\n            }\r\n            if (special.remove) {\r\n              special.remove.call(elem, handleObj);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Remove generic event handler if we removed something and no more handlers exist\r\n        // (avoids potential for endless recursion during removal of special event handlers)\r\n        if (origCount && !handlers.length) {\r\n          if (\r\n            !special.teardown ||\r\n            special.teardown.call(elem, namespaces, elemData.handle) === false\r\n          ) {\r\n            jQuery.removeEvent(elem, type, elemData.handle);\r\n          }\r\n\r\n          delete events[type];\r\n        }\r\n      }\r\n\r\n      // Remove data and the expando if it's no longer used\r\n      if (jQuery.isEmptyObject(events)) {\r\n        dataPriv.remove(elem, 'handle events');\r\n      }\r\n    },\r\n\r\n    dispatch: function (nativeEvent) {\r\n      var i,\r\n        j,\r\n        ret,\r\n        matched,\r\n        handleObj,\r\n        handlerQueue,\r\n        args = new Array(arguments.length),\r\n        // Make a writable jQuery.Event from the native event object\r\n        event = jQuery.event.fix(nativeEvent),\r\n        handlers = (dataPriv.get(this, 'events') || Object.create(null))[event.type] || [],\r\n        special = jQuery.event.special[event.type] || {};\r\n\r\n      // Use the fix-ed jQuery.Event rather than the (read-only) native event\r\n      args[0] = event;\r\n\r\n      for (i = 1; i < arguments.length; i++) {\r\n        args[i] = arguments[i];\r\n      }\r\n\r\n      event.delegateTarget = this;\r\n\r\n      // Call the preDispatch hook for the mapped type, and let it bail if desired\r\n      if (special.preDispatch && special.preDispatch.call(this, event) === false) {\r\n        return;\r\n      }\r\n\r\n      // Determine handlers\r\n      handlerQueue = jQuery.event.handlers.call(this, event, handlers);\r\n\r\n      // Run delegates first; they may want to stop propagation beneath us\r\n      i = 0;\r\n      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\r\n        event.currentTarget = matched.elem;\r\n\r\n        j = 0;\r\n        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\r\n          // If the event is namespaced, then each handler is only invoked if it is\r\n          // specially universal or its namespaces are a superset of the event's.\r\n          if (\r\n            !event.rnamespace ||\r\n            handleObj.namespace === false ||\r\n            event.rnamespace.test(handleObj.namespace)\r\n          ) {\r\n            event.handleObj = handleObj;\r\n            event.data = handleObj.data;\r\n\r\n            ret = (\r\n              (jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler\r\n            ).apply(matched.elem, args);\r\n\r\n            if (ret !== undefined) {\r\n              if ((event.result = ret) === false) {\r\n                event.preventDefault();\r\n                event.stopPropagation();\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Call the postDispatch hook for the mapped type\r\n      if (special.postDispatch) {\r\n        special.postDispatch.call(this, event);\r\n      }\r\n\r\n      return event.result;\r\n    },\r\n\r\n    handlers: function (event, handlers) {\r\n      var i,\r\n        handleObj,\r\n        sel,\r\n        matchedHandlers,\r\n        matchedSelectors,\r\n        handlerQueue = [],\r\n        delegateCount = handlers.delegateCount,\r\n        cur = event.target;\r\n\r\n      // Find delegate handlers\r\n      if (\r\n        delegateCount &&\r\n        // Support: IE <=9\r\n        // Black-hole SVG <use> instance trees (trac-13180)\r\n        cur.nodeType &&\r\n        // Support: Firefox <=42\r\n        // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\r\n        // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\r\n        // Support: IE 11 only\r\n        // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\r\n        !(event.type === 'click' && event.button >= 1)\r\n      ) {\r\n        for (; cur !== this; cur = cur.parentNode || this) {\r\n          // Don't check non-elements (trac-13208)\r\n          // Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)\r\n          if (cur.nodeType === 1 && !(event.type === 'click' && cur.disabled === true)) {\r\n            matchedHandlers = [];\r\n            matchedSelectors = {};\r\n            for (i = 0; i < delegateCount; i++) {\r\n              handleObj = handlers[i];\r\n\r\n              // Don't conflict with Object.prototype properties (trac-13203)\r\n              sel = handleObj.selector + ' ';\r\n\r\n              if (matchedSelectors[sel] === undefined) {\r\n                matchedSelectors[sel] = handleObj.needsContext\r\n                  ? jQuery(sel, this).index(cur) > -1\r\n                  : jQuery.find(sel, this, null, [cur]).length;\r\n              }\r\n              if (matchedSelectors[sel]) {\r\n                matchedHandlers.push(handleObj);\r\n              }\r\n            }\r\n            if (matchedHandlers.length) {\r\n              handlerQueue.push({ elem: cur, handlers: matchedHandlers });\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Add the remaining (directly-bound) handlers\r\n      cur = this;\r\n      if (delegateCount < handlers.length) {\r\n        handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });\r\n      }\r\n\r\n      return handlerQueue;\r\n    },\r\n\r\n    addProp: function (name, hook) {\r\n      Object.defineProperty(jQuery.Event.prototype, name, {\r\n        enumerable: true,\r\n        configurable: true,\r\n\r\n        get: isFunction(hook)\r\n          ? function () {\r\n              if (this.originalEvent) {\r\n                return hook(this.originalEvent);\r\n              }\r\n            }\r\n          : function () {\r\n              if (this.originalEvent) {\r\n                return this.originalEvent[name];\r\n              }\r\n            },\r\n\r\n        set: function (value) {\r\n          Object.defineProperty(this, name, {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: value,\r\n          });\r\n        },\r\n      });\r\n    },\r\n\r\n    fix: function (originalEvent) {\r\n      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);\r\n    },\r\n\r\n    special: {\r\n      load: {\r\n        // Prevent triggered image.load events from bubbling to window.load\r\n        noBubble: true,\r\n      },\r\n      click: {\r\n        // Utilize native event to ensure correct state for checkable inputs\r\n        setup: function (data) {\r\n          // For mutual compressibility with _default, replace `this` access with a local var.\r\n          // `|| data` is dead code meant only to preserve the variable through minification.\r\n          var el = this || data;\r\n\r\n          // Claim the first handler\r\n          if (rcheckableType.test(el.type) && el.click && nodeName(el, 'input')) {\r\n            // dataPriv.set( el, \"click\", ... )\r\n            leverageNative(el, 'click', returnTrue);\r\n          }\r\n\r\n          // Return false to allow normal processing in the caller\r\n          return false;\r\n        },\r\n        trigger: function (data) {\r\n          // For mutual compressibility with _default, replace `this` access with a local var.\r\n          // `|| data` is dead code meant only to preserve the variable through minification.\r\n          var el = this || data;\r\n\r\n          // Force setup before triggering a click\r\n          if (rcheckableType.test(el.type) && el.click && nodeName(el, 'input')) {\r\n            leverageNative(el, 'click');\r\n          }\r\n\r\n          // Return non-false to allow normal event-path propagation\r\n          return true;\r\n        },\r\n\r\n        // For cross-browser consistency, suppress native .click() on links\r\n        // Also prevent it if we're currently inside a leveraged native-event stack\r\n        _default: function (event) {\r\n          var target = event.target;\r\n          return (\r\n            (rcheckableType.test(target.type) &&\r\n              target.click &&\r\n              nodeName(target, 'input') &&\r\n              dataPriv.get(target, 'click')) ||\r\n            nodeName(target, 'a')\r\n          );\r\n        },\r\n      },\r\n\r\n      beforeunload: {\r\n        postDispatch: function (event) {\r\n          // Support: Firefox 20+\r\n          // Firefox doesn't alert if the returnValue field is not set.\r\n          if (event.result !== undefined && event.originalEvent) {\r\n            event.originalEvent.returnValue = event.result;\r\n          }\r\n        },\r\n      },\r\n    },\r\n  };\r\n\r\n  // Ensure the presence of an event listener that handles manually-triggered\r\n  // synthetic events by interrupting progress until reinvoked in response to\r\n  // *native* events that it fires directly, ensuring that state changes have\r\n  // already occurred before other listeners are invoked.\r\n  function leverageNative(el, type, expectSync) {\r\n    // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\r\n    if (!expectSync) {\r\n      if (dataPriv.get(el, type) === undefined) {\r\n        jQuery.event.add(el, type, returnTrue);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Register the controller as a special universal handler for all event namespaces\r\n    dataPriv.set(el, type, false);\r\n    jQuery.event.add(el, type, {\r\n      namespace: false,\r\n      handler: function (event) {\r\n        var notAsync,\r\n          result,\r\n          saved = dataPriv.get(this, type);\r\n\r\n        if (event.isTrigger & 1 && this[type]) {\r\n          // Interrupt processing of the outer synthetic .trigger()ed event\r\n          // Saved data should be false in such cases, but might be a leftover capture object\r\n          // from an async native handler (gh-4350)\r\n          if (!saved.length) {\r\n            // Store arguments for use when handling the inner native event\r\n            // There will always be at least one argument (an event object), so this array\r\n            // will not be confused with a leftover capture object.\r\n            saved = slice.call(arguments);\r\n            dataPriv.set(this, type, saved);\r\n\r\n            // Trigger the native event and capture its result\r\n            // Support: IE <=9 - 11+\r\n            // focus() and blur() are asynchronous\r\n            notAsync = expectSync(this, type);\r\n            this[type]();\r\n            result = dataPriv.get(this, type);\r\n            if (saved !== result || notAsync) {\r\n              dataPriv.set(this, type, false);\r\n            } else {\r\n              result = {};\r\n            }\r\n            if (saved !== result) {\r\n              // Cancel the outer synthetic event\r\n              event.stopImmediatePropagation();\r\n              event.preventDefault();\r\n\r\n              // Support: Chrome 86+\r\n              // In Chrome, if an element having a focusout handler is blurred by\r\n              // clicking outside of it, it invokes the handler synchronously. If\r\n              // that handler calls `.remove()` on the element, the data is cleared,\r\n              // leaving `result` undefined. We need to guard against this.\r\n              return result && result.value;\r\n            }\r\n\r\n            // If this is an inner synthetic event for an event with a bubbling surrogate\r\n            // (focus or blur), assume that the surrogate already propagated from triggering the\r\n            // native event and prevent that from happening again here.\r\n            // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\r\n            // bubbling surrogate propagates *after* the non-bubbling base), but that seems\r\n            // less bad than duplication.\r\n          } else if ((jQuery.event.special[type] || {}).delegateType) {\r\n            event.stopPropagation();\r\n          }\r\n\r\n          // If this is a native event triggered above, everything is now in order\r\n          // Fire an inner synthetic event with the original arguments\r\n        } else if (saved.length) {\r\n          // ...and capture the result\r\n          dataPriv.set(this, type, {\r\n            value: jQuery.event.trigger(\r\n              // Support: IE <=9 - 11+\r\n              // Extend with the prototype to reset the above stopImmediatePropagation()\r\n              jQuery.extend(saved[0], jQuery.Event.prototype),\r\n              saved.slice(1),\r\n              this,\r\n            ),\r\n          });\r\n\r\n          // Abort handling of the native event\r\n          event.stopImmediatePropagation();\r\n        }\r\n      },\r\n    });\r\n  }\r\n\r\n  jQuery.removeEvent = function (elem, type, handle) {\r\n    // This \"if\" is needed for plain objects\r\n    if (elem.removeEventListener) {\r\n      elem.removeEventListener(type, handle);\r\n    }\r\n  };\r\n\r\n  jQuery.Event = function (src, props) {\r\n    // Allow instantiation without the 'new' keyword\r\n    if (!(this instanceof jQuery.Event)) {\r\n      return new jQuery.Event(src, props);\r\n    }\r\n\r\n    // Event object\r\n    if (src && src.type) {\r\n      this.originalEvent = src;\r\n      this.type = src.type;\r\n\r\n      // Events bubbling up the document may have been marked as prevented\r\n      // by a handler lower down the tree; reflect the correct value.\r\n      this.isDefaultPrevented =\r\n        src.defaultPrevented ||\r\n        (src.defaultPrevented === undefined &&\r\n          // Support: Android <=2.3 only\r\n          src.returnValue === false)\r\n          ? returnTrue\r\n          : returnFalse;\r\n\r\n      // Create target properties\r\n      // Support: Safari <=6 - 7 only\r\n      // Target should not be a text node (trac-504, trac-13143)\r\n      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;\r\n\r\n      this.currentTarget = src.currentTarget;\r\n      this.relatedTarget = src.relatedTarget;\r\n\r\n      // Event type\r\n    } else {\r\n      this.type = src;\r\n    }\r\n\r\n    // Put explicitly provided properties onto the event object\r\n    if (props) {\r\n      jQuery.extend(this, props);\r\n    }\r\n\r\n    // Create a timestamp if incoming event doesn't have one\r\n    this.timeStamp = (src && src.timeStamp) || Date.now();\r\n\r\n    // Mark it as fixed\r\n    this[jQuery.expando] = true;\r\n  };\r\n\r\n  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\r\n  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\r\n  jQuery.Event.prototype = {\r\n    constructor: jQuery.Event,\r\n    isDefaultPrevented: returnFalse,\r\n    isPropagationStopped: returnFalse,\r\n    isImmediatePropagationStopped: returnFalse,\r\n    isSimulated: false,\r\n\r\n    preventDefault: function () {\r\n      var e = this.originalEvent;\r\n\r\n      this.isDefaultPrevented = returnTrue;\r\n\r\n      if (e && !this.isSimulated) {\r\n        e.preventDefault();\r\n      }\r\n    },\r\n    stopPropagation: function () {\r\n      var e = this.originalEvent;\r\n\r\n      this.isPropagationStopped = returnTrue;\r\n\r\n      if (e && !this.isSimulated) {\r\n        e.stopPropagation();\r\n      }\r\n    },\r\n    stopImmediatePropagation: function () {\r\n      var e = this.originalEvent;\r\n\r\n      this.isImmediatePropagationStopped = returnTrue;\r\n\r\n      if (e && !this.isSimulated) {\r\n        e.stopImmediatePropagation();\r\n      }\r\n\r\n      this.stopPropagation();\r\n    },\r\n  };\r\n\r\n  // Includes all common event props including KeyEvent and MouseEvent specific props\r\n  jQuery.each(\r\n    {\r\n      altKey: true,\r\n      bubbles: true,\r\n      cancelable: true,\r\n      changedTouches: true,\r\n      ctrlKey: true,\r\n      detail: true,\r\n      eventPhase: true,\r\n      metaKey: true,\r\n      pageX: true,\r\n      pageY: true,\r\n      shiftKey: true,\r\n      view: true,\r\n      char: true,\r\n      code: true,\r\n      charCode: true,\r\n      key: true,\r\n      keyCode: true,\r\n      button: true,\r\n      buttons: true,\r\n      clientX: true,\r\n      clientY: true,\r\n      offsetX: true,\r\n      offsetY: true,\r\n      pointerId: true,\r\n      pointerType: true,\r\n      screenX: true,\r\n      screenY: true,\r\n      targetTouches: true,\r\n      toElement: true,\r\n      touches: true,\r\n      which: true,\r\n    },\r\n    jQuery.event.addProp,\r\n  );\r\n\r\n  jQuery.each({ focus: 'focusin', blur: 'focusout' }, function (type, delegateType) {\r\n    jQuery.event.special[type] = {\r\n      // Utilize native event if possible so blur/focus sequence is correct\r\n      setup: function () {\r\n        // Claim the first handler\r\n        // dataPriv.set( this, \"focus\", ... )\r\n        // dataPriv.set( this, \"blur\", ... )\r\n        leverageNative(this, type, expectSync);\r\n\r\n        // Return false to allow normal processing in the caller\r\n        return false;\r\n      },\r\n      trigger: function () {\r\n        // Force setup before trigger\r\n        leverageNative(this, type);\r\n\r\n        // Return non-false to allow normal event-path propagation\r\n        return true;\r\n      },\r\n\r\n      // Suppress native focus or blur if we're currently inside\r\n      // a leveraged native-event stack\r\n      _default: function (event) {\r\n        return dataPriv.get(event.target, type);\r\n      },\r\n\r\n      delegateType: delegateType,\r\n    };\r\n  });\r\n\r\n  // Create mouseenter/leave events using mouseover/out and event-time checks\r\n  // so that event delegation works in jQuery.\r\n  // Do the same for pointerenter/pointerleave and pointerover/pointerout\r\n  //\r\n  // Support: Safari 7 only\r\n  // Safari sends mouseenter too often; see:\r\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258\r\n  // for the description of the bug (it existed in older Chrome versions as well).\r\n  jQuery.each(\r\n    {\r\n      mouseenter: 'mouseover',\r\n      mouseleave: 'mouseout',\r\n      pointerenter: 'pointerover',\r\n      pointerleave: 'pointerout',\r\n    },\r\n    function (orig, fix) {\r\n      jQuery.event.special[orig] = {\r\n        delegateType: fix,\r\n        bindType: fix,\r\n\r\n        handle: function (event) {\r\n          var ret,\r\n            target = this,\r\n            related = event.relatedTarget,\r\n            handleObj = event.handleObj;\r\n\r\n          // For mouseenter/leave call the handler if related is outside the target.\r\n          // NB: No relatedTarget if the mouse left/entered the browser window\r\n          if (!related || (related !== target && !jQuery.contains(target, related))) {\r\n            event.type = handleObj.origType;\r\n            ret = handleObj.handler.apply(this, arguments);\r\n            event.type = fix;\r\n          }\r\n          return ret;\r\n        },\r\n      };\r\n    },\r\n  );\r\n\r\n  jQuery.fn.extend({\r\n    on: function (types, selector, data, fn) {\r\n      return on(this, types, selector, data, fn);\r\n    },\r\n    one: function (types, selector, data, fn) {\r\n      return on(this, types, selector, data, fn, 1);\r\n    },\r\n    off: function (types, selector, fn) {\r\n      var handleObj, type;\r\n      if (types && types.preventDefault && types.handleObj) {\r\n        // ( event )  dispatched jQuery.Event\r\n        handleObj = types.handleObj;\r\n        jQuery(types.delegateTarget).off(\r\n          handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType,\r\n          handleObj.selector,\r\n          handleObj.handler,\r\n        );\r\n        return this;\r\n      }\r\n      if (typeof types === 'object') {\r\n        // ( types-object [, selector] )\r\n        for (type in types) {\r\n          this.off(type, selector, types[type]);\r\n        }\r\n        return this;\r\n      }\r\n      if (selector === false || typeof selector === 'function') {\r\n        // ( types [, fn] )\r\n        fn = selector;\r\n        selector = undefined;\r\n      }\r\n      if (fn === false) {\r\n        fn = returnFalse;\r\n      }\r\n      return this.each(function () {\r\n        jQuery.event.remove(this, types, fn, selector);\r\n      });\r\n    },\r\n  });\r\n\r\n  var // Support: IE <=10 - 11, Edge 12 - 13 only\r\n    // In IE/Edge using regex groups here causes severe slowdowns.\r\n    // See https://connect.microsoft.com/IE/feedback/details/1736512/\r\n    rnoInnerhtml = /<script|<style|<link/i,\r\n    // checked=\"checked\" or checked\r\n    rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\r\n    rcleanScript = /^\\s*<!\\[CDATA\\[|\\]\\]>\\s*$/g;\r\n\r\n  // Prefer a tbody over its parent table for containing new rows\r\n  function manipulationTarget(elem, content) {\r\n    if (\r\n      nodeName(elem, 'table') &&\r\n      nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr')\r\n    ) {\r\n      return jQuery(elem).children('tbody')[0] || elem;\r\n    }\r\n\r\n    return elem;\r\n  }\r\n\r\n  // Replace/restore the type attribute of script elements for safe DOM manipulation\r\n  function disableScript(elem) {\r\n    elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;\r\n    return elem;\r\n  }\r\n  function restoreScript(elem) {\r\n    if ((elem.type || '').slice(0, 5) === 'true/') {\r\n      elem.type = elem.type.slice(5);\r\n    } else {\r\n      elem.removeAttribute('type');\r\n    }\r\n\r\n    return elem;\r\n  }\r\n\r\n  function cloneCopyEvent(src, dest) {\r\n    var i, l, type, pdataOld, udataOld, udataCur, events;\r\n\r\n    if (dest.nodeType !== 1) {\r\n      return;\r\n    }\r\n\r\n    // 1. Copy private data: events, handlers, etc.\r\n    if (dataPriv.hasData(src)) {\r\n      pdataOld = dataPriv.get(src);\r\n      events = pdataOld.events;\r\n\r\n      if (events) {\r\n        dataPriv.remove(dest, 'handle events');\r\n\r\n        for (type in events) {\r\n          for (i = 0, l = events[type].length; i < l; i++) {\r\n            jQuery.event.add(dest, type, events[type][i]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // 2. Copy user data\r\n    if (dataUser.hasData(src)) {\r\n      udataOld = dataUser.access(src);\r\n      udataCur = jQuery.extend({}, udataOld);\r\n\r\n      dataUser.set(dest, udataCur);\r\n    }\r\n  }\r\n\r\n  // Fix IE bugs, see support tests\r\n  function fixInput(src, dest) {\r\n    var nodeName = dest.nodeName.toLowerCase();\r\n\r\n    // Fails to persist the checked state of a cloned checkbox or radio button.\r\n    if (nodeName === 'input' && rcheckableType.test(src.type)) {\r\n      dest.checked = src.checked;\r\n\r\n      // Fails to return the selected option to the default selected state when cloning options\r\n    } else if (nodeName === 'input' || nodeName === 'textarea') {\r\n      dest.defaultValue = src.defaultValue;\r\n    }\r\n  }\r\n\r\n  function domManip(collection, args, callback, ignored) {\r\n    // Flatten any nested arrays\r\n    args = flat(args);\r\n\r\n    var fragment,\r\n      first,\r\n      scripts,\r\n      hasScripts,\r\n      node,\r\n      doc,\r\n      i = 0,\r\n      l = collection.length,\r\n      iNoClone = l - 1,\r\n      value = args[0],\r\n      valueIsFunction = isFunction(value);\r\n\r\n    // We can't cloneNode fragments that contain checked, in WebKit\r\n    if (\r\n      valueIsFunction ||\r\n      (l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value))\r\n    ) {\r\n      return collection.each(function (index) {\r\n        var self = collection.eq(index);\r\n        if (valueIsFunction) {\r\n          args[0] = value.call(this, index, self.html());\r\n        }\r\n        domManip(self, args, callback, ignored);\r\n      });\r\n    }\r\n\r\n    if (l) {\r\n      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);\r\n      first = fragment.firstChild;\r\n\r\n      if (fragment.childNodes.length === 1) {\r\n        fragment = first;\r\n      }\r\n\r\n      // Require either new content or an interest in ignored elements to invoke the callback\r\n      if (first || ignored) {\r\n        scripts = jQuery.map(getAll(fragment, 'script'), disableScript);\r\n        hasScripts = scripts.length;\r\n\r\n        // Use the original fragment for the last item\r\n        // instead of the first because it can end up\r\n        // being emptied incorrectly in certain situations (trac-8070).\r\n        for (; i < l; i++) {\r\n          node = fragment;\r\n\r\n          if (i !== iNoClone) {\r\n            node = jQuery.clone(node, true, true);\r\n\r\n            // Keep references to cloned scripts for later restoration\r\n            if (hasScripts) {\r\n              // Support: Android <=4.0 only, PhantomJS 1 only\r\n              // push.apply(_, arraylike) throws on ancient WebKit\r\n              jQuery.merge(scripts, getAll(node, 'script'));\r\n            }\r\n          }\r\n\r\n          callback.call(collection[i], node, i);\r\n        }\r\n\r\n        if (hasScripts) {\r\n          doc = scripts[scripts.length - 1].ownerDocument;\r\n\r\n          // Reenable scripts\r\n          jQuery.map(scripts, restoreScript);\r\n\r\n          // Evaluate executable scripts on first document insertion\r\n          for (i = 0; i < hasScripts; i++) {\r\n            node = scripts[i];\r\n            if (\r\n              rscriptType.test(node.type || '') &&\r\n              !dataPriv.access(node, 'globalEval') &&\r\n              jQuery.contains(doc, node)\r\n            ) {\r\n              if (node.src && (node.type || '').toLowerCase() !== 'module') {\r\n                // Optional AJAX dependency, but won't run scripts if not present\r\n                if (jQuery._evalUrl && !node.noModule) {\r\n                  jQuery._evalUrl(\r\n                    node.src,\r\n                    {\r\n                      nonce: node.nonce || node.getAttribute('nonce'),\r\n                    },\r\n                    doc,\r\n                  );\r\n                }\r\n              } else {\r\n                // Unwrap a CDATA section containing script contents. This shouldn't be\r\n                // needed as in XML documents they're already not visible when\r\n                // inspecting element contents and in HTML documents they have no\r\n                // meaning but we're preserving that logic for backwards compatibility.\r\n                // This will be removed completely in 4.0. See gh-4904.\r\n                DOMEval(node.textContent.replace(rcleanScript, ''), node, doc);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return collection;\r\n  }\r\n\r\n  function remove(elem, selector, keepData) {\r\n    var node,\r\n      nodes = selector ? jQuery.filter(selector, elem) : elem,\r\n      i = 0;\r\n\r\n    for (; (node = nodes[i]) != null; i++) {\r\n      if (!keepData && node.nodeType === 1) {\r\n        jQuery.cleanData(getAll(node));\r\n      }\r\n\r\n      if (node.parentNode) {\r\n        if (keepData && isAttached(node)) {\r\n          setGlobalEval(getAll(node, 'script'));\r\n        }\r\n        node.parentNode.removeChild(node);\r\n      }\r\n    }\r\n\r\n    return elem;\r\n  }\r\n\r\n  jQuery.extend({\r\n    htmlPrefilter: function (html) {\r\n      return html;\r\n    },\r\n\r\n    clone: function (elem, dataAndEvents, deepDataAndEvents) {\r\n      var i,\r\n        l,\r\n        srcElements,\r\n        destElements,\r\n        clone = elem.cloneNode(true),\r\n        inPage = isAttached(elem);\r\n\r\n      // Fix IE cloning issues\r\n      if (\r\n        !support.noCloneChecked &&\r\n        (elem.nodeType === 1 || elem.nodeType === 11) &&\r\n        !jQuery.isXMLDoc(elem)\r\n      ) {\r\n        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\r\n        destElements = getAll(clone);\r\n        srcElements = getAll(elem);\r\n\r\n        for (i = 0, l = srcElements.length; i < l; i++) {\r\n          fixInput(srcElements[i], destElements[i]);\r\n        }\r\n      }\r\n\r\n      // Copy the events from the original to the clone\r\n      if (dataAndEvents) {\r\n        if (deepDataAndEvents) {\r\n          srcElements = srcElements || getAll(elem);\r\n          destElements = destElements || getAll(clone);\r\n\r\n          for (i = 0, l = srcElements.length; i < l; i++) {\r\n            cloneCopyEvent(srcElements[i], destElements[i]);\r\n          }\r\n        } else {\r\n          cloneCopyEvent(elem, clone);\r\n        }\r\n      }\r\n\r\n      // Preserve script evaluation history\r\n      destElements = getAll(clone, 'script');\r\n      if (destElements.length > 0) {\r\n        setGlobalEval(destElements, !inPage && getAll(elem, 'script'));\r\n      }\r\n\r\n      // Return the cloned set\r\n      return clone;\r\n    },\r\n\r\n    cleanData: function (elems) {\r\n      var data,\r\n        elem,\r\n        type,\r\n        special = jQuery.event.special,\r\n        i = 0;\r\n\r\n      for (; (elem = elems[i]) !== undefined; i++) {\r\n        if (acceptData(elem)) {\r\n          if ((data = elem[dataPriv.expando])) {\r\n            if (data.events) {\r\n              for (type in data.events) {\r\n                if (special[type]) {\r\n                  jQuery.event.remove(elem, type);\r\n\r\n                  // This is a shortcut to avoid jQuery.event.remove's overhead\r\n                } else {\r\n                  jQuery.removeEvent(elem, type, data.handle);\r\n                }\r\n              }\r\n            }\r\n\r\n            // Support: Chrome <=35 - 45+\r\n            // Assign undefined instead of using delete, see Data#remove\r\n            elem[dataPriv.expando] = undefined;\r\n          }\r\n          if (elem[dataUser.expando]) {\r\n            // Support: Chrome <=35 - 45+\r\n            // Assign undefined instead of using delete, see Data#remove\r\n            elem[dataUser.expando] = undefined;\r\n          }\r\n        }\r\n      }\r\n    },\r\n  });\r\n\r\n  jQuery.fn.extend({\r\n    detach: function (selector) {\r\n      return remove(this, selector, true);\r\n    },\r\n\r\n    remove: function (selector) {\r\n      return remove(this, selector);\r\n    },\r\n\r\n    text: function (value) {\r\n      return access(\r\n        this,\r\n        function (value) {\r\n          return value === undefined\r\n            ? jQuery.text(this)\r\n            : this.empty().each(function () {\r\n                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\r\n                  this.textContent = value;\r\n                }\r\n              });\r\n        },\r\n        null,\r\n        value,\r\n        arguments.length,\r\n      );\r\n    },\r\n\r\n    append: function () {\r\n      return domManip(this, arguments, function (elem) {\r\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\r\n          var target = manipulationTarget(this, elem);\r\n          target.appendChild(elem);\r\n        }\r\n      });\r\n    },\r\n\r\n    prepend: function () {\r\n      return domManip(this, arguments, function (elem) {\r\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\r\n          var target = manipulationTarget(this, elem);\r\n          target.insertBefore(elem, target.firstChild);\r\n        }\r\n      });\r\n    },\r\n\r\n    before: function () {\r\n      return domManip(this, arguments, function (elem) {\r\n        if (this.parentNode) {\r\n          this.parentNode.insertBefore(elem, this);\r\n        }\r\n      });\r\n    },\r\n\r\n    after: function () {\r\n      return domManip(this, arguments, function (elem) {\r\n        if (this.parentNode) {\r\n          this.parentNode.insertBefore(elem, this.nextSibling);\r\n        }\r\n      });\r\n    },\r\n\r\n    empty: function () {\r\n      var elem,\r\n        i = 0;\r\n\r\n      for (; (elem = this[i]) != null; i++) {\r\n        if (elem.nodeType === 1) {\r\n          // Prevent memory leaks\r\n          jQuery.cleanData(getAll(elem, false));\r\n\r\n          // Remove any remaining nodes\r\n          elem.textContent = '';\r\n        }\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    clone: function (dataAndEvents, deepDataAndEvents) {\r\n      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\r\n      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\r\n\r\n      return this.map(function () {\r\n        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\r\n      });\r\n    },\r\n\r\n    html: function (value) {\r\n      return access(\r\n        this,\r\n        function (value) {\r\n          var elem = this[0] || {},\r\n            i = 0,\r\n            l = this.length;\r\n\r\n          if (value === undefined && elem.nodeType === 1) {\r\n            return elem.innerHTML;\r\n          }\r\n\r\n          // See if we can take a shortcut and just use innerHTML\r\n          if (\r\n            typeof value === 'string' &&\r\n            !rnoInnerhtml.test(value) &&\r\n            !wrapMap[(rtagName.exec(value) || ['', ''])[1].toLowerCase()]\r\n          ) {\r\n            value = jQuery.htmlPrefilter(value);\r\n\r\n            try {\r\n              for (; i < l; i++) {\r\n                elem = this[i] || {};\r\n\r\n                // Remove element nodes and prevent memory leaks\r\n                if (elem.nodeType === 1) {\r\n                  jQuery.cleanData(getAll(elem, false));\r\n                  elem.innerHTML = value;\r\n                }\r\n              }\r\n\r\n              elem = 0;\r\n\r\n              // If using innerHTML throws an exception, use the fallback method\r\n            } catch (e) {}\r\n          }\r\n\r\n          if (elem) {\r\n            this.empty().append(value);\r\n          }\r\n        },\r\n        null,\r\n        value,\r\n        arguments.length,\r\n      );\r\n    },\r\n\r\n    replaceWith: function () {\r\n      var ignored = [];\r\n\r\n      // Make the changes, replacing each non-ignored context element with the new content\r\n      return domManip(\r\n        this,\r\n        arguments,\r\n        function (elem) {\r\n          var parent = this.parentNode;\r\n\r\n          if (jQuery.inArray(this, ignored) < 0) {\r\n            jQuery.cleanData(getAll(this));\r\n            if (parent) {\r\n              parent.replaceChild(elem, this);\r\n            }\r\n          }\r\n\r\n          // Force callback invocation\r\n        },\r\n        ignored,\r\n      );\r\n    },\r\n  });\r\n\r\n  jQuery.each(\r\n    {\r\n      appendTo: 'append',\r\n      prependTo: 'prepend',\r\n      insertBefore: 'before',\r\n      insertAfter: 'after',\r\n      replaceAll: 'replaceWith',\r\n    },\r\n    function (name, original) {\r\n      jQuery.fn[name] = function (selector) {\r\n        var elems,\r\n          ret = [],\r\n          insert = jQuery(selector),\r\n          last = insert.length - 1,\r\n          i = 0;\r\n\r\n        for (; i <= last; i++) {\r\n          elems = i === last ? this : this.clone(true);\r\n          jQuery(insert[i])[original](elems);\r\n\r\n          // Support: Android <=4.0 only, PhantomJS 1 only\r\n          // .get() because push.apply(_, arraylike) throws on ancient WebKit\r\n          push.apply(ret, elems.get());\r\n        }\r\n\r\n        return this.pushStack(ret);\r\n      };\r\n    },\r\n  );\r\n  var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');\r\n\r\n  var rcustomProp = /^--/;\r\n\r\n  var getStyles = function (elem) {\r\n    // Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)\r\n    // IE throws on elements created in popups\r\n    // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\r\n    var view = elem.ownerDocument.defaultView;\r\n\r\n    if (!view || !view.opener) {\r\n      view = window;\r\n    }\r\n\r\n    return view.getComputedStyle(elem);\r\n  };\r\n\r\n  var swap = function (elem, options, callback) {\r\n    var ret,\r\n      name,\r\n      old = {};\r\n\r\n    // Remember the old values, and insert the new ones\r\n    for (name in options) {\r\n      old[name] = elem.style[name];\r\n      elem.style[name] = options[name];\r\n    }\r\n\r\n    ret = callback.call(elem);\r\n\r\n    // Revert the old values\r\n    for (name in options) {\r\n      elem.style[name] = old[name];\r\n    }\r\n\r\n    return ret;\r\n  };\r\n\r\n  var rboxStyle = new RegExp(cssExpand.join('|'), 'i');\r\n\r\n  var whitespace = '[\\\\x20\\\\t\\\\r\\\\n\\\\f]';\r\n\r\n  var rtrimCSS = new RegExp(\r\n    '^' + whitespace + '+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)' + whitespace + '+$',\r\n    'g',\r\n  );\r\n\r\n  (function () {\r\n    // Executing both pixelPosition & boxSizingReliable tests require only one layout\r\n    // so they're executed at the same time to save the second computation.\r\n    function computeStyleTests() {\r\n      // This is a singleton, we need to execute it only once\r\n      if (!div) {\r\n        return;\r\n      }\r\n\r\n      container.style.cssText =\r\n        'position:absolute;left:-11111px;width:60px;' + 'margin-top:1px;padding:0;border:0';\r\n      div.style.cssText =\r\n        'position:relative;display:block;box-sizing:border-box;overflow:scroll;' +\r\n        'margin:auto;border:1px;padding:1px;' +\r\n        'width:60%;top:1%';\r\n      documentElement.appendChild(container).appendChild(div);\r\n\r\n      var divStyle = window.getComputedStyle(div);\r\n      pixelPositionVal = divStyle.top !== '1%';\r\n\r\n      // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\r\n      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;\r\n\r\n      // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\r\n      // Some styles come back with percentage values, even though they shouldn't\r\n      div.style.right = '60%';\r\n      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;\r\n\r\n      // Support: IE 9 - 11 only\r\n      // Detect misreporting of content dimensions for box-sizing:border-box elements\r\n      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;\r\n\r\n      // Support: IE 9 only\r\n      // Detect overflow:scroll screwiness (gh-3699)\r\n      // Support: Chrome <=64\r\n      // Don't get tricked when zoom affects offsetWidth (gh-4029)\r\n      div.style.position = 'absolute';\r\n      scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;\r\n\r\n      documentElement.removeChild(container);\r\n\r\n      // Nullify the div so it wouldn't be stored in the memory and\r\n      // it will also be a sign that checks already performed\r\n      div = null;\r\n    }\r\n\r\n    function roundPixelMeasures(measure) {\r\n      return Math.round(parseFloat(measure));\r\n    }\r\n\r\n    var pixelPositionVal,\r\n      boxSizingReliableVal,\r\n      scrollboxSizeVal,\r\n      pixelBoxStylesVal,\r\n      reliableTrDimensionsVal,\r\n      reliableMarginLeftVal,\r\n      container = document.createElement('div'),\r\n      div = document.createElement('div');\r\n\r\n    // Finish early in limited (non-browser) environments\r\n    if (!div.style) {\r\n      return;\r\n    }\r\n\r\n    // Support: IE <=9 - 11 only\r\n    // Style of cloned element affects source element cloned (trac-8908)\r\n    div.style.backgroundClip = 'content-box';\r\n    div.cloneNode(true).style.backgroundClip = '';\r\n    support.clearCloneStyle = div.style.backgroundClip === 'content-box';\r\n\r\n    jQuery.extend(support, {\r\n      boxSizingReliable: function () {\r\n        computeStyleTests();\r\n        return boxSizingReliableVal;\r\n      },\r\n      pixelBoxStyles: function () {\r\n        computeStyleTests();\r\n        return pixelBoxStylesVal;\r\n      },\r\n      pixelPosition: function () {\r\n        computeStyleTests();\r\n        return pixelPositionVal;\r\n      },\r\n      reliableMarginLeft: function () {\r\n        computeStyleTests();\r\n        return reliableMarginLeftVal;\r\n      },\r\n      scrollboxSize: function () {\r\n        computeStyleTests();\r\n        return scrollboxSizeVal;\r\n      },\r\n\r\n      // Support: IE 9 - 11+, Edge 15 - 18+\r\n      // IE/Edge misreport `getComputedStyle` of table rows with width/height\r\n      // set in CSS while `offset*` properties report correct values.\r\n      // Behavior in IE 9 is more subtle than in newer versions & it passes\r\n      // some versions of this test; make sure not to make it pass there!\r\n      //\r\n      // Support: Firefox 70+\r\n      // Only Firefox includes border widths\r\n      // in computed dimensions. (gh-4529)\r\n      reliableTrDimensions: function () {\r\n        var table, tr, trChild, trStyle;\r\n        if (reliableTrDimensionsVal == null) {\r\n          table = document.createElement('table');\r\n          tr = document.createElement('tr');\r\n          trChild = document.createElement('div');\r\n\r\n          table.style.cssText = 'position:absolute;left:-11111px;border-collapse:separate';\r\n          tr.style.cssText = 'border:1px solid';\r\n\r\n          // Support: Chrome 86+\r\n          // Height set through cssText does not get applied.\r\n          // Computed height then comes back as 0.\r\n          tr.style.height = '1px';\r\n          trChild.style.height = '9px';\r\n\r\n          // Support: Android 8 Chrome 86+\r\n          // In our bodyBackground.html iframe,\r\n          // display for all div elements is set to \"inline\",\r\n          // which causes a problem only in Android 8 Chrome 86.\r\n          // Ensuring the div is display: block\r\n          // gets around this issue.\r\n          trChild.style.display = 'block';\r\n\r\n          documentElement.appendChild(table).appendChild(tr).appendChild(trChild);\r\n\r\n          trStyle = window.getComputedStyle(tr);\r\n          reliableTrDimensionsVal =\r\n            parseInt(trStyle.height, 10) +\r\n              parseInt(trStyle.borderTopWidth, 10) +\r\n              parseInt(trStyle.borderBottomWidth, 10) ===\r\n            tr.offsetHeight;\r\n\r\n          documentElement.removeChild(table);\r\n        }\r\n        return reliableTrDimensionsVal;\r\n      },\r\n    });\r\n  })();\r\n\r\n  function curCSS(elem, name, computed) {\r\n    var width,\r\n      minWidth,\r\n      maxWidth,\r\n      ret,\r\n      isCustomProp = rcustomProp.test(name),\r\n      // Support: Firefox 51+\r\n      // Retrieving style before computed somehow\r\n      // fixes an issue with getting wrong values\r\n      // on detached elements\r\n      style = elem.style;\r\n\r\n    computed = computed || getStyles(elem);\r\n\r\n    // getPropertyValue is needed for:\r\n    //   .css('filter') (IE 9 only, trac-12537)\r\n    //   .css('--customProperty) (gh-3144)\r\n    if (computed) {\r\n      // Support: IE <=9 - 11+\r\n      // IE only supports `\"float\"` in `getPropertyValue`; in computed styles\r\n      // it's only available as `\"cssFloat\"`. We no longer modify properties\r\n      // sent to `.css()` apart from camelCasing, so we need to check both.\r\n      // Normally, this would create difference in behavior: if\r\n      // `getPropertyValue` returns an empty string, the value returned\r\n      // by `.css()` would be `undefined`. This is usually the case for\r\n      // disconnected elements. However, in IE even disconnected elements\r\n      // with no styles return `\"none\"` for `getPropertyValue( \"float\" )`\r\n      ret = computed.getPropertyValue(name) || computed[name];\r\n\r\n      if (isCustomProp && ret) {\r\n        // Support: Firefox 105+, Chrome <=105+\r\n        // Spec requires trimming whitespace for custom properties (gh-4926).\r\n        // Firefox only trims leading whitespace. Chrome just collapses\r\n        // both leading & trailing whitespace to a single space.\r\n        //\r\n        // Fall back to `undefined` if empty string returned.\r\n        // This collapses a missing definition with property defined\r\n        // and set to an empty string but there's no standard API\r\n        // allowing us to differentiate them without a performance penalty\r\n        // and returning `undefined` aligns with older jQuery.\r\n        //\r\n        // rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED\r\n        // as whitespace while CSS does not, but this is not a problem\r\n        // because CSS preprocessing replaces them with U+000A LINE FEED\r\n        // (which *is* CSS whitespace)\r\n        // https://www.w3.org/TR/css-syntax-3/#input-preprocessing\r\n        ret = ret.replace(rtrimCSS, '$1') || undefined;\r\n      }\r\n\r\n      if (ret === '' && !isAttached(elem)) {\r\n        ret = jQuery.style(elem, name);\r\n      }\r\n\r\n      // A tribute to the \"awesome hack by Dean Edwards\"\r\n      // Android Browser returns percentage for some values,\r\n      // but width seems to be reliably pixels.\r\n      // This is against the CSSOM draft spec:\r\n      // https://drafts.csswg.org/cssom/#resolved-values\r\n      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {\r\n        // Remember the original values\r\n        width = style.width;\r\n        minWidth = style.minWidth;\r\n        maxWidth = style.maxWidth;\r\n\r\n        // Put in the new values to get a computed value out\r\n        style.minWidth = style.maxWidth = style.width = ret;\r\n        ret = computed.width;\r\n\r\n        // Revert the changed values\r\n        style.width = width;\r\n        style.minWidth = minWidth;\r\n        style.maxWidth = maxWidth;\r\n      }\r\n    }\r\n\r\n    return ret !== undefined\r\n      ? // Support: IE <=9 - 11 only\r\n        // IE returns zIndex value as an integer.\r\n        ret + ''\r\n      : ret;\r\n  }\r\n\r\n  function addGetHookIf(conditionFn, hookFn) {\r\n    // Define the hook, we'll check on the first run if it's really needed.\r\n    return {\r\n      get: function () {\r\n        if (conditionFn()) {\r\n          // Hook not needed (or it's not possible to use it due\r\n          // to missing dependency), remove it.\r\n          delete this.get;\r\n          return;\r\n        }\r\n\r\n        // Hook needed; redefine it so that the support test is not executed again.\r\n        return (this.get = hookFn).apply(this, arguments);\r\n      },\r\n    };\r\n  }\r\n\r\n  var cssPrefixes = ['Webkit', 'Moz', 'ms'],\r\n    emptyStyle = document.createElement('div').style,\r\n    vendorProps = {};\r\n\r\n  // Return a vendor-prefixed property or undefined\r\n  function vendorPropName(name) {\r\n    // Check for vendor prefixed names\r\n    var capName = name[0].toUpperCase() + name.slice(1),\r\n      i = cssPrefixes.length;\r\n\r\n    while (i--) {\r\n      name = cssPrefixes[i] + capName;\r\n      if (name in emptyStyle) {\r\n        return name;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Return a potentially-mapped jQuery.cssProps or vendor prefixed property\r\n  function finalPropName(name) {\r\n    var final = jQuery.cssProps[name] || vendorProps[name];\r\n\r\n    if (final) {\r\n      return final;\r\n    }\r\n    if (name in emptyStyle) {\r\n      return name;\r\n    }\r\n    return (vendorProps[name] = vendorPropName(name) || name);\r\n  }\r\n\r\n  var // Swappable if display is none or starts with table\r\n    // except \"table\", \"table-cell\", or \"table-caption\"\r\n    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\r\n    rdisplayswap = /^(none|table(?!-c[ea]).+)/,\r\n    cssShow = { position: 'absolute', visibility: 'hidden', display: 'block' },\r\n    cssNormalTransform = {\r\n      letterSpacing: '0',\r\n      fontWeight: '400',\r\n    };\r\n\r\n  function setPositiveNumber(_elem, value, subtract) {\r\n    // Any relative (+/-) values have already been\r\n    // normalized at this point\r\n    var matches = rcssNum.exec(value);\r\n    return matches\r\n      ? // Guard against undefined \"subtract\", e.g., when used as in cssHooks\r\n        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || 'px')\r\n      : value;\r\n  }\r\n\r\n  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {\r\n    var i = dimension === 'width' ? 1 : 0,\r\n      extra = 0,\r\n      delta = 0;\r\n\r\n    // Adjustment may not be necessary\r\n    if (box === (isBorderBox ? 'border' : 'content')) {\r\n      return 0;\r\n    }\r\n\r\n    for (; i < 4; i += 2) {\r\n      // Both box models exclude margin\r\n      if (box === 'margin') {\r\n        delta += jQuery.css(elem, box + cssExpand[i], true, styles);\r\n      }\r\n\r\n      // If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\r\n      if (!isBorderBox) {\r\n        // Add padding\r\n        delta += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);\r\n\r\n        // For \"border\" or \"margin\", add border\r\n        if (box !== 'padding') {\r\n          delta += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);\r\n\r\n          // But still keep track of it otherwise\r\n        } else {\r\n          extra += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);\r\n        }\r\n\r\n        // If we get here with a border-box (content + padding + border), we're seeking \"content\" or\r\n        // \"padding\" or \"margin\"\r\n      } else {\r\n        // For \"content\", subtract padding\r\n        if (box === 'content') {\r\n          delta -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);\r\n        }\r\n\r\n        // For \"content\" or \"padding\", subtract border\r\n        if (box !== 'margin') {\r\n          delta -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Account for positive content-box scroll gutter when requested by providing computedVal\r\n    if (!isBorderBox && computedVal >= 0) {\r\n      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\r\n      // Assuming integer scroll gutter, subtract the rest and round down\r\n      delta +=\r\n        Math.max(\r\n          0,\r\n          Math.ceil(\r\n            elem['offset' + dimension[0].toUpperCase() + dimension.slice(1)] -\r\n              computedVal -\r\n              delta -\r\n              extra -\r\n              0.5,\r\n\r\n            // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter\r\n            // Use an explicit zero to avoid NaN (gh-3964)\r\n          ),\r\n        ) || 0;\r\n    }\r\n\r\n    return delta;\r\n  }\r\n\r\n  function getWidthOrHeight(elem, dimension, extra) {\r\n    // Start with computed style\r\n    var styles = getStyles(elem),\r\n      // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\r\n      // Fake content-box until we know it's needed to know the true value.\r\n      boxSizingNeeded = !support.boxSizingReliable() || extra,\r\n      isBorderBox =\r\n        boxSizingNeeded && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box',\r\n      valueIsBorderBox = isBorderBox,\r\n      val = curCSS(elem, dimension, styles),\r\n      offsetProp = 'offset' + dimension[0].toUpperCase() + dimension.slice(1);\r\n\r\n    // Support: Firefox <=54\r\n    // Return a confounding non-pixel value or feign ignorance, as appropriate.\r\n    if (rnumnonpx.test(val)) {\r\n      if (!extra) {\r\n        return val;\r\n      }\r\n      val = 'auto';\r\n    }\r\n\r\n    // Support: IE 9 - 11 only\r\n    // Use offsetWidth/offsetHeight for when box sizing is unreliable.\r\n    // In those cases, the computed value can be trusted to be border-box.\r\n    if (\r\n      ((!support.boxSizingReliable() && isBorderBox) ||\r\n        // Support: IE 10 - 11+, Edge 15 - 18+\r\n        // IE/Edge misreport `getComputedStyle` of table rows with width/height\r\n        // set in CSS while `offset*` properties report correct values.\r\n        // Interestingly, in some cases IE 9 doesn't suffer from this issue.\r\n        (!support.reliableTrDimensions() && nodeName(elem, 'tr')) ||\r\n        // Fall back to offsetWidth/offsetHeight when value is \"auto\"\r\n        // This happens for inline elements with no explicit setting (gh-3571)\r\n        val === 'auto' ||\r\n        // Support: Android <=4.1 - 4.3 only\r\n        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\r\n        (!parseFloat(val) && jQuery.css(elem, 'display', false, styles) === 'inline')) &&\r\n      // Make sure the element is visible & connected\r\n      elem.getClientRects().length\r\n    ) {\r\n      isBorderBox = jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';\r\n\r\n      // Where available, offsetWidth/offsetHeight approximate border box dimensions.\r\n      // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\r\n      // retrieved value as a content box dimension.\r\n      valueIsBorderBox = offsetProp in elem;\r\n      if (valueIsBorderBox) {\r\n        val = elem[offsetProp];\r\n      }\r\n    }\r\n\r\n    // Normalize \"\" and auto\r\n    val = parseFloat(val) || 0;\r\n\r\n    // Adjust for the element's box model\r\n    return (\r\n      val +\r\n      boxModelAdjustment(\r\n        elem,\r\n        dimension,\r\n        extra || (isBorderBox ? 'border' : 'content'),\r\n        valueIsBorderBox,\r\n        styles,\r\n\r\n        // Provide the current computed size to request scroll gutter calculation (gh-3589)\r\n        val,\r\n      ) +\r\n      'px'\r\n    );\r\n  }\r\n\r\n  jQuery.extend({\r\n    // Add in style property hooks for overriding the default\r\n    // behavior of getting and setting a style property\r\n    cssHooks: {\r\n      opacity: {\r\n        get: function (elem, computed) {\r\n          if (computed) {\r\n            // We should always get a number back from opacity\r\n            var ret = curCSS(elem, 'opacity');\r\n            return ret === '' ? '1' : ret;\r\n          }\r\n        },\r\n      },\r\n    },\r\n\r\n    // Don't automatically add \"px\" to these possibly-unitless properties\r\n    cssNumber: {\r\n      animationIterationCount: true,\r\n      columnCount: true,\r\n      fillOpacity: true,\r\n      flexGrow: true,\r\n      flexShrink: true,\r\n      fontWeight: true,\r\n      gridArea: true,\r\n      gridColumn: true,\r\n      gridColumnEnd: true,\r\n      gridColumnStart: true,\r\n      gridRow: true,\r\n      gridRowEnd: true,\r\n      gridRowStart: true,\r\n      lineHeight: true,\r\n      opacity: true,\r\n      order: true,\r\n      orphans: true,\r\n      widows: true,\r\n      zIndex: true,\r\n      zoom: true,\r\n    },\r\n\r\n    // Add in properties whose names you wish to fix before\r\n    // setting or getting the value\r\n    cssProps: {},\r\n\r\n    // Get and set the style property on a DOM Node\r\n    style: function (elem, name, value, extra) {\r\n      // Don't set styles on text and comment nodes\r\n      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\r\n        return;\r\n      }\r\n\r\n      // Make sure that we're working with the right name\r\n      var ret,\r\n        type,\r\n        hooks,\r\n        origName = camelCase(name),\r\n        isCustomProp = rcustomProp.test(name),\r\n        style = elem.style;\r\n\r\n      // Make sure that we're working with the right name. We don't\r\n      // want to query the value if it is a CSS custom property\r\n      // since they are user-defined.\r\n      if (!isCustomProp) {\r\n        name = finalPropName(origName);\r\n      }\r\n\r\n      // Gets hook for the prefixed version, then unprefixed version\r\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\r\n\r\n      // Check if we're setting a value\r\n      if (value !== undefined) {\r\n        type = typeof value;\r\n\r\n        // Convert \"+=\" or \"-=\" to relative numbers (trac-7345)\r\n        if (type === 'string' && (ret = rcssNum.exec(value)) && ret[1]) {\r\n          value = adjustCSS(elem, name, ret);\r\n\r\n          // Fixes bug trac-9237\r\n          type = 'number';\r\n        }\r\n\r\n        // Make sure that null and NaN values aren't set (trac-7116)\r\n        if (value == null || value !== value) {\r\n          return;\r\n        }\r\n\r\n        // If a number was passed in, add the unit (except for certain CSS properties)\r\n        // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\r\n        // \"px\" to a few hardcoded values.\r\n        if (type === 'number' && !isCustomProp) {\r\n          value += (ret && ret[3]) || (jQuery.cssNumber[origName] ? '' : 'px');\r\n        }\r\n\r\n        // background-* props affect original clone's values\r\n        if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {\r\n          style[name] = 'inherit';\r\n        }\r\n\r\n        // If a hook was provided, use that value, otherwise just set the specified value\r\n        if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\r\n          if (isCustomProp) {\r\n            style.setProperty(name, value);\r\n          } else {\r\n            style[name] = value;\r\n          }\r\n        }\r\n      } else {\r\n        // If a hook was provided get the non-computed value from there\r\n        if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\r\n          return ret;\r\n        }\r\n\r\n        // Otherwise just get the value from the style object\r\n        return style[name];\r\n      }\r\n    },\r\n\r\n    css: function (elem, name, extra, styles) {\r\n      var val,\r\n        num,\r\n        hooks,\r\n        origName = camelCase(name),\r\n        isCustomProp = rcustomProp.test(name);\r\n\r\n      // Make sure that we're working with the right name. We don't\r\n      // want to modify the value if it is a CSS custom property\r\n      // since they are user-defined.\r\n      if (!isCustomProp) {\r\n        name = finalPropName(origName);\r\n      }\r\n\r\n      // Try prefixed name followed by the unprefixed name\r\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\r\n\r\n      // If a hook was provided get the computed value from there\r\n      if (hooks && 'get' in hooks) {\r\n        val = hooks.get(elem, true, extra);\r\n      }\r\n\r\n      // Otherwise, if a way to get the computed value exists, use that\r\n      if (val === undefined) {\r\n        val = curCSS(elem, name, styles);\r\n      }\r\n\r\n      // Convert \"normal\" to computed value\r\n      if (val === 'normal' && name in cssNormalTransform) {\r\n        val = cssNormalTransform[name];\r\n      }\r\n\r\n      // Make numeric if forced or a qualifier was provided and val looks numeric\r\n      if (extra === '' || extra) {\r\n        num = parseFloat(val);\r\n        return extra === true || isFinite(num) ? num || 0 : val;\r\n      }\r\n\r\n      return val;\r\n    },\r\n  });\r\n\r\n  jQuery.each(['height', 'width'], function (_i, dimension) {\r\n    jQuery.cssHooks[dimension] = {\r\n      get: function (elem, computed, extra) {\r\n        if (computed) {\r\n          // Certain elements can have dimension info if we invisibly show them\r\n          // but it must have a current display style that would benefit\r\n          return rdisplayswap.test(jQuery.css(elem, 'display')) &&\r\n            // Support: Safari 8+\r\n            // Table columns in Safari have non-zero offsetWidth & zero\r\n            // getBoundingClientRect().width unless display is changed.\r\n            // Support: IE <=11 only\r\n            // Running getBoundingClientRect on a disconnected node\r\n            // in IE throws an error.\r\n            (!elem.getClientRects().length || !elem.getBoundingClientRect().width)\r\n            ? swap(elem, cssShow, function () {\r\n                return getWidthOrHeight(elem, dimension, extra);\r\n              })\r\n            : getWidthOrHeight(elem, dimension, extra);\r\n        }\r\n      },\r\n\r\n      set: function (elem, value, extra) {\r\n        var matches,\r\n          styles = getStyles(elem),\r\n          // Only read styles.position if the test has a chance to fail\r\n          // to avoid forcing a reflow.\r\n          scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === 'absolute',\r\n          // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\r\n          boxSizingNeeded = scrollboxSizeBuggy || extra,\r\n          isBorderBox =\r\n            boxSizingNeeded && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box',\r\n          subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0;\r\n\r\n        // Account for unreliable border-box dimensions by comparing offset* to computed and\r\n        // faking a content-box to get border and padding (gh-3699)\r\n        if (isBorderBox && scrollboxSizeBuggy) {\r\n          subtract -= Math.ceil(\r\n            elem['offset' + dimension[0].toUpperCase() + dimension.slice(1)] -\r\n              parseFloat(styles[dimension]) -\r\n              boxModelAdjustment(elem, dimension, 'border', false, styles) -\r\n              0.5,\r\n          );\r\n        }\r\n\r\n        // Convert to pixels if value adjustment is needed\r\n        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || 'px') !== 'px') {\r\n          elem.style[dimension] = value;\r\n          value = jQuery.css(elem, dimension);\r\n        }\r\n\r\n        return setPositiveNumber(elem, value, subtract);\r\n      },\r\n    };\r\n  });\r\n\r\n  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {\r\n    if (computed) {\r\n      return (\r\n        (parseFloat(curCSS(elem, 'marginLeft')) ||\r\n          elem.getBoundingClientRect().left -\r\n            swap(elem, { marginLeft: 0 }, function () {\r\n              return elem.getBoundingClientRect().left;\r\n            })) + 'px'\r\n      );\r\n    }\r\n  });\r\n\r\n  // These hooks are used by animate to expand properties\r\n  jQuery.each(\r\n    {\r\n      margin: '',\r\n      padding: '',\r\n      border: 'Width',\r\n    },\r\n    function (prefix, suffix) {\r\n      jQuery.cssHooks[prefix + suffix] = {\r\n        expand: function (value) {\r\n          var i = 0,\r\n            expanded = {},\r\n            // Assumes a single number if not a string\r\n            parts = typeof value === 'string' ? value.split(' ') : [value];\r\n\r\n          for (; i < 4; i++) {\r\n            expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\r\n          }\r\n\r\n          return expanded;\r\n        },\r\n      };\r\n\r\n      if (prefix !== 'margin') {\r\n        jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\r\n      }\r\n    },\r\n  );\r\n\r\n  jQuery.fn.extend({\r\n    css: function (name, value) {\r\n      return access(\r\n        this,\r\n        function (elem, name, value) {\r\n          var styles,\r\n            len,\r\n            map = {},\r\n            i = 0;\r\n\r\n          if (Array.isArray(name)) {\r\n            styles = getStyles(elem);\r\n            len = name.length;\r\n\r\n            for (; i < len; i++) {\r\n              map[name[i]] = jQuery.css(elem, name[i], false, styles);\r\n            }\r\n\r\n            return map;\r\n          }\r\n\r\n          return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\r\n        },\r\n        name,\r\n        value,\r\n        arguments.length > 1,\r\n      );\r\n    },\r\n  });\r\n\r\n  function Tween(elem, options, prop, end, easing) {\r\n    return new Tween.prototype.init(elem, options, prop, end, easing);\r\n  }\r\n  jQuery.Tween = Tween;\r\n\r\n  Tween.prototype = {\r\n    constructor: Tween,\r\n    init: function (elem, options, prop, end, easing, unit) {\r\n      this.elem = elem;\r\n      this.prop = prop;\r\n      this.easing = easing || jQuery.easing._default;\r\n      this.options = options;\r\n      this.start = this.now = this.cur();\r\n      this.end = end;\r\n      this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');\r\n    },\r\n    cur: function () {\r\n      var hooks = Tween.propHooks[this.prop];\r\n\r\n      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\r\n    },\r\n    run: function (percent) {\r\n      var eased,\r\n        hooks = Tween.propHooks[this.prop];\r\n\r\n      if (this.options.duration) {\r\n        this.pos = eased = jQuery.easing[this.easing](\r\n          percent,\r\n          this.options.duration * percent,\r\n          0,\r\n          1,\r\n          this.options.duration,\r\n        );\r\n      } else {\r\n        this.pos = eased = percent;\r\n      }\r\n      this.now = (this.end - this.start) * eased + this.start;\r\n\r\n      if (this.options.step) {\r\n        this.options.step.call(this.elem, this.now, this);\r\n      }\r\n\r\n      if (hooks && hooks.set) {\r\n        hooks.set(this);\r\n      } else {\r\n        Tween.propHooks._default.set(this);\r\n      }\r\n      return this;\r\n    },\r\n  };\r\n\r\n  Tween.prototype.init.prototype = Tween.prototype;\r\n\r\n  Tween.propHooks = {\r\n    _default: {\r\n      get: function (tween) {\r\n        var result;\r\n\r\n        // Use a property on the element directly when it is not a DOM element,\r\n        // or when there is no matching style property that exists.\r\n        if (\r\n          tween.elem.nodeType !== 1 ||\r\n          (tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null)\r\n        ) {\r\n          return tween.elem[tween.prop];\r\n        }\r\n\r\n        // Passing an empty string as a 3rd parameter to .css will automatically\r\n        // attempt a parseFloat and fallback to a string if the parse fails.\r\n        // Simple values such as \"10px\" are parsed to Float;\r\n        // complex values such as \"rotate(1rad)\" are returned as-is.\r\n        result = jQuery.css(tween.elem, tween.prop, '');\r\n\r\n        // Empty strings, null, undefined and \"auto\" are converted to 0.\r\n        return !result || result === 'auto' ? 0 : result;\r\n      },\r\n      set: function (tween) {\r\n        // Use step hook for back compat.\r\n        // Use cssHook if its there.\r\n        // Use .style if available and use plain properties where available.\r\n        if (jQuery.fx.step[tween.prop]) {\r\n          jQuery.fx.step[tween.prop](tween);\r\n        } else if (\r\n          tween.elem.nodeType === 1 &&\r\n          (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)\r\n        ) {\r\n          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\r\n        } else {\r\n          tween.elem[tween.prop] = tween.now;\r\n        }\r\n      },\r\n    },\r\n  };\r\n\r\n  // Support: IE <=9 only\r\n  // Panic based approach to setting things on disconnected nodes\r\n  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\r\n    set: function (tween) {\r\n      if (tween.elem.nodeType && tween.elem.parentNode) {\r\n        tween.elem[tween.prop] = tween.now;\r\n      }\r\n    },\r\n  };\r\n\r\n  jQuery.easing = {\r\n    linear: function (p) {\r\n      return p;\r\n    },\r\n    swing: function (p) {\r\n      return 0.5 - Math.cos(p * Math.PI) / 2;\r\n    },\r\n    _default: 'swing',\r\n  };\r\n\r\n  jQuery.fx = Tween.prototype.init;\r\n\r\n  // Back compat <1.8 extension point\r\n  jQuery.fx.step = {};\r\n\r\n  var fxNow,\r\n    inProgress,\r\n    rfxtypes = /^(?:toggle|show|hide)$/,\r\n    rrun = /queueHooks$/;\r\n\r\n  function schedule() {\r\n    if (inProgress) {\r\n      if (document.hidden === false && window.requestAnimationFrame) {\r\n        window.requestAnimationFrame(schedule);\r\n      } else {\r\n        window.setTimeout(schedule, jQuery.fx.interval);\r\n      }\r\n\r\n      jQuery.fx.tick();\r\n    }\r\n  }\r\n\r\n  // Animations created synchronously will run synchronously\r\n  function createFxNow() {\r\n    window.setTimeout(function () {\r\n      fxNow = undefined;\r\n    });\r\n    return (fxNow = Date.now());\r\n  }\r\n\r\n  // Generate parameters to create a standard animation\r\n  function genFx(type, includeWidth) {\r\n    var which,\r\n      i = 0,\r\n      attrs = { height: type };\r\n\r\n    // If we include width, step value is 1 to do all cssExpand values,\r\n    // otherwise step value is 2 to skip over Left and Right\r\n    includeWidth = includeWidth ? 1 : 0;\r\n    for (; i < 4; i += 2 - includeWidth) {\r\n      which = cssExpand[i];\r\n      attrs['margin' + which] = attrs['padding' + which] = type;\r\n    }\r\n\r\n    if (includeWidth) {\r\n      attrs.opacity = attrs.width = type;\r\n    }\r\n\r\n    return attrs;\r\n  }\r\n\r\n  function createTween(value, prop, animation) {\r\n    var tween,\r\n      collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners['*']),\r\n      index = 0,\r\n      length = collection.length;\r\n    for (; index < length; index++) {\r\n      if ((tween = collection[index].call(animation, prop, value))) {\r\n        // We're done with this property\r\n        return tween;\r\n      }\r\n    }\r\n  }\r\n\r\n  function defaultPrefilter(elem, props, opts) {\r\n    var prop,\r\n      value,\r\n      toggle,\r\n      hooks,\r\n      oldfire,\r\n      propTween,\r\n      restoreDisplay,\r\n      display,\r\n      isBox = 'width' in props || 'height' in props,\r\n      anim = this,\r\n      orig = {},\r\n      style = elem.style,\r\n      hidden = elem.nodeType && isHiddenWithinTree(elem),\r\n      dataShow = dataPriv.get(elem, 'fxshow');\r\n\r\n    // Queue-skipping animations hijack the fx hooks\r\n    if (!opts.queue) {\r\n      hooks = jQuery._queueHooks(elem, 'fx');\r\n      if (hooks.unqueued == null) {\r\n        hooks.unqueued = 0;\r\n        oldfire = hooks.empty.fire;\r\n        hooks.empty.fire = function () {\r\n          if (!hooks.unqueued) {\r\n            oldfire();\r\n          }\r\n        };\r\n      }\r\n      hooks.unqueued++;\r\n\r\n      anim.always(function () {\r\n        // Ensure the complete handler is called before this completes\r\n        anim.always(function () {\r\n          hooks.unqueued--;\r\n          if (!jQuery.queue(elem, 'fx').length) {\r\n            hooks.empty.fire();\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    // Detect show/hide animations\r\n    for (prop in props) {\r\n      value = props[prop];\r\n      if (rfxtypes.test(value)) {\r\n        delete props[prop];\r\n        toggle = toggle || value === 'toggle';\r\n        if (value === (hidden ? 'hide' : 'show')) {\r\n          // Pretend to be hidden if this is a \"show\" and\r\n          // there is still data from a stopped show/hide\r\n          if (value === 'show' && dataShow && dataShow[prop] !== undefined) {\r\n            hidden = true;\r\n\r\n            // Ignore all other no-op show/hide data\r\n          } else {\r\n            continue;\r\n          }\r\n        }\r\n        orig[prop] = (dataShow && dataShow[prop]) || jQuery.style(elem, prop);\r\n      }\r\n    }\r\n\r\n    // Bail out if this is a no-op like .hide().hide()\r\n    propTween = !jQuery.isEmptyObject(props);\r\n    if (!propTween && jQuery.isEmptyObject(orig)) {\r\n      return;\r\n    }\r\n\r\n    // Restrict \"overflow\" and \"display\" styles during box animations\r\n    if (isBox && elem.nodeType === 1) {\r\n      // Support: IE <=9 - 11, Edge 12 - 15\r\n      // Record all 3 overflow attributes because IE does not infer the shorthand\r\n      // from identically-valued overflowX and overflowY and Edge just mirrors\r\n      // the overflowX value there.\r\n      opts.overflow = [style.overflow, style.overflowX, style.overflowY];\r\n\r\n      // Identify a display type, preferring old show/hide data over the CSS cascade\r\n      restoreDisplay = dataShow && dataShow.display;\r\n      if (restoreDisplay == null) {\r\n        restoreDisplay = dataPriv.get(elem, 'display');\r\n      }\r\n      display = jQuery.css(elem, 'display');\r\n      if (display === 'none') {\r\n        if (restoreDisplay) {\r\n          display = restoreDisplay;\r\n        } else {\r\n          // Get nonempty value(s) by temporarily forcing visibility\r\n          showHide([elem], true);\r\n          restoreDisplay = elem.style.display || restoreDisplay;\r\n          display = jQuery.css(elem, 'display');\r\n          showHide([elem]);\r\n        }\r\n      }\r\n\r\n      // Animate inline elements as inline-block\r\n      if (display === 'inline' || (display === 'inline-block' && restoreDisplay != null)) {\r\n        if (jQuery.css(elem, 'float') === 'none') {\r\n          // Restore the original display value at the end of pure show/hide animations\r\n          if (!propTween) {\r\n            anim.done(function () {\r\n              style.display = restoreDisplay;\r\n            });\r\n            if (restoreDisplay == null) {\r\n              display = style.display;\r\n              restoreDisplay = display === 'none' ? '' : display;\r\n            }\r\n          }\r\n          style.display = 'inline-block';\r\n        }\r\n      }\r\n    }\r\n\r\n    if (opts.overflow) {\r\n      style.overflow = 'hidden';\r\n      anim.always(function () {\r\n        style.overflow = opts.overflow[0];\r\n        style.overflowX = opts.overflow[1];\r\n        style.overflowY = opts.overflow[2];\r\n      });\r\n    }\r\n\r\n    // Implement show/hide animations\r\n    propTween = false;\r\n    for (prop in orig) {\r\n      // General show/hide setup for this element animation\r\n      if (!propTween) {\r\n        if (dataShow) {\r\n          if ('hidden' in dataShow) {\r\n            hidden = dataShow.hidden;\r\n          }\r\n        } else {\r\n          dataShow = dataPriv.access(elem, 'fxshow', { display: restoreDisplay });\r\n        }\r\n\r\n        // Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\r\n        if (toggle) {\r\n          dataShow.hidden = !hidden;\r\n        }\r\n\r\n        // Show elements before animating them\r\n        if (hidden) {\r\n          showHide([elem], true);\r\n        }\r\n\r\n        /* eslint-disable no-loop-func */\r\n\r\n        anim.done(function () {\r\n          /* eslint-enable no-loop-func */\r\n\r\n          // The final step of a \"hide\" animation is actually hiding the element\r\n          if (!hidden) {\r\n            showHide([elem]);\r\n          }\r\n          dataPriv.remove(elem, 'fxshow');\r\n          for (prop in orig) {\r\n            jQuery.style(elem, prop, orig[prop]);\r\n          }\r\n        });\r\n      }\r\n\r\n      // Per-property setup\r\n      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\r\n      if (!(prop in dataShow)) {\r\n        dataShow[prop] = propTween.start;\r\n        if (hidden) {\r\n          propTween.end = propTween.start;\r\n          propTween.start = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function propFilter(props, specialEasing) {\r\n    var index, name, easing, value, hooks;\r\n\r\n    // camelCase, specialEasing and expand cssHook pass\r\n    for (index in props) {\r\n      name = camelCase(index);\r\n      easing = specialEasing[name];\r\n      value = props[index];\r\n      if (Array.isArray(value)) {\r\n        easing = value[1];\r\n        value = props[index] = value[0];\r\n      }\r\n\r\n      if (index !== name) {\r\n        props[name] = value;\r\n        delete props[index];\r\n      }\r\n\r\n      hooks = jQuery.cssHooks[name];\r\n      if (hooks && 'expand' in hooks) {\r\n        value = hooks.expand(value);\r\n        delete props[name];\r\n\r\n        // Not quite $.extend, this won't overwrite existing keys.\r\n        // Reusing 'index' because we have the correct \"name\"\r\n        for (index in value) {\r\n          if (!(index in props)) {\r\n            props[index] = value[index];\r\n            specialEasing[index] = easing;\r\n          }\r\n        }\r\n      } else {\r\n        specialEasing[name] = easing;\r\n      }\r\n    }\r\n  }\r\n\r\n  function Animation(elem, properties, options) {\r\n    var result,\r\n      stopped,\r\n      index = 0,\r\n      length = Animation.prefilters.length,\r\n      deferred = jQuery.Deferred().always(function () {\r\n        // Don't match elem in the :animated selector\r\n        delete tick.elem;\r\n      }),\r\n      tick = function () {\r\n        if (stopped) {\r\n          return false;\r\n        }\r\n        var currentTime = fxNow || createFxNow(),\r\n          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\r\n          // Support: Android 2.3 only\r\n          // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)\r\n          temp = remaining / animation.duration || 0,\r\n          percent = 1 - temp,\r\n          index = 0,\r\n          length = animation.tweens.length;\r\n\r\n        for (; index < length; index++) {\r\n          animation.tweens[index].run(percent);\r\n        }\r\n\r\n        deferred.notifyWith(elem, [animation, percent, remaining]);\r\n\r\n        // If there's more to do, yield\r\n        if (percent < 1 && length) {\r\n          return remaining;\r\n        }\r\n\r\n        // If this was an empty animation, synthesize a final progress notification\r\n        if (!length) {\r\n          deferred.notifyWith(elem, [animation, 1, 0]);\r\n        }\r\n\r\n        // Resolve the animation and report its conclusion\r\n        deferred.resolveWith(elem, [animation]);\r\n        return false;\r\n      },\r\n      animation = deferred.promise({\r\n        elem: elem,\r\n        props: jQuery.extend({}, properties),\r\n        opts: jQuery.extend(\r\n          true,\r\n          {\r\n            specialEasing: {},\r\n            easing: jQuery.easing._default,\r\n          },\r\n          options,\r\n        ),\r\n        originalProperties: properties,\r\n        originalOptions: options,\r\n        startTime: fxNow || createFxNow(),\r\n        duration: options.duration,\r\n        tweens: [],\r\n        createTween: function (prop, end) {\r\n          var tween = jQuery.Tween(\r\n            elem,\r\n            animation.opts,\r\n            prop,\r\n            end,\r\n            animation.opts.specialEasing[prop] || animation.opts.easing,\r\n          );\r\n          animation.tweens.push(tween);\r\n          return tween;\r\n        },\r\n        stop: function (gotoEnd) {\r\n          var index = 0,\r\n            // If we are going to the end, we want to run all the tweens\r\n            // otherwise we skip this part\r\n            length = gotoEnd ? animation.tweens.length : 0;\r\n          if (stopped) {\r\n            return this;\r\n          }\r\n          stopped = true;\r\n          for (; index < length; index++) {\r\n            animation.tweens[index].run(1);\r\n          }\r\n\r\n          // Resolve when we played the last frame; otherwise, reject\r\n          if (gotoEnd) {\r\n            deferred.notifyWith(elem, [animation, 1, 0]);\r\n            deferred.resolveWith(elem, [animation, gotoEnd]);\r\n          } else {\r\n            deferred.rejectWith(elem, [animation, gotoEnd]);\r\n          }\r\n          return this;\r\n        },\r\n      }),\r\n      props = animation.props;\r\n\r\n    propFilter(props, animation.opts.specialEasing);\r\n\r\n    for (; index < length; index++) {\r\n      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);\r\n      if (result) {\r\n        if (isFunction(result.stop)) {\r\n          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);\r\n        }\r\n        return result;\r\n      }\r\n    }\r\n\r\n    jQuery.map(props, createTween, animation);\r\n\r\n    if (isFunction(animation.opts.start)) {\r\n      animation.opts.start.call(elem, animation);\r\n    }\r\n\r\n    // Attach callbacks from options\r\n    animation\r\n      .progress(animation.opts.progress)\r\n      .done(animation.opts.done, animation.opts.complete)\r\n      .fail(animation.opts.fail)\r\n      .always(animation.opts.always);\r\n\r\n    jQuery.fx.timer(\r\n      jQuery.extend(tick, {\r\n        elem: elem,\r\n        anim: animation,\r\n        queue: animation.opts.queue,\r\n      }),\r\n    );\r\n\r\n    return animation;\r\n  }\r\n\r\n  jQuery.Animation = jQuery.extend(Animation, {\r\n    tweeners: {\r\n      '*': [\r\n        function (prop, value) {\r\n          var tween = this.createTween(prop, value);\r\n          adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);\r\n          return tween;\r\n        },\r\n      ],\r\n    },\r\n\r\n    tweener: function (props, callback) {\r\n      if (isFunction(props)) {\r\n        callback = props;\r\n        props = ['*'];\r\n      } else {\r\n        props = props.match(rnothtmlwhite);\r\n      }\r\n\r\n      var prop,\r\n        index = 0,\r\n        length = props.length;\r\n\r\n      for (; index < length; index++) {\r\n        prop = props[index];\r\n        Animation.tweeners[prop] = Animation.tweeners[prop] || [];\r\n        Animation.tweeners[prop].unshift(callback);\r\n      }\r\n    },\r\n\r\n    prefilters: [defaultPrefilter],\r\n\r\n    prefilter: function (callback, prepend) {\r\n      if (prepend) {\r\n        Animation.prefilters.unshift(callback);\r\n      } else {\r\n        Animation.prefilters.push(callback);\r\n      }\r\n    },\r\n  });\r\n\r\n  jQuery.speed = function (speed, easing, fn) {\r\n    var opt =\r\n      speed && typeof speed === 'object'\r\n        ? jQuery.extend({}, speed)\r\n        : {\r\n            complete: fn || (!fn && easing) || (isFunction(speed) && speed),\r\n            duration: speed,\r\n            easing: (fn && easing) || (easing && !isFunction(easing) && easing),\r\n          };\r\n\r\n    // Go to the end state if fx are off\r\n    if (jQuery.fx.off) {\r\n      opt.duration = 0;\r\n    } else {\r\n      if (typeof opt.duration !== 'number') {\r\n        if (opt.duration in jQuery.fx.speeds) {\r\n          opt.duration = jQuery.fx.speeds[opt.duration];\r\n        } else {\r\n          opt.duration = jQuery.fx.speeds._default;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Normalize opt.queue - true/undefined/null -> \"fx\"\r\n    if (opt.queue == null || opt.queue === true) {\r\n      opt.queue = 'fx';\r\n    }\r\n\r\n    // Queueing\r\n    opt.old = opt.complete;\r\n\r\n    opt.complete = function () {\r\n      if (isFunction(opt.old)) {\r\n        opt.old.call(this);\r\n      }\r\n\r\n      if (opt.queue) {\r\n        jQuery.dequeue(this, opt.queue);\r\n      }\r\n    };\r\n\r\n    return opt;\r\n  };\r\n\r\n  jQuery.fn.extend({\r\n    fadeTo: function (speed, to, easing, callback) {\r\n      // Show any hidden elements after setting opacity to 0\r\n      return (\r\n        this.filter(isHiddenWithinTree)\r\n          .css('opacity', 0)\r\n          .show()\r\n\r\n          // Animate to the value specified\r\n          .end()\r\n          .animate({ opacity: to }, speed, easing, callback)\r\n      );\r\n    },\r\n    animate: function (prop, speed, easing, callback) {\r\n      var empty = jQuery.isEmptyObject(prop),\r\n        optall = jQuery.speed(speed, easing, callback),\r\n        doAnimation = function () {\r\n          // Operate on a copy of prop so per-property easing won't be lost\r\n          var anim = Animation(this, jQuery.extend({}, prop), optall);\r\n\r\n          // Empty animations, or finishing resolves immediately\r\n          if (empty || dataPriv.get(this, 'finish')) {\r\n            anim.stop(true);\r\n          }\r\n        };\r\n\r\n      doAnimation.finish = doAnimation;\r\n\r\n      return empty || optall.queue === false\r\n        ? this.each(doAnimation)\r\n        : this.queue(optall.queue, doAnimation);\r\n    },\r\n    stop: function (type, clearQueue, gotoEnd) {\r\n      var stopQueue = function (hooks) {\r\n        var stop = hooks.stop;\r\n        delete hooks.stop;\r\n        stop(gotoEnd);\r\n      };\r\n\r\n      if (typeof type !== 'string') {\r\n        gotoEnd = clearQueue;\r\n        clearQueue = type;\r\n        type = undefined;\r\n      }\r\n      if (clearQueue) {\r\n        this.queue(type || 'fx', []);\r\n      }\r\n\r\n      return this.each(function () {\r\n        var dequeue = true,\r\n          index = type != null && type + 'queueHooks',\r\n          timers = jQuery.timers,\r\n          data = dataPriv.get(this);\r\n\r\n        if (index) {\r\n          if (data[index] && data[index].stop) {\r\n            stopQueue(data[index]);\r\n          }\r\n        } else {\r\n          for (index in data) {\r\n            if (data[index] && data[index].stop && rrun.test(index)) {\r\n              stopQueue(data[index]);\r\n            }\r\n          }\r\n        }\r\n\r\n        for (index = timers.length; index--; ) {\r\n          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {\r\n            timers[index].anim.stop(gotoEnd);\r\n            dequeue = false;\r\n            timers.splice(index, 1);\r\n          }\r\n        }\r\n\r\n        // Start the next in the queue if the last step wasn't forced.\r\n        // Timers currently will call their complete callbacks, which\r\n        // will dequeue but only if they were gotoEnd.\r\n        if (dequeue || !gotoEnd) {\r\n          jQuery.dequeue(this, type);\r\n        }\r\n      });\r\n    },\r\n    finish: function (type) {\r\n      if (type !== false) {\r\n        type = type || 'fx';\r\n      }\r\n      return this.each(function () {\r\n        var index,\r\n          data = dataPriv.get(this),\r\n          queue = data[type + 'queue'],\r\n          hooks = data[type + 'queueHooks'],\r\n          timers = jQuery.timers,\r\n          length = queue ? queue.length : 0;\r\n\r\n        // Enable finishing flag on private data\r\n        data.finish = true;\r\n\r\n        // Empty the queue first\r\n        jQuery.queue(this, type, []);\r\n\r\n        if (hooks && hooks.stop) {\r\n          hooks.stop.call(this, true);\r\n        }\r\n\r\n        // Look for any active animations, and finish them\r\n        for (index = timers.length; index--; ) {\r\n          if (timers[index].elem === this && timers[index].queue === type) {\r\n            timers[index].anim.stop(true);\r\n            timers.splice(index, 1);\r\n          }\r\n        }\r\n\r\n        // Look for any animations in the old queue and finish them\r\n        for (index = 0; index < length; index++) {\r\n          if (queue[index] && queue[index].finish) {\r\n            queue[index].finish.call(this);\r\n          }\r\n        }\r\n\r\n        // Turn off finishing flag\r\n        delete data.finish;\r\n      });\r\n    },\r\n  });\r\n\r\n  jQuery.each(['toggle', 'show', 'hide'], function (_i, name) {\r\n    var cssFn = jQuery.fn[name];\r\n    jQuery.fn[name] = function (speed, easing, callback) {\r\n      return speed == null || typeof speed === 'boolean'\r\n        ? cssFn.apply(this, arguments)\r\n        : this.animate(genFx(name, true), speed, easing, callback);\r\n    };\r\n  });\r\n\r\n  // Generate shortcuts for custom animations\r\n  jQuery.each(\r\n    {\r\n      slideDown: genFx('show'),\r\n      slideUp: genFx('hide'),\r\n      slideToggle: genFx('toggle'),\r\n      fadeIn: { opacity: 'show' },\r\n      fadeOut: { opacity: 'hide' },\r\n      fadeToggle: { opacity: 'toggle' },\r\n    },\r\n    function (name, props) {\r\n      jQuery.fn[name] = function (speed, easing, callback) {\r\n        return this.animate(props, speed, easing, callback);\r\n      };\r\n    },\r\n  );\r\n\r\n  jQuery.timers = [];\r\n  jQuery.fx.tick = function () {\r\n    var timer,\r\n      i = 0,\r\n      timers = jQuery.timers;\r\n\r\n    fxNow = Date.now();\r\n\r\n    for (; i < timers.length; i++) {\r\n      timer = timers[i];\r\n\r\n      // Run the timer and safely remove it when done (allowing for external removal)\r\n      if (!timer() && timers[i] === timer) {\r\n        timers.splice(i--, 1);\r\n      }\r\n    }\r\n\r\n    if (!timers.length) {\r\n      jQuery.fx.stop();\r\n    }\r\n    fxNow = undefined;\r\n  };\r\n\r\n  jQuery.fx.timer = function (timer) {\r\n    jQuery.timers.push(timer);\r\n    jQuery.fx.start();\r\n  };\r\n\r\n  jQuery.fx.interval = 13;\r\n  jQuery.fx.start = function () {\r\n    if (inProgress) {\r\n      return;\r\n    }\r\n\r\n    inProgress = true;\r\n    schedule();\r\n  };\r\n\r\n  jQuery.fx.stop = function () {\r\n    inProgress = null;\r\n  };\r\n\r\n  jQuery.fx.speeds = {\r\n    slow: 600,\r\n    fast: 200,\r\n\r\n    // Default speed\r\n    _default: 400,\r\n  };\r\n\r\n  // Based off of the plugin by Clint Helfers, with permission.\r\n  jQuery.fn.delay = function (time, type) {\r\n    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\r\n    type = type || 'fx';\r\n\r\n    return this.queue(type, function (next, hooks) {\r\n      var timeout = window.setTimeout(next, time);\r\n      hooks.stop = function () {\r\n        window.clearTimeout(timeout);\r\n      };\r\n    });\r\n  };\r\n\r\n  (function () {\r\n    var input = document.createElement('input'),\r\n      select = document.createElement('select'),\r\n      opt = select.appendChild(document.createElement('option'));\r\n\r\n    input.type = 'checkbox';\r\n\r\n    // Support: Android <=4.3 only\r\n    // Default value for a checkbox should be \"on\"\r\n    support.checkOn = input.value !== '';\r\n\r\n    // Support: IE <=11 only\r\n    // Must access selectedIndex to make default options select\r\n    support.optSelected = opt.selected;\r\n\r\n    // Support: IE <=11 only\r\n    // An input loses its value after becoming a radio\r\n    input = document.createElement('input');\r\n    input.value = 't';\r\n    input.type = 'radio';\r\n    support.radioValue = input.value === 't';\r\n  })();\r\n\r\n  var boolHook,\r\n    attrHandle = jQuery.expr.attrHandle;\r\n\r\n  jQuery.fn.extend({\r\n    attr: function (name, value) {\r\n      return access(this, jQuery.attr, name, value, arguments.length > 1);\r\n    },\r\n\r\n    removeAttr: function (name) {\r\n      return this.each(function () {\r\n        jQuery.removeAttr(this, name);\r\n      });\r\n    },\r\n  });\r\n\r\n  jQuery.extend({\r\n    attr: function (elem, name, value) {\r\n      var ret,\r\n        hooks,\r\n        nType = elem.nodeType;\r\n\r\n      // Don't get/set attributes on text, comment and attribute nodes\r\n      if (nType === 3 || nType === 8 || nType === 2) {\r\n        return;\r\n      }\r\n\r\n      // Fallback to prop when attributes are not supported\r\n      if (typeof elem.getAttribute === 'undefined') {\r\n        return jQuery.prop(elem, name, value);\r\n      }\r\n\r\n      // Attribute hooks are determined by the lowercase version\r\n      // Grab necessary hook if one is defined\r\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\r\n        hooks =\r\n          jQuery.attrHooks[name.toLowerCase()] ||\r\n          (jQuery.expr.match.bool.test(name) ? boolHook : undefined);\r\n      }\r\n\r\n      if (value !== undefined) {\r\n        if (value === null) {\r\n          jQuery.removeAttr(elem, name);\r\n          return;\r\n        }\r\n\r\n        if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\r\n          return ret;\r\n        }\r\n\r\n        elem.setAttribute(name, value + '');\r\n        return value;\r\n      }\r\n\r\n      if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {\r\n        return ret;\r\n      }\r\n\r\n      ret = jQuery.find.attr(elem, name);\r\n\r\n      // Non-existent attributes return null, we normalize to undefined\r\n      return ret == null ? undefined : ret;\r\n    },\r\n\r\n    attrHooks: {\r\n      type: {\r\n        set: function (elem, value) {\r\n          if (!support.radioValue && value === 'radio' && nodeName(elem, 'input')) {\r\n            var val = elem.value;\r\n            elem.setAttribute('type', value);\r\n            if (val) {\r\n              elem.value = val;\r\n            }\r\n            return value;\r\n          }\r\n        },\r\n      },\r\n    },\r\n\r\n    removeAttr: function (elem, value) {\r\n      var name,\r\n        i = 0,\r\n        // Attribute names can contain non-HTML whitespace characters\r\n        // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\r\n        attrNames = value && value.match(rnothtmlwhite);\r\n\r\n      if (attrNames && elem.nodeType === 1) {\r\n        while ((name = attrNames[i++])) {\r\n          elem.removeAttribute(name);\r\n        }\r\n      }\r\n    },\r\n  });\r\n\r\n  // Hooks for boolean attributes\r\n  boolHook = {\r\n    set: function (elem, value, name) {\r\n      if (value === false) {\r\n        // Remove boolean attributes when set to false\r\n        jQuery.removeAttr(elem, name);\r\n      } else {\r\n        elem.setAttribute(name, name);\r\n      }\r\n      return name;\r\n    },\r\n  };\r\n\r\n  jQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function (_i, name) {\r\n    var getter = attrHandle[name] || jQuery.find.attr;\r\n\r\n    attrHandle[name] = function (elem, name, isXML) {\r\n      var ret,\r\n        handle,\r\n        lowercaseName = name.toLowerCase();\r\n\r\n      if (!isXML) {\r\n        // Avoid an infinite loop by temporarily removing this function from the getter\r\n        handle = attrHandle[lowercaseName];\r\n        attrHandle[lowercaseName] = ret;\r\n        ret = getter(elem, name, isXML) != null ? lowercaseName : null;\r\n        attrHandle[lowercaseName] = handle;\r\n      }\r\n      return ret;\r\n    };\r\n  });\r\n\r\n  var rfocusable = /^(?:input|select|textarea|button)$/i,\r\n    rclickable = /^(?:a|area)$/i;\r\n\r\n  jQuery.fn.extend({\r\n    prop: function (name, value) {\r\n      return access(this, jQuery.prop, name, value, arguments.length > 1);\r\n    },\r\n\r\n    removeProp: function (name) {\r\n      return this.each(function () {\r\n        delete this[jQuery.propFix[name] || name];\r\n      });\r\n    },\r\n  });\r\n\r\n  jQuery.extend({\r\n    prop: function (elem, name, value) {\r\n      var ret,\r\n        hooks,\r\n        nType = elem.nodeType;\r\n\r\n      // Don't get/set properties on text, comment and attribute nodes\r\n      if (nType === 3 || nType === 8 || nType === 2) {\r\n        return;\r\n      }\r\n\r\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\r\n        // Fix name and attach hooks\r\n        name = jQuery.propFix[name] || name;\r\n        hooks = jQuery.propHooks[name];\r\n      }\r\n\r\n      if (value !== undefined) {\r\n        if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\r\n          return ret;\r\n        }\r\n\r\n        return (elem[name] = value);\r\n      }\r\n\r\n      if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {\r\n        return ret;\r\n      }\r\n\r\n      return elem[name];\r\n    },\r\n\r\n    propHooks: {\r\n      tabIndex: {\r\n        get: function (elem) {\r\n          // Support: IE <=9 - 11 only\r\n          // elem.tabIndex doesn't always return the\r\n          // correct value when it hasn't been explicitly set\r\n          // Use proper attribute retrieval (trac-12072)\r\n          var tabindex = jQuery.find.attr(elem, 'tabindex');\r\n\r\n          if (tabindex) {\r\n            return parseInt(tabindex, 10);\r\n          }\r\n\r\n          if (rfocusable.test(elem.nodeName) || (rclickable.test(elem.nodeName) && elem.href)) {\r\n            return 0;\r\n          }\r\n\r\n          return -1;\r\n        },\r\n      },\r\n    },\r\n\r\n    propFix: {\r\n      for: 'htmlFor',\r\n      class: 'className',\r\n    },\r\n  });\r\n\r\n  // Support: IE <=11 only\r\n  // Accessing the selectedIndex property\r\n  // forces the browser to respect setting selected\r\n  // on the option\r\n  // The getter ensures a default option is selected\r\n  // when in an optgroup\r\n  // eslint rule \"no-unused-expressions\" is disabled for this code\r\n  // since it considers such accessions noop\r\n  if (!support.optSelected) {\r\n    jQuery.propHooks.selected = {\r\n      get: function (elem) {\r\n        /* eslint no-unused-expressions: \"off\" */\r\n\r\n        var parent = elem.parentNode;\r\n        if (parent && parent.parentNode) {\r\n          parent.parentNode.selectedIndex;\r\n        }\r\n        return null;\r\n      },\r\n      set: function (elem) {\r\n        /* eslint no-unused-expressions: \"off\" */\r\n\r\n        var parent = elem.parentNode;\r\n        if (parent) {\r\n          parent.selectedIndex;\r\n\r\n          if (parent.parentNode) {\r\n            parent.parentNode.selectedIndex;\r\n          }\r\n        }\r\n      },\r\n    };\r\n  }\r\n\r\n  jQuery.each(\r\n    [\r\n      'tabIndex',\r\n      'readOnly',\r\n      'maxLength',\r\n      'cellSpacing',\r\n      'cellPadding',\r\n      'rowSpan',\r\n      'colSpan',\r\n      'useMap',\r\n      'frameBorder',\r\n      'contentEditable',\r\n    ],\r\n    function () {\r\n      jQuery.propFix[this.toLowerCase()] = this;\r\n    },\r\n  );\r\n\r\n  // Strip and collapse whitespace according to HTML spec\r\n  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\r\n  function stripAndCollapse(value) {\r\n    var tokens = value.match(rnothtmlwhite) || [];\r\n    return tokens.join(' ');\r\n  }\r\n\r\n  function getClass(elem) {\r\n    return (elem.getAttribute && elem.getAttribute('class')) || '';\r\n  }\r\n\r\n  function classesToArray(value) {\r\n    if (Array.isArray(value)) {\r\n      return value;\r\n    }\r\n    if (typeof value === 'string') {\r\n      return value.match(rnothtmlwhite) || [];\r\n    }\r\n    return [];\r\n  }\r\n\r\n  jQuery.fn.extend({\r\n    addClass: function (value) {\r\n      var classNames, cur, curValue, className, i, finalValue;\r\n\r\n      if (isFunction(value)) {\r\n        return this.each(function (j) {\r\n          jQuery(this).addClass(value.call(this, j, getClass(this)));\r\n        });\r\n      }\r\n\r\n      classNames = classesToArray(value);\r\n\r\n      if (classNames.length) {\r\n        return this.each(function () {\r\n          curValue = getClass(this);\r\n          cur = this.nodeType === 1 && ' ' + stripAndCollapse(curValue) + ' ';\r\n\r\n          if (cur) {\r\n            for (i = 0; i < classNames.length; i++) {\r\n              className = classNames[i];\r\n              if (cur.indexOf(' ' + className + ' ') < 0) {\r\n                cur += className + ' ';\r\n              }\r\n            }\r\n\r\n            // Only assign if different to avoid unneeded rendering.\r\n            finalValue = stripAndCollapse(cur);\r\n            if (curValue !== finalValue) {\r\n              this.setAttribute('class', finalValue);\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    removeClass: function (value) {\r\n      var classNames, cur, curValue, className, i, finalValue;\r\n\r\n      if (isFunction(value)) {\r\n        return this.each(function (j) {\r\n          jQuery(this).removeClass(value.call(this, j, getClass(this)));\r\n        });\r\n      }\r\n\r\n      if (!arguments.length) {\r\n        return this.attr('class', '');\r\n      }\r\n\r\n      classNames = classesToArray(value);\r\n\r\n      if (classNames.length) {\r\n        return this.each(function () {\r\n          curValue = getClass(this);\r\n\r\n          // This expression is here for better compressibility (see addClass)\r\n          cur = this.nodeType === 1 && ' ' + stripAndCollapse(curValue) + ' ';\r\n\r\n          if (cur) {\r\n            for (i = 0; i < classNames.length; i++) {\r\n              className = classNames[i];\r\n\r\n              // Remove *all* instances\r\n              while (cur.indexOf(' ' + className + ' ') > -1) {\r\n                cur = cur.replace(' ' + className + ' ', ' ');\r\n              }\r\n            }\r\n\r\n            // Only assign if different to avoid unneeded rendering.\r\n            finalValue = stripAndCollapse(cur);\r\n            if (curValue !== finalValue) {\r\n              this.setAttribute('class', finalValue);\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    toggleClass: function (value, stateVal) {\r\n      var classNames,\r\n        className,\r\n        i,\r\n        self,\r\n        type = typeof value,\r\n        isValidValue = type === 'string' || Array.isArray(value);\r\n\r\n      if (isFunction(value)) {\r\n        return this.each(function (i) {\r\n          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);\r\n        });\r\n      }\r\n\r\n      if (typeof stateVal === 'boolean' && isValidValue) {\r\n        return stateVal ? this.addClass(value) : this.removeClass(value);\r\n      }\r\n\r\n      classNames = classesToArray(value);\r\n\r\n      return this.each(function () {\r\n        if (isValidValue) {\r\n          // Toggle individual class names\r\n          self = jQuery(this);\r\n\r\n          for (i = 0; i < classNames.length; i++) {\r\n            className = classNames[i];\r\n\r\n            // Check each className given, space separated list\r\n            if (self.hasClass(className)) {\r\n              self.removeClass(className);\r\n            } else {\r\n              self.addClass(className);\r\n            }\r\n          }\r\n\r\n          // Toggle whole class name\r\n        } else if (value === undefined || type === 'boolean') {\r\n          className = getClass(this);\r\n          if (className) {\r\n            // Store className if set\r\n            dataPriv.set(this, '__className__', className);\r\n          }\r\n\r\n          // If the element has a class name or if we're passed `false`,\r\n          // then remove the whole classname (if there was one, the above saved it).\r\n          // Otherwise bring back whatever was previously saved (if anything),\r\n          // falling back to the empty string if nothing was stored.\r\n          if (this.setAttribute) {\r\n            this.setAttribute(\r\n              'class',\r\n              className || value === false ? '' : dataPriv.get(this, '__className__') || '',\r\n            );\r\n          }\r\n        }\r\n      });\r\n    },\r\n\r\n    hasClass: function (selector) {\r\n      var className,\r\n        elem,\r\n        i = 0;\r\n\r\n      className = ' ' + selector + ' ';\r\n      while ((elem = this[i++])) {\r\n        if (\r\n          elem.nodeType === 1 &&\r\n          (' ' + stripAndCollapse(getClass(elem)) + ' ').indexOf(className) > -1\r\n        ) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    },\r\n  });\r\n\r\n  var rreturn = /\\r/g;\r\n\r\n  jQuery.fn.extend({\r\n    val: function (value) {\r\n      var hooks,\r\n        ret,\r\n        valueIsFunction,\r\n        elem = this[0];\r\n\r\n      if (!arguments.length) {\r\n        if (elem) {\r\n          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\r\n\r\n          if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {\r\n            return ret;\r\n          }\r\n\r\n          ret = elem.value;\r\n\r\n          // Handle most common string cases\r\n          if (typeof ret === 'string') {\r\n            return ret.replace(rreturn, '');\r\n          }\r\n\r\n          // Handle cases where value is null/undef or number\r\n          return ret == null ? '' : ret;\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      valueIsFunction = isFunction(value);\r\n\r\n      return this.each(function (i) {\r\n        var val;\r\n\r\n        if (this.nodeType !== 1) {\r\n          return;\r\n        }\r\n\r\n        if (valueIsFunction) {\r\n          val = value.call(this, i, jQuery(this).val());\r\n        } else {\r\n          val = value;\r\n        }\r\n\r\n        // Treat null/undefined as \"\"; convert numbers to string\r\n        if (val == null) {\r\n          val = '';\r\n        } else if (typeof val === 'number') {\r\n          val += '';\r\n        } else if (Array.isArray(val)) {\r\n          val = jQuery.map(val, function (value) {\r\n            return value == null ? '' : value + '';\r\n          });\r\n        }\r\n\r\n        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];\r\n\r\n        // If set returns undefined, fall back to normal setting\r\n        if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {\r\n          this.value = val;\r\n        }\r\n      });\r\n    },\r\n  });\r\n\r\n  jQuery.extend({\r\n    valHooks: {\r\n      option: {\r\n        get: function (elem) {\r\n          var val = jQuery.find.attr(elem, 'value');\r\n          return val != null\r\n            ? val\r\n            : // Support: IE <=10 - 11 only\r\n              // option.text throws exceptions (trac-14686, trac-14858)\r\n              // Strip and collapse whitespace\r\n              // https://html.spec.whatwg.org/#strip-and-collapse-whitespace\r\n              stripAndCollapse(jQuery.text(elem));\r\n        },\r\n      },\r\n      select: {\r\n        get: function (elem) {\r\n          var value,\r\n            option,\r\n            i,\r\n            options = elem.options,\r\n            index = elem.selectedIndex,\r\n            one = elem.type === 'select-one',\r\n            values = one ? null : [],\r\n            max = one ? index + 1 : options.length;\r\n\r\n          if (index < 0) {\r\n            i = max;\r\n          } else {\r\n            i = one ? index : 0;\r\n          }\r\n\r\n          // Loop through all the selected options\r\n          for (; i < max; i++) {\r\n            option = options[i];\r\n\r\n            // Support: IE <=9 only\r\n            // IE8-9 doesn't update selected after form reset (trac-2551)\r\n            if (\r\n              (option.selected || i === index) &&\r\n              // Don't return options that are disabled or in a disabled optgroup\r\n              !option.disabled &&\r\n              (!option.parentNode.disabled || !nodeName(option.parentNode, 'optgroup'))\r\n            ) {\r\n              // Get the specific value for the option\r\n              value = jQuery(option).val();\r\n\r\n              // We don't need an array for one selects\r\n              if (one) {\r\n                return value;\r\n              }\r\n\r\n              // Multi-Selects return an array\r\n              values.push(value);\r\n            }\r\n          }\r\n\r\n          return values;\r\n        },\r\n\r\n        set: function (elem, value) {\r\n          var optionSet,\r\n            option,\r\n            options = elem.options,\r\n            values = jQuery.makeArray(value),\r\n            i = options.length;\r\n\r\n          while (i--) {\r\n            option = options[i];\r\n\r\n            /* eslint-disable no-cond-assign */\r\n\r\n            if (\r\n              (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1)\r\n            ) {\r\n              optionSet = true;\r\n            }\r\n\r\n            /* eslint-enable no-cond-assign */\r\n          }\r\n\r\n          // Force browsers to behave consistently when non-matching value is set\r\n          if (!optionSet) {\r\n            elem.selectedIndex = -1;\r\n          }\r\n          return values;\r\n        },\r\n      },\r\n    },\r\n  });\r\n\r\n  // Radios and checkboxes getter/setter\r\n  jQuery.each(['radio', 'checkbox'], function () {\r\n    jQuery.valHooks[this] = {\r\n      set: function (elem, value) {\r\n        if (Array.isArray(value)) {\r\n          return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);\r\n        }\r\n      },\r\n    };\r\n    if (!support.checkOn) {\r\n      jQuery.valHooks[this].get = function (elem) {\r\n        return elem.getAttribute('value') === null ? 'on' : elem.value;\r\n      };\r\n    }\r\n  });\r\n\r\n  // Return jQuery for attributes-only inclusion\r\n\r\n  support.focusin = 'onfocusin' in window;\r\n\r\n  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\r\n    stopPropagationCallback = function (e) {\r\n      e.stopPropagation();\r\n    };\r\n\r\n  jQuery.extend(jQuery.event, {\r\n    trigger: function (event, data, elem, onlyHandlers) {\r\n      var i,\r\n        cur,\r\n        tmp,\r\n        bubbleType,\r\n        ontype,\r\n        handle,\r\n        special,\r\n        lastElement,\r\n        eventPath = [elem || document],\r\n        type = hasOwn.call(event, 'type') ? event.type : event,\r\n        namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];\r\n\r\n      cur = lastElement = tmp = elem = elem || document;\r\n\r\n      // Don't do events on text and comment nodes\r\n      if (elem.nodeType === 3 || elem.nodeType === 8) {\r\n        return;\r\n      }\r\n\r\n      // focus/blur morphs to focusin/out; ensure we're not firing them right now\r\n      if (rfocusMorph.test(type + jQuery.event.triggered)) {\r\n        return;\r\n      }\r\n\r\n      if (type.indexOf('.') > -1) {\r\n        // Namespaced trigger; create a regexp to match event type in handle()\r\n        namespaces = type.split('.');\r\n        type = namespaces.shift();\r\n        namespaces.sort();\r\n      }\r\n      ontype = type.indexOf(':') < 0 && 'on' + type;\r\n\r\n      // Caller can pass in a jQuery.Event object, Object, or just an event type string\r\n      event = event[jQuery.expando]\r\n        ? event\r\n        : new jQuery.Event(type, typeof event === 'object' && event);\r\n\r\n      // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\r\n      event.isTrigger = onlyHandlers ? 2 : 3;\r\n      event.namespace = namespaces.join('.');\r\n      event.rnamespace = event.namespace\r\n        ? new RegExp('(^|\\\\.)' + namespaces.join('\\\\.(?:.*\\\\.|)') + '(\\\\.|$)')\r\n        : null;\r\n\r\n      // Clean up the event in case it is being reused\r\n      event.result = undefined;\r\n      if (!event.target) {\r\n        event.target = elem;\r\n      }\r\n\r\n      // Clone any incoming data and prepend the event, creating the handler arg list\r\n      data = data == null ? [event] : jQuery.makeArray(data, [event]);\r\n\r\n      // Allow special events to draw outside the lines\r\n      special = jQuery.event.special[type] || {};\r\n      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\r\n        return;\r\n      }\r\n\r\n      // Determine event propagation path in advance, per W3C events spec (trac-9951)\r\n      // Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)\r\n      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {\r\n        bubbleType = special.delegateType || type;\r\n        if (!rfocusMorph.test(bubbleType + type)) {\r\n          cur = cur.parentNode;\r\n        }\r\n        for (; cur; cur = cur.parentNode) {\r\n          eventPath.push(cur);\r\n          tmp = cur;\r\n        }\r\n\r\n        // Only add window if we got to document (e.g., not plain obj or detached DOM)\r\n        if (tmp === (elem.ownerDocument || document)) {\r\n          eventPath.push(tmp.defaultView || tmp.parentWindow || window);\r\n        }\r\n      }\r\n\r\n      // Fire handlers on the event path\r\n      i = 0;\r\n      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\r\n        lastElement = cur;\r\n        event.type = i > 1 ? bubbleType : special.bindType || type;\r\n\r\n        // jQuery handler\r\n        handle =\r\n          (dataPriv.get(cur, 'events') || Object.create(null))[event.type] &&\r\n          dataPriv.get(cur, 'handle');\r\n        if (handle) {\r\n          handle.apply(cur, data);\r\n        }\r\n\r\n        // Native handler\r\n        handle = ontype && cur[ontype];\r\n        if (handle && handle.apply && acceptData(cur)) {\r\n          event.result = handle.apply(cur, data);\r\n          if (event.result === false) {\r\n            event.preventDefault();\r\n          }\r\n        }\r\n      }\r\n      event.type = type;\r\n\r\n      // If nobody prevented the default action, do it now\r\n      if (!onlyHandlers && !event.isDefaultPrevented()) {\r\n        if (\r\n          (!special._default || special._default.apply(eventPath.pop(), data) === false) &&\r\n          acceptData(elem)\r\n        ) {\r\n          // Call a native DOM method on the target with the same name as the event.\r\n          // Don't do default actions on window, that's where global variables be (trac-6170)\r\n          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {\r\n            // Don't re-trigger an onFOO event when we call its FOO() method\r\n            tmp = elem[ontype];\r\n\r\n            if (tmp) {\r\n              elem[ontype] = null;\r\n            }\r\n\r\n            // Prevent re-triggering of the same event, since we already bubbled it above\r\n            jQuery.event.triggered = type;\r\n\r\n            if (event.isPropagationStopped()) {\r\n              lastElement.addEventListener(type, stopPropagationCallback);\r\n            }\r\n\r\n            elem[type]();\r\n\r\n            if (event.isPropagationStopped()) {\r\n              lastElement.removeEventListener(type, stopPropagationCallback);\r\n            }\r\n\r\n            jQuery.event.triggered = undefined;\r\n\r\n            if (tmp) {\r\n              elem[ontype] = tmp;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return event.result;\r\n    },\r\n\r\n    // Piggyback on a donor event to simulate a different one\r\n    // Used only for `focus(in | out)` events\r\n    simulate: function (type, elem, event) {\r\n      var e = jQuery.extend(new jQuery.Event(), event, {\r\n        type: type,\r\n        isSimulated: true,\r\n      });\r\n\r\n      jQuery.event.trigger(e, null, elem);\r\n    },\r\n  });\r\n\r\n  jQuery.fn.extend({\r\n    trigger: function (type, data) {\r\n      return this.each(function () {\r\n        jQuery.event.trigger(type, data, this);\r\n      });\r\n    },\r\n    triggerHandler: function (type, data) {\r\n      var elem = this[0];\r\n      if (elem) {\r\n        return jQuery.event.trigger(type, data, elem, true);\r\n      }\r\n    },\r\n  });\r\n\r\n  // Support: Firefox <=44\r\n  // Firefox doesn't have focus(in | out) events\r\n  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\r\n  //\r\n  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\r\n  // focus(in | out) events fire after focus & blur events,\r\n  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\r\n  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\r\n  if (!support.focusin) {\r\n    jQuery.each({ focus: 'focusin', blur: 'focusout' }, function (orig, fix) {\r\n      // Attach a single capturing handler on the document while someone wants focusin/focusout\r\n      var handler = function (event) {\r\n        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));\r\n      };\r\n\r\n      jQuery.event.special[fix] = {\r\n        setup: function () {\r\n          // Handle: regular nodes (via `this.ownerDocument`), window\r\n          // (via `this.document`) & document (via `this`).\r\n          var doc = this.ownerDocument || this.document || this,\r\n            attaches = dataPriv.access(doc, fix);\r\n\r\n          if (!attaches) {\r\n            doc.addEventListener(orig, handler, true);\r\n          }\r\n          dataPriv.access(doc, fix, (attaches || 0) + 1);\r\n        },\r\n        teardown: function () {\r\n          var doc = this.ownerDocument || this.document || this,\r\n            attaches = dataPriv.access(doc, fix) - 1;\r\n\r\n          if (!attaches) {\r\n            doc.removeEventListener(orig, handler, true);\r\n            dataPriv.remove(doc, fix);\r\n          } else {\r\n            dataPriv.access(doc, fix, attaches);\r\n          }\r\n        },\r\n      };\r\n    });\r\n  }\r\n  var location = window.location;\r\n\r\n  var nonce = { guid: Date.now() };\r\n\r\n  var rquery = /\\?/;\r\n\r\n  // Cross-browser xml parsing\r\n  jQuery.parseXML = function (data) {\r\n    var xml, parserErrorElem;\r\n    if (!data || typeof data !== 'string') {\r\n      return null;\r\n    }\r\n\r\n    // Support: IE 9 - 11 only\r\n    // IE throws on parseFromString with invalid input.\r\n    try {\r\n      xml = new window.DOMParser().parseFromString(data, 'text/xml');\r\n    } catch (e) {}\r\n\r\n    parserErrorElem = xml && xml.getElementsByTagName('parsererror')[0];\r\n    if (!xml || parserErrorElem) {\r\n      jQuery.error(\r\n        'Invalid XML: ' +\r\n          (parserErrorElem\r\n            ? jQuery\r\n                .map(parserErrorElem.childNodes, function (el) {\r\n                  return el.textContent;\r\n                })\r\n                .join('\\n')\r\n            : data),\r\n      );\r\n    }\r\n    return xml;\r\n  };\r\n\r\n  var rbracket = /\\[\\]$/,\r\n    rCRLF = /\\r?\\n/g,\r\n    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\r\n    rsubmittable = /^(?:input|select|textarea|keygen)/i;\r\n\r\n  function buildParams(prefix, obj, traditional, add) {\r\n    var name;\r\n\r\n    if (Array.isArray(obj)) {\r\n      // Serialize array item.\r\n      jQuery.each(obj, function (i, v) {\r\n        if (traditional || rbracket.test(prefix)) {\r\n          // Treat each array item as a scalar.\r\n          add(prefix, v);\r\n        } else {\r\n          // Item is non-scalar (array or object), encode its numeric index.\r\n          buildParams(\r\n            prefix + '[' + (typeof v === 'object' && v != null ? i : '') + ']',\r\n            v,\r\n            traditional,\r\n            add,\r\n          );\r\n        }\r\n      });\r\n    } else if (!traditional && toType(obj) === 'object') {\r\n      // Serialize object item.\r\n      for (name in obj) {\r\n        buildParams(prefix + '[' + name + ']', obj[name], traditional, add);\r\n      }\r\n    } else {\r\n      // Serialize scalar item.\r\n      add(prefix, obj);\r\n    }\r\n  }\r\n\r\n  // Serialize an array of form elements or a set of\r\n  // key/values into a query string\r\n  jQuery.param = function (a, traditional) {\r\n    var prefix,\r\n      s = [],\r\n      add = function (key, valueOrFunction) {\r\n        // If value is a function, invoke it and use its return value\r\n        var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;\r\n\r\n        s[s.length] =\r\n          encodeURIComponent(key) + '=' + encodeURIComponent(value == null ? '' : value);\r\n      };\r\n\r\n    if (a == null) {\r\n      return '';\r\n    }\r\n\r\n    // If an array was passed in, assume that it is an array of form elements.\r\n    if (Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {\r\n      // Serialize the form elements\r\n      jQuery.each(a, function () {\r\n        add(this.name, this.value);\r\n      });\r\n    } else {\r\n      // If traditional, encode the \"old\" way (the way 1.3.2 or older\r\n      // did it), otherwise encode params recursively.\r\n      for (prefix in a) {\r\n        buildParams(prefix, a[prefix], traditional, add);\r\n      }\r\n    }\r\n\r\n    // Return the resulting serialization\r\n    return s.join('&');\r\n  };\r\n\r\n  jQuery.fn.extend({\r\n    serialize: function () {\r\n      return jQuery.param(this.serializeArray());\r\n    },\r\n    serializeArray: function () {\r\n      return this.map(function () {\r\n        // Can add propHook for \"elements\" to filter or add form elements\r\n        var elements = jQuery.prop(this, 'elements');\r\n        return elements ? jQuery.makeArray(elements) : this;\r\n      })\r\n        .filter(function () {\r\n          var type = this.type;\r\n\r\n          // Use .is( \":disabled\" ) so that fieldset[disabled] works\r\n          return (\r\n            this.name &&\r\n            !jQuery(this).is(':disabled') &&\r\n            rsubmittable.test(this.nodeName) &&\r\n            !rsubmitterTypes.test(type) &&\r\n            (this.checked || !rcheckableType.test(type))\r\n          );\r\n        })\r\n        .map(function (_i, elem) {\r\n          var val = jQuery(this).val();\r\n\r\n          if (val == null) {\r\n            return null;\r\n          }\r\n\r\n          if (Array.isArray(val)) {\r\n            return jQuery.map(val, function (val) {\r\n              return { name: elem.name, value: val.replace(rCRLF, '\\r\\n') };\r\n            });\r\n          }\r\n\r\n          return { name: elem.name, value: val.replace(rCRLF, '\\r\\n') };\r\n        })\r\n        .get();\r\n    },\r\n  });\r\n\r\n  var r20 = /%20/g,\r\n    rhash = /#.*$/,\r\n    rantiCache = /([?&])_=[^&]*/,\r\n    rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/gm,\r\n    // trac-7653, trac-8125, trac-8152: local protocol detection\r\n    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\r\n    rnoContent = /^(?:GET|HEAD)$/,\r\n    rprotocol = /^\\/\\//,\r\n    /* Prefilters\r\n     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\r\n     * 2) These are called:\r\n     *    - BEFORE asking for a transport\r\n     *    - AFTER param serialization (s.data is a string if s.processData is true)\r\n     * 3) key is the dataType\r\n     * 4) the catchall symbol \"*\" can be used\r\n     * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\r\n     */\r\n    prefilters = {},\r\n    /* Transports bindings\r\n     * 1) key is the dataType\r\n     * 2) the catchall symbol \"*\" can be used\r\n     * 3) selection will start with transport dataType and THEN go to \"*\" if needed\r\n     */\r\n    transports = {},\r\n    // Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression\r\n    allTypes = '*/'.concat('*'),\r\n    // Anchor tag for parsing the document origin\r\n    originAnchor = document.createElement('a');\r\n\r\n  originAnchor.href = location.href;\r\n\r\n  // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\r\n  function addToPrefiltersOrTransports(structure) {\r\n    // dataTypeExpression is optional and defaults to \"*\"\r\n    return function (dataTypeExpression, func) {\r\n      if (typeof dataTypeExpression !== 'string') {\r\n        func = dataTypeExpression;\r\n        dataTypeExpression = '*';\r\n      }\r\n\r\n      var dataType,\r\n        i = 0,\r\n        dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];\r\n\r\n      if (isFunction(func)) {\r\n        // For each dataType in the dataTypeExpression\r\n        while ((dataType = dataTypes[i++])) {\r\n          // Prepend if requested\r\n          if (dataType[0] === '+') {\r\n            dataType = dataType.slice(1) || '*';\r\n            (structure[dataType] = structure[dataType] || []).unshift(func);\r\n\r\n            // Otherwise append\r\n          } else {\r\n            (structure[dataType] = structure[dataType] || []).push(func);\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  // Base inspection function for prefilters and transports\r\n  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\r\n    var inspected = {},\r\n      seekingTransport = structure === transports;\r\n\r\n    function inspect(dataType) {\r\n      var selected;\r\n      inspected[dataType] = true;\r\n      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\r\n        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\r\n        if (\r\n          typeof dataTypeOrTransport === 'string' &&\r\n          !seekingTransport &&\r\n          !inspected[dataTypeOrTransport]\r\n        ) {\r\n          options.dataTypes.unshift(dataTypeOrTransport);\r\n          inspect(dataTypeOrTransport);\r\n          return false;\r\n        } else if (seekingTransport) {\r\n          return !(selected = dataTypeOrTransport);\r\n        }\r\n      });\r\n      return selected;\r\n    }\r\n\r\n    return inspect(options.dataTypes[0]) || (!inspected['*'] && inspect('*'));\r\n  }\r\n\r\n  // A special extend for ajax options\r\n  // that takes \"flat\" options (not to be deep extended)\r\n  // Fixes trac-9887\r\n  function ajaxExtend(target, src) {\r\n    var key,\r\n      deep,\r\n      flatOptions = jQuery.ajaxSettings.flatOptions || {};\r\n\r\n    for (key in src) {\r\n      if (src[key] !== undefined) {\r\n        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\r\n      }\r\n    }\r\n    if (deep) {\r\n      jQuery.extend(true, target, deep);\r\n    }\r\n\r\n    return target;\r\n  }\r\n\r\n  /* Handles responses to an ajax request:\r\n   * - finds the right dataType (mediates between content-type and expected dataType)\r\n   * - returns the corresponding response\r\n   */\r\n  function ajaxHandleResponses(s, jqXHR, responses) {\r\n    var ct,\r\n      type,\r\n      finalDataType,\r\n      firstDataType,\r\n      contents = s.contents,\r\n      dataTypes = s.dataTypes;\r\n\r\n    // Remove auto dataType and get content-type in the process\r\n    while (dataTypes[0] === '*') {\r\n      dataTypes.shift();\r\n      if (ct === undefined) {\r\n        ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');\r\n      }\r\n    }\r\n\r\n    // Check if we're dealing with a known content-type\r\n    if (ct) {\r\n      for (type in contents) {\r\n        if (contents[type] && contents[type].test(ct)) {\r\n          dataTypes.unshift(type);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check to see if we have a response for the expected dataType\r\n    if (dataTypes[0] in responses) {\r\n      finalDataType = dataTypes[0];\r\n    } else {\r\n      // Try convertible dataTypes\r\n      for (type in responses) {\r\n        if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {\r\n          finalDataType = type;\r\n          break;\r\n        }\r\n        if (!firstDataType) {\r\n          firstDataType = type;\r\n        }\r\n      }\r\n\r\n      // Or just use first one\r\n      finalDataType = finalDataType || firstDataType;\r\n    }\r\n\r\n    // If we found a dataType\r\n    // We add the dataType to the list if needed\r\n    // and return the corresponding response\r\n    if (finalDataType) {\r\n      if (finalDataType !== dataTypes[0]) {\r\n        dataTypes.unshift(finalDataType);\r\n      }\r\n      return responses[finalDataType];\r\n    }\r\n  }\r\n\r\n  /* Chain conversions given the request and the original response\r\n   * Also sets the responseXXX fields on the jqXHR instance\r\n   */\r\n  function ajaxConvert(s, response, jqXHR, isSuccess) {\r\n    var conv2,\r\n      current,\r\n      conv,\r\n      tmp,\r\n      prev,\r\n      converters = {},\r\n      // Work with a copy of dataTypes in case we need to modify it for conversion\r\n      dataTypes = s.dataTypes.slice();\r\n\r\n    // Create converters map with lowercased keys\r\n    if (dataTypes[1]) {\r\n      for (conv in s.converters) {\r\n        converters[conv.toLowerCase()] = s.converters[conv];\r\n      }\r\n    }\r\n\r\n    current = dataTypes.shift();\r\n\r\n    // Convert to each sequential dataType\r\n    while (current) {\r\n      if (s.responseFields[current]) {\r\n        jqXHR[s.responseFields[current]] = response;\r\n      }\r\n\r\n      // Apply the dataFilter if provided\r\n      if (!prev && isSuccess && s.dataFilter) {\r\n        response = s.dataFilter(response, s.dataType);\r\n      }\r\n\r\n      prev = current;\r\n      current = dataTypes.shift();\r\n\r\n      if (current) {\r\n        // There's only work to do if current dataType is non-auto\r\n        if (current === '*') {\r\n          current = prev;\r\n\r\n          // Convert response if prev dataType is non-auto and differs from current\r\n        } else if (prev !== '*' && prev !== current) {\r\n          // Seek a direct converter\r\n          conv = converters[prev + ' ' + current] || converters['* ' + current];\r\n\r\n          // If none found, seek a pair\r\n          if (!conv) {\r\n            for (conv2 in converters) {\r\n              // If conv2 outputs current\r\n              tmp = conv2.split(' ');\r\n              if (tmp[1] === current) {\r\n                // If prev can be converted to accepted input\r\n                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];\r\n                if (conv) {\r\n                  // Condense equivalence converters\r\n                  if (conv === true) {\r\n                    conv = converters[conv2];\r\n\r\n                    // Otherwise, insert the intermediate dataType\r\n                  } else if (converters[conv2] !== true) {\r\n                    current = tmp[0];\r\n                    dataTypes.unshift(tmp[1]);\r\n                  }\r\n                  break;\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          // Apply converter (if not an equivalence)\r\n          if (conv !== true) {\r\n            // Unless errors are allowed to bubble, catch and return them\r\n            if (conv && s.throws) {\r\n              response = conv(response);\r\n            } else {\r\n              try {\r\n                response = conv(response);\r\n              } catch (e) {\r\n                return {\r\n                  state: 'parsererror',\r\n                  error: conv ? e : 'No conversion from ' + prev + ' to ' + current,\r\n                };\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return { state: 'success', data: response };\r\n  }\r\n\r\n  jQuery.extend({\r\n    // Counter for holding the number of active queries\r\n    active: 0,\r\n\r\n    // Last-Modified header cache for next request\r\n    lastModified: {},\r\n    etag: {},\r\n\r\n    ajaxSettings: {\r\n      url: location.href,\r\n      type: 'GET',\r\n      isLocal: rlocalProtocol.test(location.protocol),\r\n      global: true,\r\n      processData: true,\r\n      async: true,\r\n      contentType: 'application/x-www-form-urlencoded; charset=UTF-8',\r\n\r\n      /*\r\n\t\ttimeout: 0,\r\n\t\tdata: null,\r\n\t\tdataType: null,\r\n\t\tusername: null,\r\n\t\tpassword: null,\r\n\t\tcache: null,\r\n\t\tthrows: false,\r\n\t\ttraditional: false,\r\n\t\theaders: {},\r\n\t\t*/\r\n\r\n      accepts: {\r\n        '*': allTypes,\r\n        text: 'text/plain',\r\n        html: 'text/html',\r\n        xml: 'application/xml, text/xml',\r\n        json: 'application/json, text/javascript',\r\n      },\r\n\r\n      contents: {\r\n        xml: /\\bxml\\b/,\r\n        html: /\\bhtml/,\r\n        json: /\\bjson\\b/,\r\n      },\r\n\r\n      responseFields: {\r\n        xml: 'responseXML',\r\n        text: 'responseText',\r\n        json: 'responseJSON',\r\n      },\r\n\r\n      // Data converters\r\n      // Keys separate source (or catchall \"*\") and destination types with a single space\r\n      converters: {\r\n        // Convert anything to text\r\n        '* text': String,\r\n\r\n        // Text to html (true = no transformation)\r\n        'text html': true,\r\n\r\n        // Evaluate text as a json expression\r\n        'text json': JSON.parse,\r\n\r\n        // Parse text as xml\r\n        'text xml': jQuery.parseXML,\r\n      },\r\n\r\n      // For options that shouldn't be deep extended:\r\n      // you can add your own custom options here if\r\n      // and when you create one that shouldn't be\r\n      // deep extended (see ajaxExtend)\r\n      flatOptions: {\r\n        url: true,\r\n        context: true,\r\n      },\r\n    },\r\n\r\n    // Creates a full fledged settings object into target\r\n    // with both ajaxSettings and settings fields.\r\n    // If target is omitted, writes into ajaxSettings.\r\n    ajaxSetup: function (target, settings) {\r\n      return settings\r\n        ? // Building a settings object\r\n          ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)\r\n        : // Extending ajaxSettings\r\n          ajaxExtend(jQuery.ajaxSettings, target);\r\n    },\r\n\r\n    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\r\n    ajaxTransport: addToPrefiltersOrTransports(transports),\r\n\r\n    // Main method\r\n    ajax: function (url, options) {\r\n      // If url is an object, simulate pre-1.5 signature\r\n      if (typeof url === 'object') {\r\n        options = url;\r\n        url = undefined;\r\n      }\r\n\r\n      // Force options to be an object\r\n      options = options || {};\r\n\r\n      var transport,\r\n        // URL without anti-cache param\r\n        cacheURL,\r\n        // Response headers\r\n        responseHeadersString,\r\n        responseHeaders,\r\n        // timeout handle\r\n        timeoutTimer,\r\n        // Url cleanup var\r\n        urlAnchor,\r\n        // Request state (becomes false upon send and true upon completion)\r\n        completed,\r\n        // To know if global events are to be dispatched\r\n        fireGlobals,\r\n        // Loop variable\r\n        i,\r\n        // uncached part of the url\r\n        uncached,\r\n        // Create the final options object\r\n        s = jQuery.ajaxSetup({}, options),\r\n        // Callbacks context\r\n        callbackContext = s.context || s,\r\n        // Context for global events is callbackContext if it is a DOM node or jQuery collection\r\n        globalEventContext =\r\n          s.context && (callbackContext.nodeType || callbackContext.jquery)\r\n            ? jQuery(callbackContext)\r\n            : jQuery.event,\r\n        // Deferreds\r\n        deferred = jQuery.Deferred(),\r\n        completeDeferred = jQuery.Callbacks('once memory'),\r\n        // Status-dependent callbacks\r\n        statusCode = s.statusCode || {},\r\n        // Headers (they are sent all at once)\r\n        requestHeaders = {},\r\n        requestHeadersNames = {},\r\n        // Default abort message\r\n        strAbort = 'canceled',\r\n        // Fake xhr\r\n        jqXHR = {\r\n          readyState: 0,\r\n\r\n          // Builds headers hashtable if needed\r\n          getResponseHeader: function (key) {\r\n            var match;\r\n            if (completed) {\r\n              if (!responseHeaders) {\r\n                responseHeaders = {};\r\n                while ((match = rheaders.exec(responseHeadersString))) {\r\n                  responseHeaders[match[1].toLowerCase() + ' '] = (\r\n                    responseHeaders[match[1].toLowerCase() + ' '] || []\r\n                  ).concat(match[2]);\r\n                }\r\n              }\r\n              match = responseHeaders[key.toLowerCase() + ' '];\r\n            }\r\n            return match == null ? null : match.join(', ');\r\n          },\r\n\r\n          // Raw string\r\n          getAllResponseHeaders: function () {\r\n            return completed ? responseHeadersString : null;\r\n          },\r\n\r\n          // Caches the header\r\n          setRequestHeader: function (name, value) {\r\n            if (completed == null) {\r\n              name = requestHeadersNames[name.toLowerCase()] =\r\n                requestHeadersNames[name.toLowerCase()] || name;\r\n              requestHeaders[name] = value;\r\n            }\r\n            return this;\r\n          },\r\n\r\n          // Overrides response content-type header\r\n          overrideMimeType: function (type) {\r\n            if (completed == null) {\r\n              s.mimeType = type;\r\n            }\r\n            return this;\r\n          },\r\n\r\n          // Status-dependent callbacks\r\n          statusCode: function (map) {\r\n            var code;\r\n            if (map) {\r\n              if (completed) {\r\n                // Execute the appropriate callbacks\r\n                jqXHR.always(map[jqXHR.status]);\r\n              } else {\r\n                // Lazy-add the new callbacks in a way that preserves old ones\r\n                for (code in map) {\r\n                  statusCode[code] = [statusCode[code], map[code]];\r\n                }\r\n              }\r\n            }\r\n            return this;\r\n          },\r\n\r\n          // Cancel the request\r\n          abort: function (statusText) {\r\n            var finalText = statusText || strAbort;\r\n            if (transport) {\r\n              transport.abort(finalText);\r\n            }\r\n            done(0, finalText);\r\n            return this;\r\n          },\r\n        };\r\n\r\n      // Attach deferreds\r\n      deferred.promise(jqXHR);\r\n\r\n      // Add protocol if not provided (prefilters might expect it)\r\n      // Handle falsy url in the settings object (trac-10093: consistency with old signature)\r\n      // We also use the url parameter if available\r\n      s.url = ((url || s.url || location.href) + '').replace(rprotocol, location.protocol + '//');\r\n\r\n      // Alias method option to type as per ticket trac-12004\r\n      s.type = options.method || options.type || s.method || s.type;\r\n\r\n      // Extract dataTypes list\r\n      s.dataTypes = (s.dataType || '*').toLowerCase().match(rnothtmlwhite) || [''];\r\n\r\n      // A cross-domain request is in order when the origin doesn't match the current origin.\r\n      if (s.crossDomain == null) {\r\n        urlAnchor = document.createElement('a');\r\n\r\n        // Support: IE <=8 - 11, Edge 12 - 15\r\n        // IE throws exception on accessing the href property if url is malformed,\r\n        // e.g. http://example.com:80x/\r\n        try {\r\n          urlAnchor.href = s.url;\r\n\r\n          // Support: IE <=8 - 11 only\r\n          // Anchor's host property isn't correctly set when s.url is relative\r\n          urlAnchor.href = urlAnchor.href;\r\n          s.crossDomain =\r\n            originAnchor.protocol + '//' + originAnchor.host !==\r\n            urlAnchor.protocol + '//' + urlAnchor.host;\r\n        } catch (e) {\r\n          // If there is an error parsing the URL, assume it is crossDomain,\r\n          // it can be rejected by the transport if it is invalid\r\n          s.crossDomain = true;\r\n        }\r\n      }\r\n\r\n      // Convert data if not already a string\r\n      if (s.data && s.processData && typeof s.data !== 'string') {\r\n        s.data = jQuery.param(s.data, s.traditional);\r\n      }\r\n\r\n      // Apply prefilters\r\n      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);\r\n\r\n      // If request was aborted inside a prefilter, stop there\r\n      if (completed) {\r\n        return jqXHR;\r\n      }\r\n\r\n      // We can fire global events as of now if asked to\r\n      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)\r\n      fireGlobals = jQuery.event && s.global;\r\n\r\n      // Watch for a new set of requests\r\n      if (fireGlobals && jQuery.active++ === 0) {\r\n        jQuery.event.trigger('ajaxStart');\r\n      }\r\n\r\n      // Uppercase the type\r\n      s.type = s.type.toUpperCase();\r\n\r\n      // Determine if request has content\r\n      s.hasContent = !rnoContent.test(s.type);\r\n\r\n      // Save the URL in case we're toying with the If-Modified-Since\r\n      // and/or If-None-Match header later on\r\n      // Remove hash to simplify url manipulation\r\n      cacheURL = s.url.replace(rhash, '');\r\n\r\n      // More options handling for requests with no content\r\n      if (!s.hasContent) {\r\n        // Remember the hash so we can put it back\r\n        uncached = s.url.slice(cacheURL.length);\r\n\r\n        // If data is available and should be processed, append data to url\r\n        if (s.data && (s.processData || typeof s.data === 'string')) {\r\n          cacheURL += (rquery.test(cacheURL) ? '&' : '?') + s.data;\r\n\r\n          // trac-9682: remove data so that it's not used in an eventual retry\r\n          delete s.data;\r\n        }\r\n\r\n        // Add or update anti-cache param if needed\r\n        if (s.cache === false) {\r\n          cacheURL = cacheURL.replace(rantiCache, '$1');\r\n          uncached = (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce.guid++ + uncached;\r\n        }\r\n\r\n        // Put hash and anti-cache on the URL that will be requested (gh-1732)\r\n        s.url = cacheURL + uncached;\r\n\r\n        // Change '%20' to '+' if this is encoded form body content (gh-2658)\r\n      } else if (\r\n        s.data &&\r\n        s.processData &&\r\n        (s.contentType || '').indexOf('application/x-www-form-urlencoded') === 0\r\n      ) {\r\n        s.data = s.data.replace(r20, '+');\r\n      }\r\n\r\n      // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\r\n      if (s.ifModified) {\r\n        if (jQuery.lastModified[cacheURL]) {\r\n          jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);\r\n        }\r\n        if (jQuery.etag[cacheURL]) {\r\n          jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);\r\n        }\r\n      }\r\n\r\n      // Set the correct header, if data is being sent\r\n      if ((s.data && s.hasContent && s.contentType !== false) || options.contentType) {\r\n        jqXHR.setRequestHeader('Content-Type', s.contentType);\r\n      }\r\n\r\n      // Set the Accepts header for the server, depending on the dataType\r\n      jqXHR.setRequestHeader(\r\n        'Accept',\r\n        s.dataTypes[0] && s.accepts[s.dataTypes[0]]\r\n          ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '')\r\n          : s.accepts['*'],\r\n      );\r\n\r\n      // Check for headers option\r\n      for (i in s.headers) {\r\n        jqXHR.setRequestHeader(i, s.headers[i]);\r\n      }\r\n\r\n      // Allow custom headers/mimetypes and early abort\r\n      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {\r\n        // Abort if not done already and return\r\n        return jqXHR.abort();\r\n      }\r\n\r\n      // Aborting is no longer a cancellation\r\n      strAbort = 'abort';\r\n\r\n      // Install callbacks on deferreds\r\n      completeDeferred.add(s.complete);\r\n      jqXHR.done(s.success);\r\n      jqXHR.fail(s.error);\r\n\r\n      // Get transport\r\n      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);\r\n\r\n      // If no transport, we auto-abort\r\n      if (!transport) {\r\n        done(-1, 'No Transport');\r\n      } else {\r\n        jqXHR.readyState = 1;\r\n\r\n        // Send global event\r\n        if (fireGlobals) {\r\n          globalEventContext.trigger('ajaxSend', [jqXHR, s]);\r\n        }\r\n\r\n        // If request was aborted inside ajaxSend, stop there\r\n        if (completed) {\r\n          return jqXHR;\r\n        }\r\n\r\n        // Timeout\r\n        if (s.async && s.timeout > 0) {\r\n          timeoutTimer = window.setTimeout(function () {\r\n            jqXHR.abort('timeout');\r\n          }, s.timeout);\r\n        }\r\n\r\n        try {\r\n          completed = false;\r\n          transport.send(requestHeaders, done);\r\n        } catch (e) {\r\n          // Rethrow post-completion exceptions\r\n          if (completed) {\r\n            throw e;\r\n          }\r\n\r\n          // Propagate others as results\r\n          done(-1, e);\r\n        }\r\n      }\r\n\r\n      // Callback for when everything is done\r\n      function done(status, nativeStatusText, responses, headers) {\r\n        var isSuccess,\r\n          success,\r\n          error,\r\n          response,\r\n          modified,\r\n          statusText = nativeStatusText;\r\n\r\n        // Ignore repeat invocations\r\n        if (completed) {\r\n          return;\r\n        }\r\n\r\n        completed = true;\r\n\r\n        // Clear timeout if it exists\r\n        if (timeoutTimer) {\r\n          window.clearTimeout(timeoutTimer);\r\n        }\r\n\r\n        // Dereference transport for early garbage collection\r\n        // (no matter how long the jqXHR object will be used)\r\n        transport = undefined;\r\n\r\n        // Cache response headers\r\n        responseHeadersString = headers || '';\r\n\r\n        // Set readyState\r\n        jqXHR.readyState = status > 0 ? 4 : 0;\r\n\r\n        // Determine if successful\r\n        isSuccess = (status >= 200 && status < 300) || status === 304;\r\n\r\n        // Get response data\r\n        if (responses) {\r\n          response = ajaxHandleResponses(s, jqXHR, responses);\r\n        }\r\n\r\n        // Use a noop converter for missing script but not if jsonp\r\n        if (\r\n          !isSuccess &&\r\n          jQuery.inArray('script', s.dataTypes) > -1 &&\r\n          jQuery.inArray('json', s.dataTypes) < 0\r\n        ) {\r\n          s.converters['text script'] = function () {};\r\n        }\r\n\r\n        // Convert no matter what (that way responseXXX fields are always set)\r\n        response = ajaxConvert(s, response, jqXHR, isSuccess);\r\n\r\n        // If successful, handle type chaining\r\n        if (isSuccess) {\r\n          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\r\n          if (s.ifModified) {\r\n            modified = jqXHR.getResponseHeader('Last-Modified');\r\n            if (modified) {\r\n              jQuery.lastModified[cacheURL] = modified;\r\n            }\r\n            modified = jqXHR.getResponseHeader('etag');\r\n            if (modified) {\r\n              jQuery.etag[cacheURL] = modified;\r\n            }\r\n          }\r\n\r\n          // if no content\r\n          if (status === 204 || s.type === 'HEAD') {\r\n            statusText = 'nocontent';\r\n\r\n            // if not modified\r\n          } else if (status === 304) {\r\n            statusText = 'notmodified';\r\n\r\n            // If we have data, let's convert it\r\n          } else {\r\n            statusText = response.state;\r\n            success = response.data;\r\n            error = response.error;\r\n            isSuccess = !error;\r\n          }\r\n        } else {\r\n          // Extract error from statusText and normalize for non-aborts\r\n          error = statusText;\r\n          if (status || !statusText) {\r\n            statusText = 'error';\r\n            if (status < 0) {\r\n              status = 0;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Set data for the fake xhr object\r\n        jqXHR.status = status;\r\n        jqXHR.statusText = (nativeStatusText || statusText) + '';\r\n\r\n        // Success/Error\r\n        if (isSuccess) {\r\n          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\r\n        } else {\r\n          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\r\n        }\r\n\r\n        // Status-dependent callbacks\r\n        jqXHR.statusCode(statusCode);\r\n        statusCode = undefined;\r\n\r\n        if (fireGlobals) {\r\n          globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [\r\n            jqXHR,\r\n            s,\r\n            isSuccess ? success : error,\r\n          ]);\r\n        }\r\n\r\n        // Complete\r\n        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);\r\n\r\n        if (fireGlobals) {\r\n          globalEventContext.trigger('ajaxComplete', [jqXHR, s]);\r\n\r\n          // Handle the global AJAX counter\r\n          if (!--jQuery.active) {\r\n            jQuery.event.trigger('ajaxStop');\r\n          }\r\n        }\r\n      }\r\n\r\n      return jqXHR;\r\n    },\r\n\r\n    getJSON: function (url, data, callback) {\r\n      return jQuery.get(url, data, callback, 'json');\r\n    },\r\n\r\n    getScript: function (url, callback) {\r\n      return jQuery.get(url, undefined, callback, 'script');\r\n    },\r\n  });\r\n\r\n  jQuery.each(['get', 'post'], function (_i, method) {\r\n    jQuery[method] = function (url, data, callback, type) {\r\n      // Shift arguments if data argument was omitted\r\n      if (isFunction(data)) {\r\n        type = type || callback;\r\n        callback = data;\r\n        data = undefined;\r\n      }\r\n\r\n      // The url can be an options object (which then must have .url)\r\n      return jQuery.ajax(\r\n        jQuery.extend(\r\n          {\r\n            url: url,\r\n            type: method,\r\n            dataType: type,\r\n            data: data,\r\n            success: callback,\r\n          },\r\n          jQuery.isPlainObject(url) && url,\r\n        ),\r\n      );\r\n    };\r\n  });\r\n\r\n  jQuery.ajaxPrefilter(function (s) {\r\n    var i;\r\n    for (i in s.headers) {\r\n      if (i.toLowerCase() === 'content-type') {\r\n        s.contentType = s.headers[i] || '';\r\n      }\r\n    }\r\n  });\r\n\r\n  jQuery._evalUrl = function (url, options, doc) {\r\n    return jQuery.ajax({\r\n      url: url,\r\n\r\n      // Make this explicit, since user can override this through ajaxSetup (trac-11264)\r\n      type: 'GET',\r\n      dataType: 'script',\r\n      cache: true,\r\n      async: false,\r\n      global: false,\r\n\r\n      // Only evaluate the response if it is successful (gh-4126)\r\n      // dataFilter is not invoked for failure responses, so using it instead\r\n      // of the default converter is kludgy but it works.\r\n      converters: {\r\n        'text script': function () {},\r\n      },\r\n      dataFilter: function (response) {\r\n        jQuery.globalEval(response, options, doc);\r\n      },\r\n    });\r\n  };\r\n\r\n  jQuery.fn.extend({\r\n    wrapAll: function (html) {\r\n      var wrap;\r\n\r\n      if (this[0]) {\r\n        if (isFunction(html)) {\r\n          html = html.call(this[0]);\r\n        }\r\n\r\n        // The elements to wrap the target around\r\n        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\r\n\r\n        if (this[0].parentNode) {\r\n          wrap.insertBefore(this[0]);\r\n        }\r\n\r\n        wrap\r\n          .map(function () {\r\n            var elem = this;\r\n\r\n            while (elem.firstElementChild) {\r\n              elem = elem.firstElementChild;\r\n            }\r\n\r\n            return elem;\r\n          })\r\n          .append(this);\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    wrapInner: function (html) {\r\n      if (isFunction(html)) {\r\n        return this.each(function (i) {\r\n          jQuery(this).wrapInner(html.call(this, i));\r\n        });\r\n      }\r\n\r\n      return this.each(function () {\r\n        var self = jQuery(this),\r\n          contents = self.contents();\r\n\r\n        if (contents.length) {\r\n          contents.wrapAll(html);\r\n        } else {\r\n          self.append(html);\r\n        }\r\n      });\r\n    },\r\n\r\n    wrap: function (html) {\r\n      var htmlIsFunction = isFunction(html);\r\n\r\n      return this.each(function (i) {\r\n        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);\r\n      });\r\n    },\r\n\r\n    unwrap: function (selector) {\r\n      this.parent(selector)\r\n        .not('body')\r\n        .each(function () {\r\n          jQuery(this).replaceWith(this.childNodes);\r\n        });\r\n      return this;\r\n    },\r\n  });\r\n\r\n  jQuery.expr.pseudos.hidden = function (elem) {\r\n    return !jQuery.expr.pseudos.visible(elem);\r\n  };\r\n  jQuery.expr.pseudos.visible = function (elem) {\r\n    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);\r\n  };\r\n\r\n  jQuery.ajaxSettings.xhr = function () {\r\n    try {\r\n      return new window.XMLHttpRequest();\r\n    } catch (e) {}\r\n  };\r\n\r\n  var xhrSuccessStatus = {\r\n      // File protocol always yields status code 0, assume 200\r\n      0: 200,\r\n\r\n      // Support: IE <=9 only\r\n      // trac-1450: sometimes IE returns 1223 when it should be 204\r\n      1223: 204,\r\n    },\r\n    xhrSupported = jQuery.ajaxSettings.xhr();\r\n\r\n  support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;\r\n  support.ajax = xhrSupported = !!xhrSupported;\r\n\r\n  jQuery.ajaxTransport(function (options) {\r\n    var callback, errorCallback;\r\n\r\n    // Cross domain only allowed if supported through XMLHttpRequest\r\n    if (support.cors || (xhrSupported && !options.crossDomain)) {\r\n      return {\r\n        send: function (headers, complete) {\r\n          var i,\r\n            xhr = options.xhr();\r\n\r\n          xhr.open(options.type, options.url, options.async, options.username, options.password);\r\n\r\n          // Apply custom fields if provided\r\n          if (options.xhrFields) {\r\n            for (i in options.xhrFields) {\r\n              xhr[i] = options.xhrFields[i];\r\n            }\r\n          }\r\n\r\n          // Override mime type if needed\r\n          if (options.mimeType && xhr.overrideMimeType) {\r\n            xhr.overrideMimeType(options.mimeType);\r\n          }\r\n\r\n          // X-Requested-With header\r\n          // For cross-domain requests, seeing as conditions for a preflight are\r\n          // akin to a jigsaw puzzle, we simply never set it to be sure.\r\n          // (it can always be set on a per-request basis or even using ajaxSetup)\r\n          // For same-domain requests, won't change header if already provided.\r\n          if (!options.crossDomain && !headers['X-Requested-With']) {\r\n            headers['X-Requested-With'] = 'XMLHttpRequest';\r\n          }\r\n\r\n          // Set headers\r\n          for (i in headers) {\r\n            xhr.setRequestHeader(i, headers[i]);\r\n          }\r\n\r\n          // Callback\r\n          callback = function (type) {\r\n            return function () {\r\n              if (callback) {\r\n                callback =\r\n                  errorCallback =\r\n                  xhr.onload =\r\n                  xhr.onerror =\r\n                  xhr.onabort =\r\n                  xhr.ontimeout =\r\n                  xhr.onreadystatechange =\r\n                    null;\r\n\r\n                if (type === 'abort') {\r\n                  xhr.abort();\r\n                } else if (type === 'error') {\r\n                  // Support: IE <=9 only\r\n                  // On a manual native abort, IE9 throws\r\n                  // errors on any property access that is not readyState\r\n                  if (typeof xhr.status !== 'number') {\r\n                    complete(0, 'error');\r\n                  } else {\r\n                    complete(\r\n                      // File: protocol always yields status 0; see trac-8605, trac-14207\r\n                      xhr.status,\r\n                      xhr.statusText,\r\n                    );\r\n                  }\r\n                } else {\r\n                  complete(\r\n                    xhrSuccessStatus[xhr.status] || xhr.status,\r\n                    xhr.statusText,\r\n\r\n                    // Support: IE <=9 only\r\n                    // IE9 has no XHR2 but throws on binary (trac-11426)\r\n                    // For XHR2 non-text, let the caller handle it (gh-2498)\r\n                    (xhr.responseType || 'text') !== 'text' || typeof xhr.responseText !== 'string'\r\n                      ? { binary: xhr.response }\r\n                      : { text: xhr.responseText },\r\n                    xhr.getAllResponseHeaders(),\r\n                  );\r\n                }\r\n              }\r\n            };\r\n          };\r\n\r\n          // Listen to events\r\n          xhr.onload = callback();\r\n          errorCallback = xhr.onerror = xhr.ontimeout = callback('error');\r\n\r\n          // Support: IE 9 only\r\n          // Use onreadystatechange to replace onabort\r\n          // to handle uncaught aborts\r\n          if (xhr.onabort !== undefined) {\r\n            xhr.onabort = errorCallback;\r\n          } else {\r\n            xhr.onreadystatechange = function () {\r\n              // Check readyState before timeout as it changes\r\n              if (xhr.readyState === 4) {\r\n                // Allow onerror to be called first,\r\n                // but that will not handle a native abort\r\n                // Also, save errorCallback to a variable\r\n                // as xhr.onerror cannot be accessed\r\n                window.setTimeout(function () {\r\n                  if (callback) {\r\n                    errorCallback();\r\n                  }\r\n                });\r\n              }\r\n            };\r\n          }\r\n\r\n          // Create the abort callback\r\n          callback = callback('abort');\r\n\r\n          try {\r\n            // Do send the request (this may raise an exception)\r\n            xhr.send((options.hasContent && options.data) || null);\r\n          } catch (e) {\r\n            // trac-14683: Only rethrow if this hasn't been notified as an error yet\r\n            if (callback) {\r\n              throw e;\r\n            }\r\n          }\r\n        },\r\n\r\n        abort: function () {\r\n          if (callback) {\r\n            callback();\r\n          }\r\n        },\r\n      };\r\n    }\r\n  });\r\n\r\n  // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\r\n  jQuery.ajaxPrefilter(function (s) {\r\n    if (s.crossDomain) {\r\n      s.contents.script = false;\r\n    }\r\n  });\r\n\r\n  // Install script dataType\r\n  jQuery.ajaxSetup({\r\n    accepts: {\r\n      script:\r\n        'text/javascript, application/javascript, ' +\r\n        'application/ecmascript, application/x-ecmascript',\r\n    },\r\n    contents: {\r\n      script: /\\b(?:java|ecma)script\\b/,\r\n    },\r\n    converters: {\r\n      'text script': function (text) {\r\n        jQuery.globalEval(text);\r\n        return text;\r\n      },\r\n    },\r\n  });\r\n\r\n  // Handle cache's special case and crossDomain\r\n  jQuery.ajaxPrefilter('script', function (s) {\r\n    if (s.cache === undefined) {\r\n      s.cache = false;\r\n    }\r\n    if (s.crossDomain) {\r\n      s.type = 'GET';\r\n    }\r\n  });\r\n\r\n  // Bind script tag hack transport\r\n  jQuery.ajaxTransport('script', function (s) {\r\n    // This transport only deals with cross domain or forced-by-attrs requests\r\n    if (s.crossDomain || s.scriptAttrs) {\r\n      var script, callback;\r\n      return {\r\n        send: function (_, complete) {\r\n          script = jQuery('<script>')\r\n            .attr(s.scriptAttrs || {})\r\n            .prop({ charset: s.scriptCharset, src: s.url })\r\n            .on(\r\n              'load error',\r\n              (callback = function (evt) {\r\n                script.remove();\r\n                callback = null;\r\n                if (evt) {\r\n                  complete(evt.type === 'error' ? 404 : 200, evt.type);\r\n                }\r\n              }),\r\n            );\r\n\r\n          // Use native DOM manipulation to avoid our domManip AJAX trickery\r\n          document.head.appendChild(script[0]);\r\n        },\r\n        abort: function () {\r\n          if (callback) {\r\n            callback();\r\n          }\r\n        },\r\n      };\r\n    }\r\n  });\r\n\r\n  var oldCallbacks = [],\r\n    rjsonp = /(=)\\?(?=&|$)|\\?\\?/;\r\n\r\n  // Default jsonp settings\r\n  jQuery.ajaxSetup({\r\n    jsonp: 'callback',\r\n    jsonpCallback: function () {\r\n      var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce.guid++;\r\n      this[callback] = true;\r\n      return callback;\r\n    },\r\n  });\r\n\r\n  // Detect, normalize options and install callbacks for jsonp requests\r\n  jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {\r\n    var callbackName,\r\n      overwritten,\r\n      responseContainer,\r\n      jsonProp =\r\n        s.jsonp !== false &&\r\n        (rjsonp.test(s.url)\r\n          ? 'url'\r\n          : typeof s.data === 'string' &&\r\n            (s.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 &&\r\n            rjsonp.test(s.data) &&\r\n            'data');\r\n\r\n    // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\r\n    if (jsonProp || s.dataTypes[0] === 'jsonp') {\r\n      // Get callback name, remembering preexisting value associated with it\r\n      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback)\r\n        ? s.jsonpCallback()\r\n        : s.jsonpCallback;\r\n\r\n      // Insert callback into url or form data\r\n      if (jsonProp) {\r\n        s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);\r\n      } else if (s.jsonp !== false) {\r\n        s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;\r\n      }\r\n\r\n      // Use data converter to retrieve json after script execution\r\n      s.converters['script json'] = function () {\r\n        if (!responseContainer) {\r\n          jQuery.error(callbackName + ' was not called');\r\n        }\r\n        return responseContainer[0];\r\n      };\r\n\r\n      // Force json dataType\r\n      s.dataTypes[0] = 'json';\r\n\r\n      // Install callback\r\n      overwritten = window[callbackName];\r\n      window[callbackName] = function () {\r\n        responseContainer = arguments;\r\n      };\r\n\r\n      // Clean-up function (fires after converters)\r\n      jqXHR.always(function () {\r\n        // If previous value didn't exist - remove it\r\n        if (overwritten === undefined) {\r\n          jQuery(window).removeProp(callbackName);\r\n\r\n          // Otherwise restore preexisting value\r\n        } else {\r\n          window[callbackName] = overwritten;\r\n        }\r\n\r\n        // Save back as free\r\n        if (s[callbackName]) {\r\n          // Make sure that re-using the options doesn't screw things around\r\n          s.jsonpCallback = originalSettings.jsonpCallback;\r\n\r\n          // Save the callback name for future use\r\n          oldCallbacks.push(callbackName);\r\n        }\r\n\r\n        // Call if it was a function and we have a response\r\n        if (responseContainer && isFunction(overwritten)) {\r\n          overwritten(responseContainer[0]);\r\n        }\r\n\r\n        responseContainer = overwritten = undefined;\r\n      });\r\n\r\n      // Delegate to script\r\n      return 'script';\r\n    }\r\n  });\r\n\r\n  // Support: Safari 8 only\r\n  // In Safari 8 documents created via document.implementation.createHTMLDocument\r\n  // collapse sibling forms: the second one becomes a child of the first one.\r\n  // Because of that, this security measure has to be disabled in Safari 8.\r\n  // https://bugs.webkit.org/show_bug.cgi?id=137337\r\n  support.createHTMLDocument = (function () {\r\n    var body = document.implementation.createHTMLDocument('').body;\r\n    body.innerHTML = '<form></form><form></form>';\r\n    return body.childNodes.length === 2;\r\n  })();\r\n\r\n  // Argument \"data\" should be string of html\r\n  // context (optional): If specified, the fragment will be created in this context,\r\n  // defaults to document\r\n  // keepScripts (optional): If true, will include scripts passed in the html string\r\n  jQuery.parseHTML = function (data, context, keepScripts) {\r\n    if (typeof data !== 'string') {\r\n      return [];\r\n    }\r\n    if (typeof context === 'boolean') {\r\n      keepScripts = context;\r\n      context = false;\r\n    }\r\n\r\n    var base, parsed, scripts;\r\n\r\n    if (!context) {\r\n      // Stop scripts or inline event handlers from being executed immediately\r\n      // by using document.implementation\r\n      if (support.createHTMLDocument) {\r\n        context = document.implementation.createHTMLDocument('');\r\n\r\n        // Set the base href for the created document\r\n        // so any parsed elements with URLs\r\n        // are based on the document's URL (gh-2965)\r\n        base = context.createElement('base');\r\n        base.href = document.location.href;\r\n        context.head.appendChild(base);\r\n      } else {\r\n        context = document;\r\n      }\r\n    }\r\n\r\n    parsed = rsingleTag.exec(data);\r\n    scripts = !keepScripts && [];\r\n\r\n    // Single tag\r\n    if (parsed) {\r\n      return [context.createElement(parsed[1])];\r\n    }\r\n\r\n    parsed = buildFragment([data], context, scripts);\r\n\r\n    if (scripts && scripts.length) {\r\n      jQuery(scripts).remove();\r\n    }\r\n\r\n    return jQuery.merge([], parsed.childNodes);\r\n  };\r\n\r\n  /**\r\n   * Load a url into a page\r\n   */\r\n  jQuery.fn.load = function (url, params, callback) {\r\n    var selector,\r\n      type,\r\n      response,\r\n      self = this,\r\n      off = url.indexOf(' ');\r\n\r\n    if (off > -1) {\r\n      selector = stripAndCollapse(url.slice(off));\r\n      url = url.slice(0, off);\r\n    }\r\n\r\n    // If it's a function\r\n    if (isFunction(params)) {\r\n      // We assume that it's the callback\r\n      callback = params;\r\n      params = undefined;\r\n\r\n      // Otherwise, build a param string\r\n    } else if (params && typeof params === 'object') {\r\n      type = 'POST';\r\n    }\r\n\r\n    // If we have elements to modify, make the request\r\n    if (self.length > 0) {\r\n      jQuery\r\n        .ajax({\r\n          url: url,\r\n\r\n          // If \"type\" variable is undefined, then \"GET\" method will be used.\r\n          // Make value of this field explicit since\r\n          // user can override it through ajaxSetup method\r\n          type: type || 'GET',\r\n          dataType: 'html',\r\n          data: params,\r\n        })\r\n        .done(function (responseText) {\r\n          // Save response for use in complete callback\r\n          response = arguments;\r\n\r\n          self.html(\r\n            selector\r\n              ? // If a selector was specified, locate the right elements in a dummy div\r\n                // Exclude scripts to avoid IE 'Permission Denied' errors\r\n                jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector)\r\n              : // Otherwise use the full result\r\n                responseText,\r\n          );\r\n\r\n          // If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\r\n          // but they are ignored because response was set above.\r\n          // If it fails, this function gets \"jqXHR\", \"status\", \"error\"\r\n        })\r\n        .always(\r\n          callback &&\r\n            function (jqXHR, status) {\r\n              self.each(function () {\r\n                callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);\r\n              });\r\n            },\r\n        );\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  jQuery.expr.pseudos.animated = function (elem) {\r\n    return jQuery.grep(jQuery.timers, function (fn) {\r\n      return elem === fn.elem;\r\n    }).length;\r\n  };\r\n\r\n  jQuery.offset = {\r\n    setOffset: function (elem, options, i) {\r\n      var curPosition,\r\n        curLeft,\r\n        curCSSTop,\r\n        curTop,\r\n        curOffset,\r\n        curCSSLeft,\r\n        calculatePosition,\r\n        position = jQuery.css(elem, 'position'),\r\n        curElem = jQuery(elem),\r\n        props = {};\r\n\r\n      // Set position first, in-case top/left are set even on static elem\r\n      if (position === 'static') {\r\n        elem.style.position = 'relative';\r\n      }\r\n\r\n      curOffset = curElem.offset();\r\n      curCSSTop = jQuery.css(elem, 'top');\r\n      curCSSLeft = jQuery.css(elem, 'left');\r\n      calculatePosition =\r\n        (position === 'absolute' || position === 'fixed') &&\r\n        (curCSSTop + curCSSLeft).indexOf('auto') > -1;\r\n\r\n      // Need to be able to calculate position if either\r\n      // top or left is auto and position is either absolute or fixed\r\n      if (calculatePosition) {\r\n        curPosition = curElem.position();\r\n        curTop = curPosition.top;\r\n        curLeft = curPosition.left;\r\n      } else {\r\n        curTop = parseFloat(curCSSTop) || 0;\r\n        curLeft = parseFloat(curCSSLeft) || 0;\r\n      }\r\n\r\n      if (isFunction(options)) {\r\n        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\r\n        options = options.call(elem, i, jQuery.extend({}, curOffset));\r\n      }\r\n\r\n      if (options.top != null) {\r\n        props.top = options.top - curOffset.top + curTop;\r\n      }\r\n      if (options.left != null) {\r\n        props.left = options.left - curOffset.left + curLeft;\r\n      }\r\n\r\n      if ('using' in options) {\r\n        options.using.call(elem, props);\r\n      } else {\r\n        curElem.css(props);\r\n      }\r\n    },\r\n  };\r\n\r\n  jQuery.fn.extend({\r\n    // offset() relates an element's border box to the document origin\r\n    offset: function (options) {\r\n      // Preserve chaining for setter\r\n      if (arguments.length) {\r\n        return options === undefined\r\n          ? this\r\n          : this.each(function (i) {\r\n              jQuery.offset.setOffset(this, options, i);\r\n            });\r\n      }\r\n\r\n      var rect,\r\n        win,\r\n        elem = this[0];\r\n\r\n      if (!elem) {\r\n        return;\r\n      }\r\n\r\n      // Return zeros for disconnected and hidden (display: none) elements (gh-2310)\r\n      // Support: IE <=11 only\r\n      // Running getBoundingClientRect on a\r\n      // disconnected node in IE throws an error\r\n      if (!elem.getClientRects().length) {\r\n        return { top: 0, left: 0 };\r\n      }\r\n\r\n      // Get document-relative position by adding viewport scroll to viewport-relative gBCR\r\n      rect = elem.getBoundingClientRect();\r\n      win = elem.ownerDocument.defaultView;\r\n      return {\r\n        top: rect.top + win.pageYOffset,\r\n        left: rect.left + win.pageXOffset,\r\n      };\r\n    },\r\n\r\n    // position() relates an element's margin box to its offset parent's padding box\r\n    // This corresponds to the behavior of CSS absolute positioning\r\n    position: function () {\r\n      if (!this[0]) {\r\n        return;\r\n      }\r\n\r\n      var offsetParent,\r\n        offset,\r\n        doc,\r\n        elem = this[0],\r\n        parentOffset = { top: 0, left: 0 };\r\n\r\n      // position:fixed elements are offset from the viewport, which itself always has zero offset\r\n      if (jQuery.css(elem, 'position') === 'fixed') {\r\n        // Assume position:fixed implies availability of getBoundingClientRect\r\n        offset = elem.getBoundingClientRect();\r\n      } else {\r\n        offset = this.offset();\r\n\r\n        // Account for the *real* offset parent, which can be the document or its root element\r\n        // when a statically positioned element is identified\r\n        doc = elem.ownerDocument;\r\n        offsetParent = elem.offsetParent || doc.documentElement;\r\n        while (\r\n          offsetParent &&\r\n          (offsetParent === doc.body || offsetParent === doc.documentElement) &&\r\n          jQuery.css(offsetParent, 'position') === 'static'\r\n        ) {\r\n          offsetParent = offsetParent.parentNode;\r\n        }\r\n        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {\r\n          // Incorporate borders into its offset, since they are outside its content origin\r\n          parentOffset = jQuery(offsetParent).offset();\r\n          parentOffset.top += jQuery.css(offsetParent, 'borderTopWidth', true);\r\n          parentOffset.left += jQuery.css(offsetParent, 'borderLeftWidth', true);\r\n        }\r\n      }\r\n\r\n      // Subtract parent offsets and element margins\r\n      return {\r\n        top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),\r\n        left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true),\r\n      };\r\n    },\r\n\r\n    // This method will return documentElement in the following cases:\r\n    // 1) For the element inside the iframe without offsetParent, this method will return\r\n    //    documentElement of the parent window\r\n    // 2) For the hidden or detached element\r\n    // 3) For body or html element, i.e. in case of the html node - it will return itself\r\n    //\r\n    // but those exceptions were never presented as a real life use-cases\r\n    // and might be considered as more preferable results.\r\n    //\r\n    // This logic, however, is not guaranteed and can change at any point in the future\r\n    offsetParent: function () {\r\n      return this.map(function () {\r\n        var offsetParent = this.offsetParent;\r\n\r\n        while (offsetParent && jQuery.css(offsetParent, 'position') === 'static') {\r\n          offsetParent = offsetParent.offsetParent;\r\n        }\r\n\r\n        return offsetParent || documentElement;\r\n      });\r\n    },\r\n  });\r\n\r\n  // Create scrollLeft and scrollTop methods\r\n  jQuery.each({ scrollLeft: 'pageXOffset', scrollTop: 'pageYOffset' }, function (method, prop) {\r\n    var top = 'pageYOffset' === prop;\r\n\r\n    jQuery.fn[method] = function (val) {\r\n      return access(\r\n        this,\r\n        function (elem, method, val) {\r\n          // Coalesce documents and windows\r\n          var win;\r\n          if (isWindow(elem)) {\r\n            win = elem;\r\n          } else if (elem.nodeType === 9) {\r\n            win = elem.defaultView;\r\n          }\r\n\r\n          if (val === undefined) {\r\n            return win ? win[prop] : elem[method];\r\n          }\r\n\r\n          if (win) {\r\n            win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);\r\n          } else {\r\n            elem[method] = val;\r\n          }\r\n        },\r\n        method,\r\n        val,\r\n        arguments.length,\r\n      );\r\n    };\r\n  });\r\n\r\n  // Support: Safari <=7 - 9.1, Chrome <=37 - 49\r\n  // Add the top/left cssHooks using jQuery.fn.position\r\n  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\r\n  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\r\n  // getComputedStyle returns percent when specified for top/left/bottom/right;\r\n  // rather than make the css module depend on the offset module, just check for it here\r\n  jQuery.each(['top', 'left'], function (_i, prop) {\r\n    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\r\n      if (computed) {\r\n        computed = curCSS(elem, prop);\r\n\r\n        // If curCSS returns percentage, fallback to offset\r\n        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;\r\n      }\r\n    });\r\n  });\r\n\r\n  // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\r\n  jQuery.each({ Height: 'height', Width: 'width' }, function (name, type) {\r\n    jQuery.each(\r\n      {\r\n        padding: 'inner' + name,\r\n        content: type,\r\n        '': 'outer' + name,\r\n      },\r\n      function (defaultExtra, funcName) {\r\n        // Margin is only for outerHeight, outerWidth\r\n        jQuery.fn[funcName] = function (margin, value) {\r\n          var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'),\r\n            extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');\r\n\r\n          return access(\r\n            this,\r\n            function (elem, type, value) {\r\n              var doc;\r\n\r\n              if (isWindow(elem)) {\r\n                // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\r\n                return funcName.indexOf('outer') === 0\r\n                  ? elem['inner' + name]\r\n                  : elem.document.documentElement['client' + name];\r\n              }\r\n\r\n              // Get document width or height\r\n              if (elem.nodeType === 9) {\r\n                doc = elem.documentElement;\r\n\r\n                // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\r\n                // whichever is greatest\r\n                return Math.max(\r\n                  elem.body['scroll' + name],\r\n                  doc['scroll' + name],\r\n                  elem.body['offset' + name],\r\n                  doc['offset' + name],\r\n                  doc['client' + name],\r\n                );\r\n              }\r\n\r\n              return value === undefined\r\n                ? // Get width or height on the element, requesting but not forcing parseFloat\r\n                  jQuery.css(elem, type, extra)\r\n                : // Set width or height on the element\r\n                  jQuery.style(elem, type, value, extra);\r\n            },\r\n            type,\r\n            chainable ? margin : undefined,\r\n            chainable,\r\n          );\r\n        };\r\n      },\r\n    );\r\n  });\r\n\r\n  jQuery.each(\r\n    ['ajaxStart', 'ajaxStop', 'ajaxComplete', 'ajaxError', 'ajaxSuccess', 'ajaxSend'],\r\n    function (_i, type) {\r\n      jQuery.fn[type] = function (fn) {\r\n        return this.on(type, fn);\r\n      };\r\n    },\r\n  );\r\n\r\n  jQuery.fn.extend({\r\n    bind: function (types, data, fn) {\r\n      return this.on(types, null, data, fn);\r\n    },\r\n    unbind: function (types, fn) {\r\n      return this.off(types, null, fn);\r\n    },\r\n\r\n    delegate: function (selector, types, data, fn) {\r\n      return this.on(types, selector, data, fn);\r\n    },\r\n    undelegate: function (selector, types, fn) {\r\n      // ( namespace ) or ( selector, types [, fn] )\r\n      return arguments.length === 1\r\n        ? this.off(selector, '**')\r\n        : this.off(types, selector || '**', fn);\r\n    },\r\n\r\n    hover: function (fnOver, fnOut) {\r\n      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\r\n    },\r\n  });\r\n\r\n  jQuery.each(\r\n    (\r\n      'blur focus focusin focusout resize scroll click dblclick ' +\r\n      'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' +\r\n      'change select submit keydown keypress keyup contextmenu'\r\n    ).split(' '),\r\n    function (_i, name) {\r\n      // Handle event binding\r\n      jQuery.fn[name] = function (data, fn) {\r\n        return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\r\n      };\r\n    },\r\n  );\r\n\r\n  // Support: Android <=4.0 only\r\n  // Make sure we trim BOM and NBSP\r\n  // Require that the \"whitespace run\" starts from a non-whitespace\r\n  // to avoid O(N^2) behavior when the engine would try matching \"\\s+$\" at each space position.\r\n  var rtrim = /^[\\s\\uFEFF\\xA0]+|([^\\s\\uFEFF\\xA0])[\\s\\uFEFF\\xA0]+$/g;\r\n\r\n  // Bind a function to a context, optionally partially applying any\r\n  // arguments.\r\n  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)\r\n  // However, it is not slated for removal any time soon\r\n  jQuery.proxy = function (fn, context) {\r\n    var tmp, args, proxy;\r\n\r\n    if (typeof context === 'string') {\r\n      tmp = fn[context];\r\n      context = fn;\r\n      fn = tmp;\r\n    }\r\n\r\n    // Quick check to determine if target is callable, in the spec\r\n    // this throws a TypeError, but we will just return undefined.\r\n    if (!isFunction(fn)) {\r\n      return undefined;\r\n    }\r\n\r\n    // Simulated bind\r\n    args = slice.call(arguments, 2);\r\n    proxy = function () {\r\n      return fn.apply(context || this, args.concat(slice.call(arguments)));\r\n    };\r\n\r\n    // Set the guid of unique handler to the same of original handler, so it can be removed\r\n    proxy.guid = fn.guid = fn.guid || jQuery.guid++;\r\n\r\n    return proxy;\r\n  };\r\n\r\n  jQuery.holdReady = function (hold) {\r\n    if (hold) {\r\n      jQuery.readyWait++;\r\n    } else {\r\n      jQuery.ready(true);\r\n    }\r\n  };\r\n  jQuery.isArray = Array.isArray;\r\n  jQuery.parseJSON = JSON.parse;\r\n  jQuery.nodeName = nodeName;\r\n  jQuery.isFunction = isFunction;\r\n  jQuery.isWindow = isWindow;\r\n  jQuery.camelCase = camelCase;\r\n  jQuery.type = toType;\r\n\r\n  jQuery.now = Date.now;\r\n\r\n  jQuery.isNumeric = function (obj) {\r\n    // As of jQuery 3.0, isNumeric is limited to\r\n    // strings and numbers (primitives or objects)\r\n    // that can be coerced to finite numbers (gh-2662)\r\n    var type = jQuery.type(obj);\r\n    return (\r\n      (type === 'number' || type === 'string') &&\r\n      // parseFloat NaNs numeric-cast false positives (\"\")\r\n      // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\r\n      // subtraction forces infinities to NaN\r\n      !isNaN(obj - parseFloat(obj))\r\n    );\r\n  };\r\n\r\n  jQuery.trim = function (text) {\r\n    return text == null ? '' : (text + '').replace(rtrim, '$1');\r\n  };\r\n\r\n  // Register as a named AMD module, since jQuery can be concatenated with other\r\n  // files that may use define, but not via a proper concatenation script that\r\n  // understands anonymous AMD modules. A named AMD is safest and most robust\r\n  // way to register. Lowercase jquery is used because AMD module names are\r\n  // derived from file names, and jQuery is normally delivered in a lowercase\r\n  // file name. Do this after creating the global so that if an AMD module wants\r\n  // to call noConflict to hide this version of jQuery, it will work.\r\n\r\n  // Note that for maximum portability, libraries that are not jQuery should\r\n  // declare themselves as anonymous modules, and avoid setting a global if an\r\n  // AMD loader is present. jQuery is a special case. For more information, see\r\n  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\r\n\r\n  if (typeof define === 'function' && define.amd) {\r\n    define('jquery', [], function () {\r\n      return jQuery;\r\n    });\r\n  }\r\n\r\n  var // Map over jQuery in case of overwrite\r\n    _jQuery = window.jQuery,\r\n    // Map over the $ in case of overwrite\r\n    _$ = window.$;\r\n\r\n  jQuery.noConflict = function (deep) {\r\n    if (window.$ === jQuery) {\r\n      window.$ = _$;\r\n    }\r\n\r\n    if (deep && window.jQuery === jQuery) {\r\n      window.jQuery = _jQuery;\r\n    }\r\n\r\n    return jQuery;\r\n  };\r\n\r\n  // Expose jQuery and $ identifiers, even in AMD\r\n  // (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)\r\n  // and CommonJS for browser emulators (trac-13566)\r\n  if (typeof noGlobal === 'undefined') {\r\n    window.jQuery = window.$ = jQuery;\r\n  }\r\n\r\n  return jQuery;\r\n})};\r\n\n\n//# sourceURL=webpack://gulp_2023/./src/js/modules/jquery.js?");

/***/ }),

/***/ "./src/js/modules/slic-slider.js":
/*!***************************************!*\
  !*** ./src/js/modules/slic-slider.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"slicSlider\": () => (/* binding */ slicSlider)\n/* harmony export */ });\nfunction slicSlider(){(function(factory) {\r\n   'use strict';\r\n   if (typeof define === 'function' && define.amd) {\r\n       define(['jquery'], factory);\r\n   } else if (typeof exports !== 'undefined') {\r\n       module.exports = factory(require('jquery'));\r\n   } else {\r\n       factory(jQuery);\r\n   }\r\n\r\n}(function($) {\r\n   'use strict';\r\n   var Slick = window.Slick || {};\r\n\r\n   Slick = (function() {\r\n\r\n       var instanceUid = 0;\r\n\r\n       function Slick(element, settings) {\r\n\r\n           var _ = this, dataSettings;\r\n\r\n           _.defaults = {\r\n               accessibility: true,\r\n               adaptiveHeight: false,\r\n               appendArrows: $(element),\r\n               appendDots: $(element),\r\n               arrows: true,\r\n               asNavFor: null,\r\n               prevArrow: '<button class=\"slick-prev\" aria-label=\"Previous\" type=\"button\">Previous</button>',\r\n               nextArrow: '<button class=\"slick-next\" aria-label=\"Next\" type=\"button\">Next</button>',\r\n               autoplay: false,\r\n               autoplaySpeed: 3000,\r\n               centerMode: false,\r\n               centerPadding: '50px',\r\n               cssEase: 'ease',\r\n               customPaging: function(slider, i) {\r\n                   return $('<button type=\"button\" />').text(i + 1);\r\n               },\r\n               dots: false,\r\n               dotsClass: 'slick-dots',\r\n               draggable: true,\r\n               easing: 'linear',\r\n               edgeFriction: 0.35,\r\n               fade: false,\r\n               focusOnSelect: false,\r\n               focusOnChange: false,\r\n               infinite: true,\r\n               initialSlide: 0,\r\n               lazyLoad: 'ondemand',\r\n               mobileFirst: false,\r\n               pauseOnHover: true,\r\n               pauseOnFocus: true,\r\n               pauseOnDotsHover: false,\r\n               respondTo: 'window',\r\n               responsive: null,\r\n               rows: 1,\r\n               rtl: false,\r\n               slide: '',\r\n               slidesPerRow: 1,\r\n               slidesToShow: 1,\r\n               slidesToScroll: 1,\r\n               speed: 500,\r\n               swipe: true,\r\n               swipeToSlide: false,\r\n               touchMove: true,\r\n               touchThreshold: 5,\r\n               useCSS: true,\r\n               useTransform: true,\r\n               variableWidth: false,\r\n               vertical: false,\r\n               verticalSwiping: false,\r\n               waitForAnimate: true,\r\n               zIndex: 1000\r\n           };\r\n\r\n           _.initials = {\r\n               animating: false,\r\n               dragging: false,\r\n               autoPlayTimer: null,\r\n               currentDirection: 0,\r\n               currentLeft: null,\r\n               currentSlide: 0,\r\n               direction: 1,\r\n               $dots: null,\r\n               listWidth: null,\r\n               listHeight: null,\r\n               loadIndex: 0,\r\n               $nextArrow: null,\r\n               $prevArrow: null,\r\n               scrolling: false,\r\n               slideCount: null,\r\n               slideWidth: null,\r\n               $slideTrack: null,\r\n               $slides: null,\r\n               sliding: false,\r\n               slideOffset: 0,\r\n               swipeLeft: null,\r\n               swiping: false,\r\n               $list: null,\r\n               touchObject: {},\r\n               transformsEnabled: false,\r\n               unslicked: false\r\n           };\r\n\r\n           $.extend(_, _.initials);\r\n\r\n           _.activeBreakpoint = null;\r\n           _.animType = null;\r\n           _.animProp = null;\r\n           _.breakpoints = [];\r\n           _.breakpointSettings = [];\r\n           _.cssTransitions = false;\r\n           _.focussed = false;\r\n           _.interrupted = false;\r\n           _.hidden = 'hidden';\r\n           _.paused = true;\r\n           _.positionProp = null;\r\n           _.respondTo = null;\r\n           _.rowCount = 1;\r\n           _.shouldClick = true;\r\n           _.$slider = $(element);\r\n           _.$slidesCache = null;\r\n           _.transformType = null;\r\n           _.transitionType = null;\r\n           _.visibilityChange = 'visibilitychange';\r\n           _.windowWidth = 0;\r\n           _.windowTimer = null;\r\n\r\n           dataSettings = $(element).data('slick') || {};\r\n\r\n           _.options = $.extend({}, _.defaults, settings, dataSettings);\r\n\r\n           _.currentSlide = _.options.initialSlide;\r\n\r\n           _.originalSettings = _.options;\r\n\r\n           if (typeof document.mozHidden !== 'undefined') {\r\n               _.hidden = 'mozHidden';\r\n               _.visibilityChange = 'mozvisibilitychange';\r\n           } else if (typeof document.webkitHidden !== 'undefined') {\r\n               _.hidden = 'webkitHidden';\r\n               _.visibilityChange = 'webkitvisibilitychange';\r\n           }\r\n\r\n           _.autoPlay = $.proxy(_.autoPlay, _);\r\n           _.autoPlayClear = $.proxy(_.autoPlayClear, _);\r\n           _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);\r\n           _.changeSlide = $.proxy(_.changeSlide, _);\r\n           _.clickHandler = $.proxy(_.clickHandler, _);\r\n           _.selectHandler = $.proxy(_.selectHandler, _);\r\n           _.setPosition = $.proxy(_.setPosition, _);\r\n           _.swipeHandler = $.proxy(_.swipeHandler, _);\r\n           _.dragHandler = $.proxy(_.dragHandler, _);\r\n           _.keyHandler = $.proxy(_.keyHandler, _);\r\n\r\n           _.instanceUid = instanceUid++;\r\n\r\n           // A simple way to check for HTML strings\r\n           // Strict HTML recognition (must start with <)\r\n           // Extracted from jQuery v1.11 source\r\n           _.htmlExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*)$/;\r\n\r\n\r\n           _.registerBreakpoints();\r\n           _.init(true);\r\n\r\n       }\r\n\r\n       return Slick;\r\n\r\n   }());\r\n\r\n   Slick.prototype.activateADA = function() {\r\n       var _ = this;\r\n\r\n       _.$slideTrack.find('.slick-active').attr({\r\n           'aria-hidden': 'false'\r\n       }).find('a, input, button, select').attr({\r\n           'tabindex': '0'\r\n       });\r\n\r\n   };\r\n\r\n   Slick.prototype.addSlide = Slick.prototype.slickAdd = function(markup, index, addBefore) {\r\n\r\n       var _ = this;\r\n\r\n       if (typeof(index) === 'boolean') {\r\n           addBefore = index;\r\n           index = null;\r\n       } else if (index < 0 || (index >= _.slideCount)) {\r\n           return false;\r\n       }\r\n\r\n       _.unload();\r\n\r\n       if (typeof(index) === 'number') {\r\n           if (index === 0 && _.$slides.length === 0) {\r\n               $(markup).appendTo(_.$slideTrack);\r\n           } else if (addBefore) {\r\n               $(markup).insertBefore(_.$slides.eq(index));\r\n           } else {\r\n               $(markup).insertAfter(_.$slides.eq(index));\r\n           }\r\n       } else {\r\n           if (addBefore === true) {\r\n               $(markup).prependTo(_.$slideTrack);\r\n           } else {\r\n               $(markup).appendTo(_.$slideTrack);\r\n           }\r\n       }\r\n\r\n       _.$slides = _.$slideTrack.children(this.options.slide);\r\n\r\n       _.$slideTrack.children(this.options.slide).detach();\r\n\r\n       _.$slideTrack.append(_.$slides);\r\n\r\n       _.$slides.each(function(index, element) {\r\n           $(element).attr('data-slick-index', index);\r\n       });\r\n\r\n       _.$slidesCache = _.$slides;\r\n\r\n       _.reinit();\r\n\r\n   };\r\n\r\n   Slick.prototype.animateHeight = function() {\r\n       var _ = this;\r\n       if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {\r\n           var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);\r\n           _.$list.animate({\r\n               height: targetHeight\r\n           }, _.options.speed);\r\n       }\r\n   };\r\n\r\n   Slick.prototype.animateSlide = function(targetLeft, callback) {\r\n\r\n       var animProps = {},\r\n           _ = this;\r\n\r\n       _.animateHeight();\r\n\r\n       if (_.options.rtl === true && _.options.vertical === false) {\r\n           targetLeft = -targetLeft;\r\n       }\r\n       if (_.transformsEnabled === false) {\r\n           if (_.options.vertical === false) {\r\n               _.$slideTrack.animate({\r\n                   left: targetLeft\r\n               }, _.options.speed, _.options.easing, callback);\r\n           } else {\r\n               _.$slideTrack.animate({\r\n                   top: targetLeft\r\n               }, _.options.speed, _.options.easing, callback);\r\n           }\r\n\r\n       } else {\r\n\r\n           if (_.cssTransitions === false) {\r\n               if (_.options.rtl === true) {\r\n                   _.currentLeft = -(_.currentLeft);\r\n               }\r\n               $({\r\n                   animStart: _.currentLeft\r\n               }).animate({\r\n                   animStart: targetLeft\r\n               }, {\r\n                   duration: _.options.speed,\r\n                   easing: _.options.easing,\r\n                   step: function(now) {\r\n                       now = Math.ceil(now);\r\n                       if (_.options.vertical === false) {\r\n                           animProps[_.animType] = 'translate(' +\r\n                               now + 'px, 0px)';\r\n                           _.$slideTrack.css(animProps);\r\n                       } else {\r\n                           animProps[_.animType] = 'translate(0px,' +\r\n                               now + 'px)';\r\n                           _.$slideTrack.css(animProps);\r\n                       }\r\n                   },\r\n                   complete: function() {\r\n                       if (callback) {\r\n                           callback.call();\r\n                       }\r\n                   }\r\n               });\r\n\r\n           } else {\r\n\r\n               _.applyTransition();\r\n               targetLeft = Math.ceil(targetLeft);\r\n\r\n               if (_.options.vertical === false) {\r\n                   animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';\r\n               } else {\r\n                   animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';\r\n               }\r\n               _.$slideTrack.css(animProps);\r\n\r\n               if (callback) {\r\n                   setTimeout(function() {\r\n\r\n                       _.disableTransition();\r\n\r\n                       callback.call();\r\n                   }, _.options.speed);\r\n               }\r\n\r\n           }\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.getNavTarget = function() {\r\n\r\n       var _ = this,\r\n           asNavFor = _.options.asNavFor;\r\n\r\n       if ( asNavFor && asNavFor !== null ) {\r\n           asNavFor = $(asNavFor).not(_.$slider);\r\n       }\r\n\r\n       return asNavFor;\r\n\r\n   };\r\n\r\n   Slick.prototype.asNavFor = function(index) {\r\n\r\n       var _ = this,\r\n           asNavFor = _.getNavTarget();\r\n\r\n       if ( asNavFor !== null && typeof asNavFor === 'object' ) {\r\n           asNavFor.each(function() {\r\n               var target = $(this).slick('getSlick');\r\n               if(!target.unslicked) {\r\n                   target.slideHandler(index, true);\r\n               }\r\n           });\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.applyTransition = function(slide) {\r\n\r\n       var _ = this,\r\n           transition = {};\r\n\r\n       if (_.options.fade === false) {\r\n           transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;\r\n       } else {\r\n           transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;\r\n       }\r\n\r\n       if (_.options.fade === false) {\r\n           _.$slideTrack.css(transition);\r\n       } else {\r\n           _.$slides.eq(slide).css(transition);\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.autoPlay = function() {\r\n\r\n       var _ = this;\r\n\r\n       _.autoPlayClear();\r\n\r\n       if ( _.slideCount > _.options.slidesToShow ) {\r\n           _.autoPlayTimer = setInterval( _.autoPlayIterator, _.options.autoplaySpeed );\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.autoPlayClear = function() {\r\n\r\n       var _ = this;\r\n\r\n       if (_.autoPlayTimer) {\r\n           clearInterval(_.autoPlayTimer);\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.autoPlayIterator = function() {\r\n\r\n       var _ = this,\r\n           slideTo = _.currentSlide + _.options.slidesToScroll;\r\n\r\n       if ( !_.paused && !_.interrupted && !_.focussed ) {\r\n\r\n           if ( _.options.infinite === false ) {\r\n\r\n               if ( _.direction === 1 && ( _.currentSlide + 1 ) === ( _.slideCount - 1 )) {\r\n                   _.direction = 0;\r\n               }\r\n\r\n               else if ( _.direction === 0 ) {\r\n\r\n                   slideTo = _.currentSlide - _.options.slidesToScroll;\r\n\r\n                   if ( _.currentSlide - 1 === 0 ) {\r\n                       _.direction = 1;\r\n                   }\r\n\r\n               }\r\n\r\n           }\r\n\r\n           _.slideHandler( slideTo );\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.buildArrows = function() {\r\n\r\n       var _ = this;\r\n\r\n       if (_.options.arrows === true ) {\r\n\r\n           _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');\r\n           _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');\r\n\r\n           if( _.slideCount > _.options.slidesToShow ) {\r\n\r\n               _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');\r\n               _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');\r\n\r\n               if (_.htmlExpr.test(_.options.prevArrow)) {\r\n                   _.$prevArrow.prependTo(_.options.appendArrows);\r\n               }\r\n\r\n               if (_.htmlExpr.test(_.options.nextArrow)) {\r\n                   _.$nextArrow.appendTo(_.options.appendArrows);\r\n               }\r\n\r\n               if (_.options.infinite !== true) {\r\n                   _.$prevArrow\r\n                       .addClass('slick-disabled')\r\n                       .attr('aria-disabled', 'true');\r\n               }\r\n\r\n           } else {\r\n\r\n               _.$prevArrow.add( _.$nextArrow )\r\n\r\n                   .addClass('slick-hidden')\r\n                   .attr({\r\n                       'aria-disabled': 'true',\r\n                       'tabindex': '-1'\r\n                   });\r\n\r\n           }\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.buildDots = function() {\r\n\r\n       var _ = this,\r\n           i, dot;\r\n\r\n       if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\r\n\r\n           _.$slider.addClass('slick-dotted');\r\n\r\n           dot = $('<ul />').addClass(_.options.dotsClass);\r\n\r\n           for (i = 0; i <= _.getDotCount(); i += 1) {\r\n               dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));\r\n           }\r\n\r\n           _.$dots = dot.appendTo(_.options.appendDots);\r\n\r\n           _.$dots.find('li').first().addClass('slick-active');\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.buildOut = function() {\r\n\r\n       var _ = this;\r\n\r\n       _.$slides =\r\n           _.$slider\r\n               .children( _.options.slide + ':not(.slick-cloned)')\r\n               .addClass('slick-slide');\r\n\r\n       _.slideCount = _.$slides.length;\r\n\r\n       _.$slides.each(function(index, element) {\r\n           $(element)\r\n               .attr('data-slick-index', index)\r\n               .data('originalStyling', $(element).attr('style') || '');\r\n       });\r\n\r\n       _.$slider.addClass('slick-slider');\r\n\r\n       _.$slideTrack = (_.slideCount === 0) ?\r\n           $('<div class=\"slick-track\"/>').appendTo(_.$slider) :\r\n           _.$slides.wrapAll('<div class=\"slick-track\"/>').parent();\r\n\r\n       _.$list = _.$slideTrack.wrap(\r\n           '<div class=\"slick-list\"/>').parent();\r\n       _.$slideTrack.css('opacity', 0);\r\n\r\n       if (_.options.centerMode === true || _.options.swipeToSlide === true) {\r\n           _.options.slidesToScroll = 1;\r\n       }\r\n\r\n       $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');\r\n\r\n       _.setupInfinite();\r\n\r\n       _.buildArrows();\r\n\r\n       _.buildDots();\r\n\r\n       _.updateDots();\r\n\r\n\r\n       _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);\r\n\r\n       if (_.options.draggable === true) {\r\n           _.$list.addClass('draggable');\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.buildRows = function() {\r\n\r\n       var _ = this, a, b, c, newSlides, numOfSlides, originalSlides,slidesPerSection;\r\n\r\n       newSlides = document.createDocumentFragment();\r\n       originalSlides = _.$slider.children();\r\n\r\n       if(_.options.rows > 0) {\r\n\r\n           slidesPerSection = _.options.slidesPerRow * _.options.rows;\r\n           numOfSlides = Math.ceil(\r\n               originalSlides.length / slidesPerSection\r\n           );\r\n\r\n           for(a = 0; a < numOfSlides; a++){\r\n               var slide = document.createElement('div');\r\n               for(b = 0; b < _.options.rows; b++) {\r\n                   var row = document.createElement('div');\r\n                   for(c = 0; c < _.options.slidesPerRow; c++) {\r\n                       var target = (a * slidesPerSection + ((b * _.options.slidesPerRow) + c));\r\n                       if (originalSlides.get(target)) {\r\n                           row.appendChild(originalSlides.get(target));\r\n                       }\r\n                   }\r\n                   slide.appendChild(row);\r\n               }\r\n               newSlides.appendChild(slide);\r\n           }\r\n\r\n           _.$slider.empty().append(newSlides);\r\n           _.$slider.children().children().children()\r\n               .css({\r\n                   'width':(100 / _.options.slidesPerRow) + '%',\r\n                   'display': 'inline-block'\r\n               });\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.checkResponsive = function(initial, forceUpdate) {\r\n\r\n       var _ = this,\r\n           breakpoint, targetBreakpoint, respondToWidth, triggerBreakpoint = false;\r\n       var sliderWidth = _.$slider.width();\r\n       var windowWidth = window.innerWidth || $(window).width();\r\n\r\n       if (_.respondTo === 'window') {\r\n           respondToWidth = windowWidth;\r\n       } else if (_.respondTo === 'slider') {\r\n           respondToWidth = sliderWidth;\r\n       } else if (_.respondTo === 'min') {\r\n           respondToWidth = Math.min(windowWidth, sliderWidth);\r\n       }\r\n\r\n       if ( _.options.responsive &&\r\n           _.options.responsive.length &&\r\n           _.options.responsive !== null) {\r\n\r\n           targetBreakpoint = null;\r\n\r\n           for (breakpoint in _.breakpoints) {\r\n               if (_.breakpoints.hasOwnProperty(breakpoint)) {\r\n                   if (_.originalSettings.mobileFirst === false) {\r\n                       if (respondToWidth < _.breakpoints[breakpoint]) {\r\n                           targetBreakpoint = _.breakpoints[breakpoint];\r\n                       }\r\n                   } else {\r\n                       if (respondToWidth > _.breakpoints[breakpoint]) {\r\n                           targetBreakpoint = _.breakpoints[breakpoint];\r\n                       }\r\n                   }\r\n               }\r\n           }\r\n\r\n           if (targetBreakpoint !== null) {\r\n               if (_.activeBreakpoint !== null) {\r\n                   if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {\r\n                       _.activeBreakpoint =\r\n                           targetBreakpoint;\r\n                       if (_.breakpointSettings[targetBreakpoint] === 'unslick') {\r\n                           _.unslick(targetBreakpoint);\r\n                       } else {\r\n                           _.options = $.extend({}, _.originalSettings,\r\n                               _.breakpointSettings[\r\n                                   targetBreakpoint]);\r\n                           if (initial === true) {\r\n                               _.currentSlide = _.options.initialSlide;\r\n                           }\r\n                           _.refresh(initial);\r\n                       }\r\n                       triggerBreakpoint = targetBreakpoint;\r\n                   }\r\n               } else {\r\n                   _.activeBreakpoint = targetBreakpoint;\r\n                   if (_.breakpointSettings[targetBreakpoint] === 'unslick') {\r\n                       _.unslick(targetBreakpoint);\r\n                   } else {\r\n                       _.options = $.extend({}, _.originalSettings,\r\n                           _.breakpointSettings[\r\n                               targetBreakpoint]);\r\n                       if (initial === true) {\r\n                           _.currentSlide = _.options.initialSlide;\r\n                       }\r\n                       _.refresh(initial);\r\n                   }\r\n                   triggerBreakpoint = targetBreakpoint;\r\n               }\r\n           } else {\r\n               if (_.activeBreakpoint !== null) {\r\n                   _.activeBreakpoint = null;\r\n                   _.options = _.originalSettings;\r\n                   if (initial === true) {\r\n                       _.currentSlide = _.options.initialSlide;\r\n                   }\r\n                   _.refresh(initial);\r\n                   triggerBreakpoint = targetBreakpoint;\r\n               }\r\n           }\r\n\r\n           // only trigger breakpoints during an actual break. not on initialize.\r\n           if( !initial && triggerBreakpoint !== false ) {\r\n               _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);\r\n           }\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.changeSlide = function(event, dontAnimate) {\r\n\r\n       var _ = this,\r\n           $target = $(event.currentTarget),\r\n           indexOffset, slideOffset, unevenOffset;\r\n\r\n       // If target is a link, prevent default action.\r\n       if($target.is('a')) {\r\n           event.preventDefault();\r\n       }\r\n\r\n       // If target is not the <li> element (ie: a child), find the <li>.\r\n       if(!$target.is('li')) {\r\n           $target = $target.closest('li');\r\n       }\r\n\r\n       unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);\r\n       indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;\r\n\r\n       switch (event.data.message) {\r\n\r\n           case 'previous':\r\n               slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;\r\n               if (_.slideCount > _.options.slidesToShow) {\r\n                   _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);\r\n               }\r\n               break;\r\n\r\n           case 'next':\r\n               slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;\r\n               if (_.slideCount > _.options.slidesToShow) {\r\n                   _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);\r\n               }\r\n               break;\r\n\r\n           case 'index':\r\n               var index = event.data.index === 0 ? 0 :\r\n                   event.data.index || $target.index() * _.options.slidesToScroll;\r\n\r\n               _.slideHandler(_.checkNavigable(index), false, dontAnimate);\r\n               $target.children().trigger('focus');\r\n               break;\r\n\r\n           default:\r\n               return;\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.checkNavigable = function(index) {\r\n\r\n       var _ = this,\r\n           navigables, prevNavigable;\r\n\r\n       navigables = _.getNavigableIndexes();\r\n       prevNavigable = 0;\r\n       if (index > navigables[navigables.length - 1]) {\r\n           index = navigables[navigables.length - 1];\r\n       } else {\r\n           for (var n in navigables) {\r\n               if (index < navigables[n]) {\r\n                   index = prevNavigable;\r\n                   break;\r\n               }\r\n               prevNavigable = navigables[n];\r\n           }\r\n       }\r\n\r\n       return index;\r\n   };\r\n\r\n   Slick.prototype.cleanUpEvents = function() {\r\n\r\n       var _ = this;\r\n\r\n       if (_.options.dots && _.$dots !== null) {\r\n\r\n           $('li', _.$dots)\r\n               .off('click.slick', _.changeSlide)\r\n               .off('mouseenter.slick', $.proxy(_.interrupt, _, true))\r\n               .off('mouseleave.slick', $.proxy(_.interrupt, _, false));\r\n\r\n           if (_.options.accessibility === true) {\r\n               _.$dots.off('keydown.slick', _.keyHandler);\r\n           }\r\n       }\r\n\r\n       _.$slider.off('focus.slick blur.slick');\r\n\r\n       if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\r\n           _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);\r\n           _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);\r\n\r\n           if (_.options.accessibility === true) {\r\n               _.$prevArrow && _.$prevArrow.off('keydown.slick', _.keyHandler);\r\n               _.$nextArrow && _.$nextArrow.off('keydown.slick', _.keyHandler);\r\n           }\r\n       }\r\n\r\n       _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);\r\n       _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);\r\n       _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);\r\n       _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);\r\n\r\n       _.$list.off('click.slick', _.clickHandler);\r\n\r\n       $(document).off(_.visibilityChange, _.visibility);\r\n\r\n       _.cleanUpSlideEvents();\r\n\r\n       if (_.options.accessibility === true) {\r\n           _.$list.off('keydown.slick', _.keyHandler);\r\n       }\r\n\r\n       if (_.options.focusOnSelect === true) {\r\n           $(_.$slideTrack).children().off('click.slick', _.selectHandler);\r\n       }\r\n\r\n       $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);\r\n\r\n       $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);\r\n\r\n       $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);\r\n\r\n       $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);\r\n\r\n   };\r\n\r\n   Slick.prototype.cleanUpSlideEvents = function() {\r\n\r\n       var _ = this;\r\n\r\n       _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));\r\n       _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));\r\n\r\n   };\r\n\r\n   Slick.prototype.cleanUpRows = function() {\r\n\r\n       var _ = this, originalSlides;\r\n\r\n       if(_.options.rows > 0) {\r\n           originalSlides = _.$slides.children().children();\r\n           originalSlides.removeAttr('style');\r\n           _.$slider.empty().append(originalSlides);\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.clickHandler = function(event) {\r\n\r\n       var _ = this;\r\n\r\n       if (_.shouldClick === false) {\r\n           event.stopImmediatePropagation();\r\n           event.stopPropagation();\r\n           event.preventDefault();\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.destroy = function(refresh) {\r\n\r\n       var _ = this;\r\n\r\n       _.autoPlayClear();\r\n\r\n       _.touchObject = {};\r\n\r\n       _.cleanUpEvents();\r\n\r\n       $('.slick-cloned', _.$slider).detach();\r\n\r\n       if (_.$dots) {\r\n           _.$dots.remove();\r\n       }\r\n\r\n       if ( _.$prevArrow && _.$prevArrow.length ) {\r\n\r\n           _.$prevArrow\r\n               .removeClass('slick-disabled slick-arrow slick-hidden')\r\n               .removeAttr('aria-hidden aria-disabled tabindex')\r\n               .css('display','');\r\n\r\n           if ( _.htmlExpr.test( _.options.prevArrow )) {\r\n               _.$prevArrow.remove();\r\n           }\r\n       }\r\n\r\n       if ( _.$nextArrow && _.$nextArrow.length ) {\r\n\r\n           _.$nextArrow\r\n               .removeClass('slick-disabled slick-arrow slick-hidden')\r\n               .removeAttr('aria-hidden aria-disabled tabindex')\r\n               .css('display','');\r\n\r\n           if ( _.htmlExpr.test( _.options.nextArrow )) {\r\n               _.$nextArrow.remove();\r\n           }\r\n       }\r\n\r\n\r\n       if (_.$slides) {\r\n\r\n           _.$slides\r\n               .removeClass('slick-slide slick-active slick-center slick-visible slick-current')\r\n               .removeAttr('aria-hidden')\r\n               .removeAttr('data-slick-index')\r\n               .each(function(){\r\n                   $(this).attr('style', $(this).data('originalStyling'));\r\n               });\r\n\r\n           _.$slideTrack.children(this.options.slide).detach();\r\n\r\n           _.$slideTrack.detach();\r\n\r\n           _.$list.detach();\r\n\r\n           _.$slider.append(_.$slides);\r\n       }\r\n\r\n       _.cleanUpRows();\r\n\r\n       _.$slider.removeClass('slick-slider');\r\n       _.$slider.removeClass('slick-initialized');\r\n       _.$slider.removeClass('slick-dotted');\r\n\r\n       _.unslicked = true;\r\n\r\n       if(!refresh) {\r\n           _.$slider.trigger('destroy', [_]);\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.disableTransition = function(slide) {\r\n\r\n       var _ = this,\r\n           transition = {};\r\n\r\n       transition[_.transitionType] = '';\r\n\r\n       if (_.options.fade === false) {\r\n           _.$slideTrack.css(transition);\r\n       } else {\r\n           _.$slides.eq(slide).css(transition);\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.fadeSlide = function(slideIndex, callback) {\r\n\r\n       var _ = this;\r\n\r\n       if (_.cssTransitions === false) {\r\n\r\n           _.$slides.eq(slideIndex).css({\r\n               zIndex: _.options.zIndex\r\n           });\r\n\r\n           _.$slides.eq(slideIndex).animate({\r\n               opacity: 1\r\n           }, _.options.speed, _.options.easing, callback);\r\n\r\n       } else {\r\n\r\n           _.applyTransition(slideIndex);\r\n\r\n           _.$slides.eq(slideIndex).css({\r\n               opacity: 1,\r\n               zIndex: _.options.zIndex\r\n           });\r\n\r\n           if (callback) {\r\n               setTimeout(function() {\r\n\r\n                   _.disableTransition(slideIndex);\r\n\r\n                   callback.call();\r\n               }, _.options.speed);\r\n           }\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.fadeSlideOut = function(slideIndex) {\r\n\r\n       var _ = this;\r\n\r\n       if (_.cssTransitions === false) {\r\n\r\n           _.$slides.eq(slideIndex).animate({\r\n               opacity: 0,\r\n               zIndex: _.options.zIndex - 2\r\n           }, _.options.speed, _.options.easing);\r\n\r\n       } else {\r\n\r\n           _.applyTransition(slideIndex);\r\n\r\n           _.$slides.eq(slideIndex).css({\r\n               opacity: 0,\r\n               zIndex: _.options.zIndex - 2\r\n           });\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.filterSlides = Slick.prototype.slickFilter = function(filter) {\r\n\r\n       var _ = this;\r\n\r\n       if (filter !== null) {\r\n\r\n           _.$slidesCache = _.$slides;\r\n\r\n           _.unload();\r\n\r\n           _.$slideTrack.children(this.options.slide).detach();\r\n\r\n           _.$slidesCache.filter(filter).appendTo(_.$slideTrack);\r\n\r\n           _.reinit();\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.focusHandler = function() {\r\n\r\n       var _ = this;\r\n\r\n       _.$slider\r\n           .off('focus.slick blur.slick')\r\n           .on('focus.slick blur.slick', '*', function(event) {\r\n\r\n           event.stopImmediatePropagation();\r\n           var $sf = $(this);\r\n\r\n           setTimeout(function() {\r\n\r\n               if( _.options.pauseOnFocus ) {\r\n                   _.focussed = $sf.is(':focus');\r\n                   _.autoPlay();\r\n               }\r\n\r\n           }, 0);\r\n\r\n       });\r\n   };\r\n\r\n   Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function() {\r\n\r\n       var _ = this;\r\n       return _.currentSlide;\r\n\r\n   };\r\n\r\n   Slick.prototype.getDotCount = function() {\r\n\r\n       var _ = this;\r\n\r\n       var breakPoint = 0;\r\n       var counter = 0;\r\n       var pagerQty = 0;\r\n\r\n       if (_.options.infinite === true) {\r\n           if (_.slideCount <= _.options.slidesToShow) {\r\n                ++pagerQty;\r\n           } else {\r\n               while (breakPoint < _.slideCount) {\r\n                   ++pagerQty;\r\n                   breakPoint = counter + _.options.slidesToScroll;\r\n                   counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;\r\n               }\r\n           }\r\n       } else if (_.options.centerMode === true) {\r\n           pagerQty = _.slideCount;\r\n       } else if(!_.options.asNavFor) {\r\n           pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);\r\n       }else {\r\n           while (breakPoint < _.slideCount) {\r\n               ++pagerQty;\r\n               breakPoint = counter + _.options.slidesToScroll;\r\n               counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;\r\n           }\r\n       }\r\n\r\n       return pagerQty - 1;\r\n\r\n   };\r\n\r\n   Slick.prototype.getLeft = function(slideIndex) {\r\n\r\n       var _ = this,\r\n           targetLeft,\r\n           verticalHeight,\r\n           verticalOffset = 0,\r\n           targetSlide,\r\n           coef;\r\n\r\n       _.slideOffset = 0;\r\n       verticalHeight = _.$slides.first().outerHeight(true);\r\n\r\n       if (_.options.infinite === true) {\r\n           if (_.slideCount > _.options.slidesToShow) {\r\n               _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;\r\n               coef = -1\r\n\r\n               if (_.options.vertical === true && _.options.centerMode === true) {\r\n                   if (_.options.slidesToShow === 2) {\r\n                       coef = -1.5;\r\n                   } else if (_.options.slidesToShow === 1) {\r\n                       coef = -2\r\n                   }\r\n               }\r\n               verticalOffset = (verticalHeight * _.options.slidesToShow) * coef;\r\n           }\r\n           if (_.slideCount % _.options.slidesToScroll !== 0) {\r\n               if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {\r\n                   if (slideIndex > _.slideCount) {\r\n                       _.slideOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth) * -1;\r\n                       verticalOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight) * -1;\r\n                   } else {\r\n                       _.slideOffset = ((_.slideCount % _.options.slidesToScroll) * _.slideWidth) * -1;\r\n                       verticalOffset = ((_.slideCount % _.options.slidesToScroll) * verticalHeight) * -1;\r\n                   }\r\n               }\r\n           }\r\n       } else {\r\n           if (slideIndex + _.options.slidesToShow > _.slideCount) {\r\n               _.slideOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * _.slideWidth;\r\n               verticalOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * verticalHeight;\r\n           }\r\n       }\r\n\r\n       if (_.slideCount <= _.options.slidesToShow) {\r\n           _.slideOffset = 0;\r\n           verticalOffset = 0;\r\n       }\r\n\r\n       if (_.options.centerMode === true && _.slideCount <= _.options.slidesToShow) {\r\n           _.slideOffset = ((_.slideWidth * Math.floor(_.options.slidesToShow)) / 2) - ((_.slideWidth * _.slideCount) / 2);\r\n       } else if (_.options.centerMode === true && _.options.infinite === true) {\r\n           _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;\r\n       } else if (_.options.centerMode === true) {\r\n           _.slideOffset = 0;\r\n           _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);\r\n       }\r\n\r\n       if (_.options.vertical === false) {\r\n           targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;\r\n       } else {\r\n           targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;\r\n       }\r\n\r\n       if (_.options.variableWidth === true) {\r\n\r\n           if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {\r\n               targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);\r\n           } else {\r\n               targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);\r\n           }\r\n\r\n           if (_.options.rtl === true) {\r\n               if (targetSlide[0]) {\r\n                   targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;\r\n               } else {\r\n                   targetLeft =  0;\r\n               }\r\n           } else {\r\n               targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;\r\n           }\r\n\r\n           if (_.options.centerMode === true) {\r\n               if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {\r\n                   targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);\r\n               } else {\r\n                   targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);\r\n               }\r\n\r\n               if (_.options.rtl === true) {\r\n                   if (targetSlide[0]) {\r\n                       targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;\r\n                   } else {\r\n                       targetLeft =  0;\r\n                   }\r\n               } else {\r\n                   targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;\r\n               }\r\n\r\n               targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;\r\n           }\r\n       }\r\n\r\n       return targetLeft;\r\n\r\n   };\r\n\r\n   Slick.prototype.getOption = Slick.prototype.slickGetOption = function(option) {\r\n\r\n       var _ = this;\r\n\r\n       return _.options[option];\r\n\r\n   };\r\n\r\n   Slick.prototype.getNavigableIndexes = function() {\r\n\r\n       var _ = this,\r\n           breakPoint = 0,\r\n           counter = 0,\r\n           indexes = [],\r\n           max;\r\n\r\n       if (_.options.infinite === false) {\r\n           max = _.slideCount;\r\n       } else {\r\n           breakPoint = _.options.slidesToScroll * -1;\r\n           counter = _.options.slidesToScroll * -1;\r\n           max = _.slideCount * 2;\r\n       }\r\n\r\n       while (breakPoint < max) {\r\n           indexes.push(breakPoint);\r\n           breakPoint = counter + _.options.slidesToScroll;\r\n           counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;\r\n       }\r\n\r\n       return indexes;\r\n\r\n   };\r\n\r\n   Slick.prototype.getSlick = function() {\r\n\r\n       return this;\r\n\r\n   };\r\n\r\n   Slick.prototype.getSlideCount = function() {\r\n\r\n       var _ = this,\r\n           slidesTraversed, swipedSlide, centerOffset;\r\n\r\n       centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;\r\n\r\n       if (_.options.swipeToSlide === true) {\r\n           _.$slideTrack.find('.slick-slide').each(function(index, slide) {\r\n               if (slide.offsetLeft - centerOffset + ($(slide).outerWidth() / 2) > (_.swipeLeft * -1)) {\r\n                   swipedSlide = slide;\r\n                   return false;\r\n               }\r\n           });\r\n\r\n           slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;\r\n\r\n           return slidesTraversed;\r\n\r\n       } else {\r\n           return _.options.slidesToScroll;\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.goTo = Slick.prototype.slickGoTo = function(slide, dontAnimate) {\r\n\r\n       var _ = this;\r\n\r\n       _.changeSlide({\r\n           data: {\r\n               message: 'index',\r\n               index: parseInt(slide)\r\n           }\r\n       }, dontAnimate);\r\n\r\n   };\r\n\r\n   Slick.prototype.init = function(creation) {\r\n\r\n       var _ = this;\r\n\r\n       if (!$(_.$slider).hasClass('slick-initialized')) {\r\n\r\n           $(_.$slider).addClass('slick-initialized');\r\n\r\n           _.buildRows();\r\n           _.buildOut();\r\n           _.setProps();\r\n           _.startLoad();\r\n           _.loadSlider();\r\n           _.initializeEvents();\r\n           _.updateArrows();\r\n           _.updateDots();\r\n           _.checkResponsive(true);\r\n           _.focusHandler();\r\n\r\n       }\r\n\r\n       if (creation) {\r\n           _.$slider.trigger('init', [_]);\r\n       }\r\n\r\n       if (_.options.accessibility === true) {\r\n           _.initADA();\r\n       }\r\n\r\n       if ( _.options.autoplay ) {\r\n\r\n           _.paused = false;\r\n           _.autoPlay();\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.initADA = function() {\r\n       var _ = this,\r\n               numDotGroups = Math.ceil(_.slideCount / _.options.slidesToShow),\r\n               tabControlIndexes = _.getNavigableIndexes().filter(function(val) {\r\n                   return (val >= 0) && (val < _.slideCount);\r\n               });\r\n\r\n       _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({\r\n           'aria-hidden': 'true',\r\n           'tabindex': '-1'\r\n       }).find('a, input, button, select').attr({\r\n           'tabindex': '-1'\r\n       });\r\n\r\n       if (_.$dots !== null) {\r\n           _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function(i) {\r\n               var slideControlIndex = tabControlIndexes.indexOf(i);\r\n\r\n               $(this).attr({\r\n                   'role': 'tabpanel',\r\n                   'id': 'slick-slide' + _.instanceUid + i,\r\n                   'tabindex': -1\r\n               });\r\n\r\n               if (slideControlIndex !== -1) {\r\n                  var ariaButtonControl = 'slick-slide-control' + _.instanceUid + slideControlIndex\r\n                  if ($('#' + ariaButtonControl).length) {\r\n                    $(this).attr({\r\n                        'aria-describedby': ariaButtonControl\r\n                    });\r\n                  }\r\n               }\r\n           });\r\n\r\n           _.$dots.attr('role', 'tablist').find('li').each(function(i) {\r\n               var mappedSlideIndex = tabControlIndexes[i];\r\n\r\n               $(this).attr({\r\n                   'role': 'presentation'\r\n               });\r\n\r\n               $(this).find('button').first().attr({\r\n                   'role': 'tab',\r\n                   'id': 'slick-slide-control' + _.instanceUid + i,\r\n                   'aria-controls': 'slick-slide' + _.instanceUid + mappedSlideIndex,\r\n                   'aria-label': (i + 1) + ' of ' + numDotGroups,\r\n                   'aria-selected': null,\r\n                   'tabindex': '-1'\r\n               });\r\n\r\n           }).eq(_.currentSlide).find('button').attr({\r\n               'aria-selected': 'true',\r\n               'tabindex': '0'\r\n           }).end();\r\n       }\r\n\r\n       for (var i=_.currentSlide, max=i+_.options.slidesToShow; i < max; i++) {\r\n         if (_.options.focusOnChange) {\r\n           _.$slides.eq(i).attr({'tabindex': '0'});\r\n         } else {\r\n           _.$slides.eq(i).removeAttr('tabindex');\r\n         }\r\n       }\r\n\r\n       _.activateADA();\r\n\r\n   };\r\n\r\n   Slick.prototype.initArrowEvents = function() {\r\n\r\n       var _ = this;\r\n\r\n       if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\r\n           _.$prevArrow\r\n              .off('click.slick')\r\n              .on('click.slick', {\r\n                   message: 'previous'\r\n              }, _.changeSlide);\r\n           _.$nextArrow\r\n              .off('click.slick')\r\n              .on('click.slick', {\r\n                   message: 'next'\r\n              }, _.changeSlide);\r\n\r\n           if (_.options.accessibility === true) {\r\n               _.$prevArrow.on('keydown.slick', _.keyHandler);\r\n               _.$nextArrow.on('keydown.slick', _.keyHandler);\r\n           }\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.initDotEvents = function() {\r\n\r\n       var _ = this;\r\n\r\n       if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\r\n           $('li', _.$dots).on('click.slick', {\r\n               message: 'index'\r\n           }, _.changeSlide);\r\n\r\n           if (_.options.accessibility === true) {\r\n               _.$dots.on('keydown.slick', _.keyHandler);\r\n           }\r\n       }\r\n\r\n       if (_.options.dots === true && _.options.pauseOnDotsHover === true && _.slideCount > _.options.slidesToShow) {\r\n\r\n           $('li', _.$dots)\r\n               .on('mouseenter.slick', $.proxy(_.interrupt, _, true))\r\n               .on('mouseleave.slick', $.proxy(_.interrupt, _, false));\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.initSlideEvents = function() {\r\n\r\n       var _ = this;\r\n\r\n       if ( _.options.pauseOnHover ) {\r\n\r\n           _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));\r\n           _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.initializeEvents = function() {\r\n\r\n       var _ = this;\r\n\r\n       _.initArrowEvents();\r\n\r\n       _.initDotEvents();\r\n       _.initSlideEvents();\r\n\r\n       _.$list.on('touchstart.slick mousedown.slick', {\r\n           action: 'start'\r\n       }, _.swipeHandler);\r\n       _.$list.on('touchmove.slick mousemove.slick', {\r\n           action: 'move'\r\n       }, _.swipeHandler);\r\n       _.$list.on('touchend.slick mouseup.slick', {\r\n           action: 'end'\r\n       }, _.swipeHandler);\r\n       _.$list.on('touchcancel.slick mouseleave.slick', {\r\n           action: 'end'\r\n       }, _.swipeHandler);\r\n\r\n       _.$list.on('click.slick', _.clickHandler);\r\n\r\n       $(document).on(_.visibilityChange, $.proxy(_.visibility, _));\r\n\r\n       if (_.options.accessibility === true) {\r\n           _.$list.on('keydown.slick', _.keyHandler);\r\n       }\r\n\r\n       if (_.options.focusOnSelect === true) {\r\n           $(_.$slideTrack).children().on('click.slick', _.selectHandler);\r\n       }\r\n\r\n       $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));\r\n\r\n       $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));\r\n\r\n       $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);\r\n\r\n       $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);\r\n       $(_.setPosition);\r\n\r\n   };\r\n\r\n   Slick.prototype.initUI = function() {\r\n\r\n       var _ = this;\r\n\r\n       if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\r\n\r\n           _.$prevArrow.show();\r\n           _.$nextArrow.show();\r\n\r\n       }\r\n\r\n       if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\r\n\r\n           _.$dots.show();\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.keyHandler = function(event) {\r\n\r\n       var _ = this;\r\n        //Dont slide if the cursor is inside the form fields and arrow keys are pressed\r\n       if(!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {\r\n           if (event.keyCode === 37 && _.options.accessibility === true) {\r\n               _.changeSlide({\r\n                   data: {\r\n                       message: _.options.rtl === true ? 'next' :  'previous'\r\n                   }\r\n               });\r\n           } else if (event.keyCode === 39 && _.options.accessibility === true) {\r\n               _.changeSlide({\r\n                   data: {\r\n                       message: _.options.rtl === true ? 'previous' : 'next'\r\n                   }\r\n               });\r\n           }\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.lazyLoad = function() {\r\n\r\n       var _ = this,\r\n           loadRange, cloneRange, rangeStart, rangeEnd;\r\n\r\n       function loadImages(imagesScope) {\r\n\r\n           $('img[data-lazy]', imagesScope).each(function() {\r\n\r\n               var image = $(this),\r\n                   imageSource = $(this).attr('data-lazy'),\r\n                   imageSrcSet = $(this).attr('data-srcset'),\r\n                   imageSizes  = $(this).attr('data-sizes') || _.$slider.attr('data-sizes'),\r\n                   imageToLoad = document.createElement('img');\r\n\r\n               imageToLoad.onload = function() {\r\n\r\n                   image\r\n                       .animate({ opacity: 0 }, 100, function() {\r\n\r\n                           if (imageSrcSet) {\r\n                               image\r\n                                   .attr('srcset', imageSrcSet );\r\n\r\n                               if (imageSizes) {\r\n                                   image\r\n                                       .attr('sizes', imageSizes );\r\n                               }\r\n                           }\r\n\r\n                           image\r\n                               .attr('src', imageSource)\r\n                               .animate({ opacity: 1 }, 200, function() {\r\n                                   image\r\n                                       .removeAttr('data-lazy data-srcset data-sizes')\r\n                                       .removeClass('slick-loading');\r\n                               });\r\n                           _.$slider.trigger('lazyLoaded', [_, image, imageSource]);\r\n                       });\r\n\r\n               };\r\n\r\n               imageToLoad.onerror = function() {\r\n\r\n                   image\r\n                       .removeAttr( 'data-lazy' )\r\n                       .removeClass( 'slick-loading' )\r\n                       .addClass( 'slick-lazyload-error' );\r\n\r\n                   _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);\r\n\r\n               };\r\n\r\n               imageToLoad.src = imageSource;\r\n\r\n           });\r\n\r\n       }\r\n\r\n       if (_.options.centerMode === true) {\r\n           if (_.options.infinite === true) {\r\n               rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);\r\n               rangeEnd = rangeStart + _.options.slidesToShow + 2;\r\n           } else {\r\n               rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));\r\n               rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;\r\n           }\r\n       } else {\r\n           rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;\r\n           rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);\r\n           if (_.options.fade === true) {\r\n               if (rangeStart > 0) rangeStart--;\r\n               if (rangeEnd <= _.slideCount) rangeEnd++;\r\n           }\r\n       }\r\n\r\n       loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);\r\n\r\n       if (_.options.lazyLoad === 'anticipated') {\r\n           var prevSlide = rangeStart - 1,\r\n               nextSlide = rangeEnd,\r\n               $slides = _.$slider.find('.slick-slide');\r\n\r\n           for (var i = 0; i < _.options.slidesToScroll; i++) {\r\n               if (prevSlide < 0) prevSlide = _.slideCount - 1;\r\n               loadRange = loadRange.add($slides.eq(prevSlide));\r\n               loadRange = loadRange.add($slides.eq(nextSlide));\r\n               prevSlide--;\r\n               nextSlide++;\r\n           }\r\n       }\r\n\r\n       loadImages(loadRange);\r\n\r\n       if (_.slideCount <= _.options.slidesToShow) {\r\n           cloneRange = _.$slider.find('.slick-slide');\r\n           loadImages(cloneRange);\r\n       } else\r\n       if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {\r\n           cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);\r\n           loadImages(cloneRange);\r\n       } else if (_.currentSlide === 0) {\r\n           cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);\r\n           loadImages(cloneRange);\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.loadSlider = function() {\r\n\r\n       var _ = this;\r\n\r\n       _.setPosition();\r\n\r\n       _.$slideTrack.css({\r\n           opacity: 1\r\n       });\r\n\r\n       _.$slider.removeClass('slick-loading');\r\n\r\n       _.initUI();\r\n\r\n       if (_.options.lazyLoad === 'progressive') {\r\n           _.progressiveLazyLoad();\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.next = Slick.prototype.slickNext = function() {\r\n\r\n       var _ = this;\r\n\r\n       _.changeSlide({\r\n           data: {\r\n               message: 'next'\r\n           }\r\n       });\r\n\r\n   };\r\n\r\n   Slick.prototype.orientationChange = function() {\r\n\r\n       var _ = this;\r\n\r\n       _.checkResponsive();\r\n       _.setPosition();\r\n\r\n   };\r\n\r\n   Slick.prototype.pause = Slick.prototype.slickPause = function() {\r\n\r\n       var _ = this;\r\n\r\n       _.autoPlayClear();\r\n       _.paused = true;\r\n\r\n   };\r\n\r\n   Slick.prototype.play = Slick.prototype.slickPlay = function() {\r\n\r\n       var _ = this;\r\n\r\n       _.autoPlay();\r\n       _.options.autoplay = true;\r\n       _.paused = false;\r\n       _.focussed = false;\r\n       _.interrupted = false;\r\n\r\n   };\r\n\r\n   Slick.prototype.postSlide = function(index) {\r\n\r\n       var _ = this;\r\n\r\n       if( !_.unslicked ) {\r\n\r\n           _.$slider.trigger('afterChange', [_, index]);\r\n\r\n           _.animating = false;\r\n\r\n           if (_.slideCount > _.options.slidesToShow) {\r\n               _.setPosition();\r\n           }\r\n\r\n           _.swipeLeft = null;\r\n\r\n           if ( _.options.autoplay ) {\r\n               _.autoPlay();\r\n           }\r\n\r\n           if (_.options.accessibility === true) {\r\n               _.initADA();\r\n\r\n               if (_.options.focusOnChange) {\r\n                   var $currentSlide = $(_.$slides.get(_.currentSlide));\r\n                   $currentSlide.attr('tabindex', 0).focus();\r\n               }\r\n           }\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.prev = Slick.prototype.slickPrev = function() {\r\n\r\n       var _ = this;\r\n\r\n       _.changeSlide({\r\n           data: {\r\n               message: 'previous'\r\n           }\r\n       });\r\n\r\n   };\r\n\r\n   Slick.prototype.preventDefault = function(event) {\r\n\r\n       event.preventDefault();\r\n\r\n   };\r\n\r\n   Slick.prototype.progressiveLazyLoad = function( tryCount ) {\r\n\r\n       tryCount = tryCount || 1;\r\n\r\n       var _ = this,\r\n           $imgsToLoad = $( 'img[data-lazy]', _.$slider ),\r\n           image,\r\n           imageSource,\r\n           imageSrcSet,\r\n           imageSizes,\r\n           imageToLoad;\r\n\r\n       if ( $imgsToLoad.length ) {\r\n\r\n           image = $imgsToLoad.first();\r\n           imageSource = image.attr('data-lazy');\r\n           imageSrcSet = image.attr('data-srcset');\r\n           imageSizes  = image.attr('data-sizes') || _.$slider.attr('data-sizes');\r\n           imageToLoad = document.createElement('img');\r\n\r\n           imageToLoad.onload = function() {\r\n\r\n               if (imageSrcSet) {\r\n                   image\r\n                       .attr('srcset', imageSrcSet );\r\n\r\n                   if (imageSizes) {\r\n                       image\r\n                           .attr('sizes', imageSizes );\r\n                   }\r\n               }\r\n\r\n               image\r\n                   .attr( 'src', imageSource )\r\n                   .removeAttr('data-lazy data-srcset data-sizes')\r\n                   .removeClass('slick-loading');\r\n\r\n               if ( _.options.adaptiveHeight === true ) {\r\n                   _.setPosition();\r\n               }\r\n\r\n               _.$slider.trigger('lazyLoaded', [ _, image, imageSource ]);\r\n               _.progressiveLazyLoad();\r\n\r\n           };\r\n\r\n           imageToLoad.onerror = function() {\r\n\r\n               if ( tryCount < 3 ) {\r\n\r\n                   /**\r\n                    * try to load the image 3 times,\r\n                    * leave a slight delay so we don't get\r\n                    * servers blocking the request.\r\n                    */\r\n                   setTimeout( function() {\r\n                       _.progressiveLazyLoad( tryCount + 1 );\r\n                   }, 500 );\r\n\r\n               } else {\r\n\r\n                   image\r\n                       .removeAttr( 'data-lazy' )\r\n                       .removeClass( 'slick-loading' )\r\n                       .addClass( 'slick-lazyload-error' );\r\n\r\n                   _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);\r\n\r\n                   _.progressiveLazyLoad();\r\n\r\n               }\r\n\r\n           };\r\n\r\n           imageToLoad.src = imageSource;\r\n\r\n       } else {\r\n\r\n           _.$slider.trigger('allImagesLoaded', [ _ ]);\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.refresh = function( initializing ) {\r\n\r\n       var _ = this, currentSlide, lastVisibleIndex;\r\n\r\n       lastVisibleIndex = _.slideCount - _.options.slidesToShow;\r\n\r\n       // in non-infinite sliders, we don't want to go past the\r\n       // last visible index.\r\n       if( !_.options.infinite && ( _.currentSlide > lastVisibleIndex )) {\r\n           _.currentSlide = lastVisibleIndex;\r\n       }\r\n\r\n       // if less slides than to show, go to start.\r\n       if ( _.slideCount <= _.options.slidesToShow ) {\r\n           _.currentSlide = 0;\r\n\r\n       }\r\n\r\n       currentSlide = _.currentSlide;\r\n\r\n       _.destroy(true);\r\n\r\n       $.extend(_, _.initials, { currentSlide: currentSlide });\r\n\r\n       _.init();\r\n\r\n       if( !initializing ) {\r\n\r\n           _.changeSlide({\r\n               data: {\r\n                   message: 'index',\r\n                   index: currentSlide\r\n               }\r\n           }, false);\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.registerBreakpoints = function() {\r\n\r\n       var _ = this, breakpoint, currentBreakpoint, l,\r\n           responsiveSettings = _.options.responsive || null;\r\n\r\n       if ( $.type(responsiveSettings) === 'array' && responsiveSettings.length ) {\r\n\r\n           _.respondTo = _.options.respondTo || 'window';\r\n\r\n           for ( breakpoint in responsiveSettings ) {\r\n\r\n               l = _.breakpoints.length-1;\r\n\r\n               if (responsiveSettings.hasOwnProperty(breakpoint)) {\r\n                   currentBreakpoint = responsiveSettings[breakpoint].breakpoint;\r\n\r\n                   // loop through the breakpoints and cut out any existing\r\n                   // ones with the same breakpoint number, we don't want dupes.\r\n                   while( l >= 0 ) {\r\n                       if( _.breakpoints[l] && _.breakpoints[l] === currentBreakpoint ) {\r\n                           _.breakpoints.splice(l,1);\r\n                       }\r\n                       l--;\r\n                   }\r\n\r\n                   _.breakpoints.push(currentBreakpoint);\r\n                   _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;\r\n\r\n               }\r\n\r\n           }\r\n\r\n           _.breakpoints.sort(function(a, b) {\r\n               return ( _.options.mobileFirst ) ? a-b : b-a;\r\n           });\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.reinit = function() {\r\n\r\n       var _ = this;\r\n\r\n       _.$slides =\r\n           _.$slideTrack\r\n               .children(_.options.slide)\r\n               .addClass('slick-slide');\r\n\r\n       _.slideCount = _.$slides.length;\r\n\r\n       if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {\r\n           _.currentSlide = _.currentSlide - _.options.slidesToScroll;\r\n       }\r\n\r\n       if (_.slideCount <= _.options.slidesToShow) {\r\n           _.currentSlide = 0;\r\n       }\r\n\r\n       _.registerBreakpoints();\r\n\r\n       _.setProps();\r\n       _.setupInfinite();\r\n       _.buildArrows();\r\n       _.updateArrows();\r\n       _.initArrowEvents();\r\n       _.buildDots();\r\n       _.updateDots();\r\n       _.initDotEvents();\r\n       _.cleanUpSlideEvents();\r\n       _.initSlideEvents();\r\n\r\n       _.checkResponsive(false, true);\r\n\r\n       if (_.options.focusOnSelect === true) {\r\n           $(_.$slideTrack).children().on('click.slick', _.selectHandler);\r\n       }\r\n\r\n       _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);\r\n\r\n       _.setPosition();\r\n       _.focusHandler();\r\n\r\n       _.paused = !_.options.autoplay;\r\n       _.autoPlay();\r\n\r\n       _.$slider.trigger('reInit', [_]);\r\n\r\n   };\r\n\r\n   Slick.prototype.resize = function() {\r\n\r\n       var _ = this;\r\n\r\n       if ($(window).width() !== _.windowWidth) {\r\n           clearTimeout(_.windowDelay);\r\n           _.windowDelay = window.setTimeout(function() {\r\n               _.windowWidth = $(window).width();\r\n               _.checkResponsive();\r\n               if( !_.unslicked ) { _.setPosition(); }\r\n           }, 50);\r\n       }\r\n   };\r\n\r\n   Slick.prototype.removeSlide = Slick.prototype.slickRemove = function(index, removeBefore, removeAll) {\r\n\r\n       var _ = this;\r\n\r\n       if (typeof(index) === 'boolean') {\r\n           removeBefore = index;\r\n           index = removeBefore === true ? 0 : _.slideCount - 1;\r\n       } else {\r\n           index = removeBefore === true ? --index : index;\r\n       }\r\n\r\n       if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {\r\n           return false;\r\n       }\r\n\r\n       _.unload();\r\n\r\n       if (removeAll === true) {\r\n           _.$slideTrack.children().remove();\r\n       } else {\r\n           _.$slideTrack.children(this.options.slide).eq(index).remove();\r\n       }\r\n\r\n       _.$slides = _.$slideTrack.children(this.options.slide);\r\n\r\n       _.$slideTrack.children(this.options.slide).detach();\r\n\r\n       _.$slideTrack.append(_.$slides);\r\n\r\n       _.$slidesCache = _.$slides;\r\n\r\n       _.reinit();\r\n\r\n   };\r\n\r\n   Slick.prototype.setCSS = function(position) {\r\n\r\n       var _ = this,\r\n           positionProps = {},\r\n           x, y;\r\n\r\n       if (_.options.rtl === true) {\r\n           position = -position;\r\n       }\r\n       x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';\r\n       y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';\r\n\r\n       positionProps[_.positionProp] = position;\r\n\r\n       if (_.transformsEnabled === false) {\r\n           _.$slideTrack.css(positionProps);\r\n       } else {\r\n           positionProps = {};\r\n           if (_.cssTransitions === false) {\r\n               positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';\r\n               _.$slideTrack.css(positionProps);\r\n           } else {\r\n               positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';\r\n               _.$slideTrack.css(positionProps);\r\n           }\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.setDimensions = function() {\r\n\r\n       var _ = this;\r\n\r\n       if (_.options.vertical === false) {\r\n           if (_.options.centerMode === true) {\r\n               _.$list.css({\r\n                   padding: ('0px ' + _.options.centerPadding)\r\n               });\r\n           }\r\n       } else {\r\n           _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);\r\n           if (_.options.centerMode === true) {\r\n               _.$list.css({\r\n                   padding: (_.options.centerPadding + ' 0px')\r\n               });\r\n           }\r\n       }\r\n\r\n       _.listWidth = _.$list.width();\r\n       _.listHeight = _.$list.height();\r\n\r\n\r\n       if (_.options.vertical === false && _.options.variableWidth === false) {\r\n           _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);\r\n           _.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slick-slide').length)));\r\n\r\n       } else if (_.options.variableWidth === true) {\r\n           _.$slideTrack.width(5000 * _.slideCount);\r\n       } else {\r\n           _.slideWidth = Math.ceil(_.listWidth);\r\n           _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length)));\r\n       }\r\n\r\n       var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();\r\n       if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);\r\n\r\n   };\r\n\r\n   Slick.prototype.setFade = function() {\r\n\r\n       var _ = this,\r\n           targetLeft;\r\n\r\n       _.$slides.each(function(index, element) {\r\n           targetLeft = (_.slideWidth * index) * -1;\r\n           if (_.options.rtl === true) {\r\n               $(element).css({\r\n                   position: 'relative',\r\n                   right: targetLeft,\r\n                   top: 0,\r\n                   zIndex: _.options.zIndex - 2,\r\n                   opacity: 0\r\n               });\r\n           } else {\r\n               $(element).css({\r\n                   position: 'relative',\r\n                   left: targetLeft,\r\n                   top: 0,\r\n                   zIndex: _.options.zIndex - 2,\r\n                   opacity: 0\r\n               });\r\n           }\r\n       });\r\n\r\n       _.$slides.eq(_.currentSlide).css({\r\n           zIndex: _.options.zIndex - 1,\r\n           opacity: 1\r\n       });\r\n\r\n   };\r\n\r\n   Slick.prototype.setHeight = function() {\r\n\r\n       var _ = this;\r\n\r\n       if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {\r\n           var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);\r\n           _.$list.css('height', targetHeight);\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.setOption =\r\n   Slick.prototype.slickSetOption = function() {\r\n\r\n       /**\r\n        * accepts arguments in format of:\r\n        *\r\n        *  - for changing a single option's value:\r\n        *     .slick(\"setOption\", option, value, refresh )\r\n        *\r\n        *  - for changing a set of responsive options:\r\n        *     .slick(\"setOption\", 'responsive', [{}, ...], refresh )\r\n        *\r\n        *  - for updating multiple values at once (not responsive)\r\n        *     .slick(\"setOption\", { 'option': value, ... }, refresh )\r\n        */\r\n\r\n       var _ = this, l, item, option, value, refresh = false, type;\r\n\r\n       if( $.type( arguments[0] ) === 'object' ) {\r\n\r\n           option =  arguments[0];\r\n           refresh = arguments[1];\r\n           type = 'multiple';\r\n\r\n       } else if ( $.type( arguments[0] ) === 'string' ) {\r\n\r\n           option =  arguments[0];\r\n           value = arguments[1];\r\n           refresh = arguments[2];\r\n\r\n           if ( arguments[0] === 'responsive' && $.type( arguments[1] ) === 'array' ) {\r\n\r\n               type = 'responsive';\r\n\r\n           } else if ( typeof arguments[1] !== 'undefined' ) {\r\n\r\n               type = 'single';\r\n\r\n           }\r\n\r\n       }\r\n\r\n       if ( type === 'single' ) {\r\n\r\n           _.options[option] = value;\r\n\r\n\r\n       } else if ( type === 'multiple' ) {\r\n\r\n           $.each( option , function( opt, val ) {\r\n\r\n               _.options[opt] = val;\r\n\r\n           });\r\n\r\n\r\n       } else if ( type === 'responsive' ) {\r\n\r\n           for ( item in value ) {\r\n\r\n               if( $.type( _.options.responsive ) !== 'array' ) {\r\n\r\n                   _.options.responsive = [ value[item] ];\r\n\r\n               } else {\r\n\r\n                   l = _.options.responsive.length-1;\r\n\r\n                   // loop through the responsive object and splice out duplicates.\r\n                   while( l >= 0 ) {\r\n\r\n                       if( _.options.responsive[l].breakpoint === value[item].breakpoint ) {\r\n\r\n                           _.options.responsive.splice(l,1);\r\n\r\n                       }\r\n\r\n                       l--;\r\n\r\n                   }\r\n\r\n                   _.options.responsive.push( value[item] );\r\n\r\n               }\r\n\r\n           }\r\n\r\n       }\r\n\r\n       if ( refresh ) {\r\n\r\n           _.unload();\r\n           _.reinit();\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.setPosition = function() {\r\n\r\n       var _ = this;\r\n\r\n       _.setDimensions();\r\n\r\n       _.setHeight();\r\n\r\n       if (_.options.fade === false) {\r\n           _.setCSS(_.getLeft(_.currentSlide));\r\n       } else {\r\n           _.setFade();\r\n       }\r\n\r\n       _.$slider.trigger('setPosition', [_]);\r\n\r\n   };\r\n\r\n   Slick.prototype.setProps = function() {\r\n\r\n       var _ = this,\r\n           bodyStyle = document.body.style;\r\n\r\n       _.positionProp = _.options.vertical === true ? 'top' : 'left';\r\n\r\n       if (_.positionProp === 'top') {\r\n           _.$slider.addClass('slick-vertical');\r\n       } else {\r\n           _.$slider.removeClass('slick-vertical');\r\n       }\r\n\r\n       if (bodyStyle.WebkitTransition !== undefined ||\r\n           bodyStyle.MozTransition !== undefined ||\r\n           bodyStyle.msTransition !== undefined) {\r\n           if (_.options.useCSS === true) {\r\n               _.cssTransitions = true;\r\n           }\r\n       }\r\n\r\n       if ( _.options.fade ) {\r\n           if ( typeof _.options.zIndex === 'number' ) {\r\n               if( _.options.zIndex < 3 ) {\r\n                   _.options.zIndex = 3;\r\n               }\r\n           } else {\r\n               _.options.zIndex = _.defaults.zIndex;\r\n           }\r\n       }\r\n\r\n       if (bodyStyle.OTransform !== undefined) {\r\n           _.animType = 'OTransform';\r\n           _.transformType = '-o-transform';\r\n           _.transitionType = 'OTransition';\r\n           if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;\r\n       }\r\n       if (bodyStyle.MozTransform !== undefined) {\r\n           _.animType = 'MozTransform';\r\n           _.transformType = '-moz-transform';\r\n           _.transitionType = 'MozTransition';\r\n           if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;\r\n       }\r\n       if (bodyStyle.webkitTransform !== undefined) {\r\n           _.animType = 'webkitTransform';\r\n           _.transformType = '-webkit-transform';\r\n           _.transitionType = 'webkitTransition';\r\n           if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;\r\n       }\r\n       if (bodyStyle.msTransform !== undefined) {\r\n           _.animType = 'msTransform';\r\n           _.transformType = '-ms-transform';\r\n           _.transitionType = 'msTransition';\r\n           if (bodyStyle.msTransform === undefined) _.animType = false;\r\n       }\r\n       if (bodyStyle.transform !== undefined && _.animType !== false) {\r\n           _.animType = 'transform';\r\n           _.transformType = 'transform';\r\n           _.transitionType = 'transition';\r\n       }\r\n       _.transformsEnabled = _.options.useTransform && (_.animType !== null && _.animType !== false);\r\n   };\r\n\r\n\r\n   Slick.prototype.setSlideClasses = function(index) {\r\n\r\n       var _ = this,\r\n           centerOffset, allSlides, indexOffset, remainder;\r\n\r\n       allSlides = _.$slider\r\n           .find('.slick-slide')\r\n           .removeClass('slick-active slick-center slick-current')\r\n           .attr('aria-hidden', 'true');\r\n\r\n       _.$slides\r\n           .eq(index)\r\n           .addClass('slick-current');\r\n\r\n       if (_.options.centerMode === true) {\r\n\r\n           var evenCoef = _.options.slidesToShow % 2 === 0 ? 1 : 0;\r\n\r\n           centerOffset = Math.floor(_.options.slidesToShow / 2);\r\n\r\n           if (_.options.infinite === true) {\r\n\r\n               if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {\r\n                   _.$slides\r\n                       .slice(index - centerOffset + evenCoef, index + centerOffset + 1)\r\n                       .addClass('slick-active')\r\n                       .attr('aria-hidden', 'false');\r\n\r\n               } else {\r\n\r\n                   indexOffset = _.options.slidesToShow + index;\r\n                   allSlides\r\n                       .slice(indexOffset - centerOffset + 1 + evenCoef, indexOffset + centerOffset + 2)\r\n                       .addClass('slick-active')\r\n                       .attr('aria-hidden', 'false');\r\n\r\n               }\r\n\r\n               if (index === 0) {\r\n\r\n                   allSlides\r\n                       .eq(allSlides.length - 1 - _.options.slidesToShow)\r\n                       .addClass('slick-center');\r\n\r\n               } else if (index === _.slideCount - 1) {\r\n\r\n                   allSlides\r\n                       .eq(_.options.slidesToShow)\r\n                       .addClass('slick-center');\r\n\r\n               }\r\n\r\n           }\r\n\r\n           _.$slides\r\n               .eq(index)\r\n               .addClass('slick-center');\r\n\r\n       } else {\r\n\r\n           if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {\r\n\r\n               _.$slides\r\n                   .slice(index, index + _.options.slidesToShow)\r\n                   .addClass('slick-active')\r\n                   .attr('aria-hidden', 'false');\r\n\r\n           } else if (allSlides.length <= _.options.slidesToShow) {\r\n\r\n               allSlides\r\n                   .addClass('slick-active')\r\n                   .attr('aria-hidden', 'false');\r\n\r\n           } else {\r\n\r\n               remainder = _.slideCount % _.options.slidesToShow;\r\n               indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;\r\n\r\n               if (_.options.slidesToShow == _.options.slidesToScroll && (_.slideCount - index) < _.options.slidesToShow) {\r\n\r\n                   allSlides\r\n                       .slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder)\r\n                       .addClass('slick-active')\r\n                       .attr('aria-hidden', 'false');\r\n\r\n               } else {\r\n\r\n                   allSlides\r\n                       .slice(indexOffset, indexOffset + _.options.slidesToShow)\r\n                       .addClass('slick-active')\r\n                       .attr('aria-hidden', 'false');\r\n\r\n               }\r\n\r\n           }\r\n\r\n       }\r\n\r\n       if (_.options.lazyLoad === 'ondemand' || _.options.lazyLoad === 'anticipated') {\r\n           _.lazyLoad();\r\n       }\r\n   };\r\n\r\n   Slick.prototype.setupInfinite = function() {\r\n\r\n       var _ = this,\r\n           i, slideIndex, infiniteCount;\r\n\r\n       if (_.options.fade === true) {\r\n           _.options.centerMode = false;\r\n       }\r\n\r\n       if (_.options.infinite === true && _.options.fade === false) {\r\n\r\n           slideIndex = null;\r\n\r\n           if (_.slideCount > _.options.slidesToShow) {\r\n\r\n               if (_.options.centerMode === true) {\r\n                   infiniteCount = _.options.slidesToShow + 1;\r\n               } else {\r\n                   infiniteCount = _.options.slidesToShow;\r\n               }\r\n\r\n               for (i = _.slideCount; i > (_.slideCount -\r\n                       infiniteCount); i -= 1) {\r\n                   slideIndex = i - 1;\r\n                   $(_.$slides[slideIndex]).clone(true).attr('id', '')\r\n                       .attr('data-slick-index', slideIndex - _.slideCount)\r\n                       .prependTo(_.$slideTrack).addClass('slick-cloned');\r\n               }\r\n               for (i = 0; i < infiniteCount  + _.slideCount; i += 1) {\r\n                   slideIndex = i;\r\n                   $(_.$slides[slideIndex]).clone(true).attr('id', '')\r\n                       .attr('data-slick-index', slideIndex + _.slideCount)\r\n                       .appendTo(_.$slideTrack).addClass('slick-cloned');\r\n               }\r\n               _.$slideTrack.find('.slick-cloned').find('[id]').each(function() {\r\n                   $(this).attr('id', '');\r\n               });\r\n\r\n           }\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.interrupt = function( toggle ) {\r\n\r\n       var _ = this;\r\n\r\n       if( !toggle ) {\r\n           _.autoPlay();\r\n       }\r\n       _.interrupted = toggle;\r\n\r\n   };\r\n\r\n   Slick.prototype.selectHandler = function(event) {\r\n\r\n       var _ = this;\r\n\r\n       var targetElement =\r\n           $(event.target).is('.slick-slide') ?\r\n               $(event.target) :\r\n               $(event.target).parents('.slick-slide');\r\n\r\n       var index = parseInt(targetElement.attr('data-slick-index'));\r\n\r\n       if (!index) index = 0;\r\n\r\n       if (_.slideCount <= _.options.slidesToShow) {\r\n\r\n           _.slideHandler(index, false, true);\r\n           return;\r\n\r\n       }\r\n\r\n       _.slideHandler(index);\r\n\r\n   };\r\n\r\n   Slick.prototype.slideHandler = function(index, sync, dontAnimate) {\r\n\r\n       var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null,\r\n           _ = this, navTarget;\r\n\r\n       sync = sync || false;\r\n\r\n       if (_.animating === true && _.options.waitForAnimate === true) {\r\n           return;\r\n       }\r\n\r\n       if (_.options.fade === true && _.currentSlide === index) {\r\n           return;\r\n       }\r\n\r\n       if (sync === false) {\r\n           _.asNavFor(index);\r\n       }\r\n\r\n       targetSlide = index;\r\n       targetLeft = _.getLeft(targetSlide);\r\n       slideLeft = _.getLeft(_.currentSlide);\r\n\r\n       _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;\r\n\r\n       if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {\r\n           if (_.options.fade === false) {\r\n               targetSlide = _.currentSlide;\r\n               if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {\r\n                   _.animateSlide(slideLeft, function() {\r\n                       _.postSlide(targetSlide);\r\n                   });\r\n               } else {\r\n                   _.postSlide(targetSlide);\r\n               }\r\n           }\r\n           return;\r\n       } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {\r\n           if (_.options.fade === false) {\r\n               targetSlide = _.currentSlide;\r\n               if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {\r\n                   _.animateSlide(slideLeft, function() {\r\n                       _.postSlide(targetSlide);\r\n                   });\r\n               } else {\r\n                   _.postSlide(targetSlide);\r\n               }\r\n           }\r\n           return;\r\n       }\r\n\r\n       if ( _.options.autoplay ) {\r\n           clearInterval(_.autoPlayTimer);\r\n       }\r\n\r\n       if (targetSlide < 0) {\r\n           if (_.slideCount % _.options.slidesToScroll !== 0) {\r\n               animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);\r\n           } else {\r\n               animSlide = _.slideCount + targetSlide;\r\n           }\r\n       } else if (targetSlide >= _.slideCount) {\r\n           if (_.slideCount % _.options.slidesToScroll !== 0) {\r\n               animSlide = 0;\r\n           } else {\r\n               animSlide = targetSlide - _.slideCount;\r\n           }\r\n       } else {\r\n           animSlide = targetSlide;\r\n       }\r\n\r\n       _.animating = true;\r\n\r\n       _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);\r\n\r\n       oldSlide = _.currentSlide;\r\n       _.currentSlide = animSlide;\r\n\r\n       _.setSlideClasses(_.currentSlide);\r\n\r\n       if ( _.options.asNavFor ) {\r\n\r\n           navTarget = _.getNavTarget();\r\n           navTarget = navTarget.slick('getSlick');\r\n\r\n           if ( navTarget.slideCount <= navTarget.options.slidesToShow ) {\r\n               navTarget.setSlideClasses(_.currentSlide);\r\n           }\r\n\r\n       }\r\n\r\n       _.updateDots();\r\n       _.updateArrows();\r\n\r\n       if (_.options.fade === true) {\r\n           if (dontAnimate !== true) {\r\n\r\n               _.fadeSlideOut(oldSlide);\r\n\r\n               _.fadeSlide(animSlide, function() {\r\n                   _.postSlide(animSlide);\r\n               });\r\n\r\n           } else {\r\n               _.postSlide(animSlide);\r\n           }\r\n           _.animateHeight();\r\n           return;\r\n       }\r\n\r\n       if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {\r\n           _.animateSlide(targetLeft, function() {\r\n               _.postSlide(animSlide);\r\n           });\r\n       } else {\r\n           _.postSlide(animSlide);\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.startLoad = function() {\r\n\r\n       var _ = this;\r\n\r\n       if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\r\n\r\n           _.$prevArrow.hide();\r\n           _.$nextArrow.hide();\r\n\r\n       }\r\n\r\n       if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\r\n\r\n           _.$dots.hide();\r\n\r\n       }\r\n\r\n       _.$slider.addClass('slick-loading');\r\n\r\n   };\r\n\r\n   Slick.prototype.swipeDirection = function() {\r\n\r\n       var xDist, yDist, r, swipeAngle, _ = this;\r\n\r\n       xDist = _.touchObject.startX - _.touchObject.curX;\r\n       yDist = _.touchObject.startY - _.touchObject.curY;\r\n       r = Math.atan2(yDist, xDist);\r\n\r\n       swipeAngle = Math.round(r * 180 / Math.PI);\r\n       if (swipeAngle < 0) {\r\n           swipeAngle = 360 - Math.abs(swipeAngle);\r\n       }\r\n\r\n       if ((swipeAngle <= 45) && (swipeAngle >= 0)) {\r\n           return (_.options.rtl === false ? 'left' : 'right');\r\n       }\r\n       if ((swipeAngle <= 360) && (swipeAngle >= 315)) {\r\n           return (_.options.rtl === false ? 'left' : 'right');\r\n       }\r\n       if ((swipeAngle >= 135) && (swipeAngle <= 225)) {\r\n           return (_.options.rtl === false ? 'right' : 'left');\r\n       }\r\n       if (_.options.verticalSwiping === true) {\r\n           if ((swipeAngle >= 35) && (swipeAngle <= 135)) {\r\n               return 'down';\r\n           } else {\r\n               return 'up';\r\n           }\r\n       }\r\n\r\n       return 'vertical';\r\n\r\n   };\r\n\r\n   Slick.prototype.swipeEnd = function(event) {\r\n\r\n       var _ = this,\r\n           slideCount,\r\n           direction;\r\n\r\n       _.dragging = false;\r\n       _.swiping = false;\r\n\r\n       if (_.scrolling) {\r\n           _.scrolling = false;\r\n           return false;\r\n       }\r\n\r\n       _.interrupted = false;\r\n       _.shouldClick = ( _.touchObject.swipeLength > 10 ) ? false : true;\r\n\r\n       if ( _.touchObject.curX === undefined ) {\r\n           return false;\r\n       }\r\n\r\n       if ( _.touchObject.edgeHit === true ) {\r\n           _.$slider.trigger('edge', [_, _.swipeDirection() ]);\r\n       }\r\n\r\n       if ( _.touchObject.swipeLength >= _.touchObject.minSwipe ) {\r\n\r\n           direction = _.swipeDirection();\r\n\r\n           switch ( direction ) {\r\n\r\n               case 'left':\r\n               case 'down':\r\n\r\n                   slideCount =\r\n                       _.options.swipeToSlide ?\r\n                           _.checkNavigable( _.currentSlide + _.getSlideCount() ) :\r\n                           _.currentSlide + _.getSlideCount();\r\n\r\n                   _.currentDirection = 0;\r\n\r\n                   break;\r\n\r\n               case 'right':\r\n               case 'up':\r\n\r\n                   slideCount =\r\n                       _.options.swipeToSlide ?\r\n                           _.checkNavigable( _.currentSlide - _.getSlideCount() ) :\r\n                           _.currentSlide - _.getSlideCount();\r\n\r\n                   _.currentDirection = 1;\r\n\r\n                   break;\r\n\r\n               default:\r\n\r\n\r\n           }\r\n\r\n           if( direction != 'vertical' ) {\r\n\r\n               _.slideHandler( slideCount );\r\n               _.touchObject = {};\r\n               _.$slider.trigger('swipe', [_, direction ]);\r\n\r\n           }\r\n\r\n       } else {\r\n\r\n           if ( _.touchObject.startX !== _.touchObject.curX ) {\r\n\r\n               _.slideHandler( _.currentSlide );\r\n               _.touchObject = {};\r\n\r\n           }\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.swipeHandler = function(event) {\r\n\r\n       var _ = this;\r\n\r\n       if ((_.options.swipe === false) || ('ontouchend' in document && _.options.swipe === false)) {\r\n           return;\r\n       } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {\r\n           return;\r\n       }\r\n\r\n       _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ?\r\n           event.originalEvent.touches.length : 1;\r\n\r\n       _.touchObject.minSwipe = _.listWidth / _.options\r\n           .touchThreshold;\r\n\r\n       if (_.options.verticalSwiping === true) {\r\n           _.touchObject.minSwipe = _.listHeight / _.options\r\n               .touchThreshold;\r\n       }\r\n\r\n       switch (event.data.action) {\r\n\r\n           case 'start':\r\n               _.swipeStart(event);\r\n               break;\r\n\r\n           case 'move':\r\n               _.swipeMove(event);\r\n               break;\r\n\r\n           case 'end':\r\n               _.swipeEnd(event);\r\n               break;\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.swipeMove = function(event) {\r\n\r\n       var _ = this,\r\n           edgeWasHit = false,\r\n           curLeft, swipeDirection, swipeLength, positionOffset, touches, verticalSwipeLength;\r\n\r\n       touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;\r\n\r\n       if (!_.dragging || _.scrolling || touches && touches.length !== 1) {\r\n           return false;\r\n       }\r\n\r\n       curLeft = _.getLeft(_.currentSlide);\r\n\r\n       _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;\r\n       _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;\r\n\r\n       _.touchObject.swipeLength = Math.round(Math.sqrt(\r\n           Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));\r\n\r\n       verticalSwipeLength = Math.round(Math.sqrt(\r\n           Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));\r\n\r\n       if (!_.options.verticalSwiping && !_.swiping && verticalSwipeLength > 4) {\r\n           _.scrolling = true;\r\n           return false;\r\n       }\r\n\r\n       if (_.options.verticalSwiping === true) {\r\n           _.touchObject.swipeLength = verticalSwipeLength;\r\n       }\r\n\r\n       swipeDirection = _.swipeDirection();\r\n\r\n       if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {\r\n           _.swiping = true;\r\n           event.preventDefault();\r\n       }\r\n\r\n       positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);\r\n       if (_.options.verticalSwiping === true) {\r\n           positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;\r\n       }\r\n\r\n\r\n       swipeLength = _.touchObject.swipeLength;\r\n\r\n       _.touchObject.edgeHit = false;\r\n\r\n       if (_.options.infinite === false) {\r\n           if ((_.currentSlide === 0 && swipeDirection === 'right') || (_.currentSlide >= _.getDotCount() && swipeDirection === 'left')) {\r\n               swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;\r\n               _.touchObject.edgeHit = true;\r\n           }\r\n       }\r\n\r\n       if (_.options.vertical === false) {\r\n           _.swipeLeft = curLeft + swipeLength * positionOffset;\r\n       } else {\r\n           _.swipeLeft = curLeft + (swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;\r\n       }\r\n       if (_.options.verticalSwiping === true) {\r\n           _.swipeLeft = curLeft + swipeLength * positionOffset;\r\n       }\r\n\r\n       if (_.options.fade === true || _.options.touchMove === false) {\r\n           return false;\r\n       }\r\n\r\n       if (_.animating === true) {\r\n           _.swipeLeft = null;\r\n           return false;\r\n       }\r\n\r\n       _.setCSS(_.swipeLeft);\r\n\r\n   };\r\n\r\n   Slick.prototype.swipeStart = function(event) {\r\n\r\n       var _ = this,\r\n           touches;\r\n\r\n       _.interrupted = true;\r\n\r\n       if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {\r\n           _.touchObject = {};\r\n           return false;\r\n       }\r\n\r\n       if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {\r\n           touches = event.originalEvent.touches[0];\r\n       }\r\n\r\n       _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;\r\n       _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;\r\n\r\n       _.dragging = true;\r\n\r\n   };\r\n\r\n   Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function() {\r\n\r\n       var _ = this;\r\n\r\n       if (_.$slidesCache !== null) {\r\n\r\n           _.unload();\r\n\r\n           _.$slideTrack.children(this.options.slide).detach();\r\n\r\n           _.$slidesCache.appendTo(_.$slideTrack);\r\n\r\n           _.reinit();\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.unload = function() {\r\n\r\n       var _ = this;\r\n\r\n       $('.slick-cloned', _.$slider).remove();\r\n\r\n       if (_.$dots) {\r\n           _.$dots.remove();\r\n       }\r\n\r\n       if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {\r\n           _.$prevArrow.remove();\r\n       }\r\n\r\n       if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {\r\n           _.$nextArrow.remove();\r\n       }\r\n\r\n       _.$slides\r\n           .removeClass('slick-slide slick-active slick-visible slick-current')\r\n           .attr('aria-hidden', 'true')\r\n           .css('width', '');\r\n\r\n   };\r\n\r\n   Slick.prototype.unslick = function(fromBreakpoint) {\r\n\r\n       var _ = this;\r\n       _.$slider.trigger('unslick', [_, fromBreakpoint]);\r\n       _.destroy();\r\n\r\n   };\r\n\r\n   Slick.prototype.updateArrows = function() {\r\n\r\n       var _ = this,\r\n           centerOffset;\r\n\r\n       centerOffset = Math.floor(_.options.slidesToShow / 2);\r\n\r\n       if ( _.options.arrows === true &&\r\n           _.slideCount > _.options.slidesToShow &&\r\n           !_.options.infinite ) {\r\n\r\n           _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\r\n           _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\r\n\r\n           if (_.currentSlide === 0) {\r\n\r\n               _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');\r\n               _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\r\n\r\n           } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {\r\n\r\n               _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');\r\n               _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\r\n\r\n           } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {\r\n\r\n               _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');\r\n               _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\r\n\r\n           }\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.updateDots = function() {\r\n\r\n       var _ = this;\r\n\r\n       if (_.$dots !== null) {\r\n\r\n           _.$dots\r\n               .find('li')\r\n                   .removeClass('slick-active')\r\n                   .end();\r\n\r\n           _.$dots\r\n               .find('li')\r\n               .eq(Math.floor(_.currentSlide / _.options.slidesToScroll))\r\n               .addClass('slick-active');\r\n\r\n       }\r\n\r\n   };\r\n\r\n   Slick.prototype.visibility = function() {\r\n\r\n       var _ = this;\r\n\r\n       if ( _.options.autoplay ) {\r\n\r\n           if ( document[_.hidden] ) {\r\n\r\n               _.interrupted = true;\r\n\r\n           } else {\r\n\r\n               _.interrupted = false;\r\n\r\n           }\r\n\r\n       }\r\n\r\n   };\r\n\r\n   $.fn.slick = function() {\r\n       var _ = this,\r\n           opt = arguments[0],\r\n           args = Array.prototype.slice.call(arguments, 1),\r\n           l = _.length,\r\n           i,\r\n           ret;\r\n       for (i = 0; i < l; i++) {\r\n           if (typeof opt == 'object' || typeof opt == 'undefined')\r\n               _[i].slick = new Slick(_[i], opt);\r\n           else\r\n               ret = _[i].slick[opt].apply(_[i].slick, args);\r\n           if (typeof ret != 'undefined') return ret;\r\n       }\r\n       return _;\r\n   };\r\n\r\n}));}\n\n//# sourceURL=webpack://gulp_2023/./src/js/modules/slic-slider.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/app.js");
/******/ 	
/******/ })()
;